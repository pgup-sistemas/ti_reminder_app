{"file_contents":{"README.md":{"content":"# TI OSN System - Sistema Profissional de Gerenciamento\n\nAplica√ß√£o web completa para gest√£o de lembretes, tarefas, chamados de TI, tutoriais e equipamentos, com painel de relat√≥rios, exporta√ß√£o de dados e interface intuitiva. Dispon√≠vel como Progressive Web App (PWA) com funcionalidade offline.\n\n## üìã √çndice\n- [Vis√£o Geral](#vis√£o-geral)\n- [Funcionalidades Principais](#funcionalidades-principais)\n  - [Gest√£o de Lembretes e Tarefas](#gest√£o-de-lembretes-e-tarefas)\n  - [Sistema de Chamados de TI](#sistema-de-chamados-de-ti)\n  - [Sistema de Tutoriais](#sistema-de-tutoriais)\n  - [Gest√£o de Equipamentos](#gest√£o-de-equipamentos)\n  - [Dashboard e Relat√≥rios](#dashboard-e-relat√≥rios)\n- [Progressive Web App (PWA)](#progressive-web-app-pwa)\n- [Stack Tecnol√≥gica](#stack-tecnol√≥gica)\n- [Estrutura do Projeto](#estrutura-do-projeto)\n- [Instala√ß√£o e Configura√ß√£o](#instala√ß√£o-e-configura√ß√£o)\n  - [Configura√ß√£o do PostgreSQL](#configura√ß√£o-do-postgresql)\n- [Como Utilizar](#como-utilizar)\n- [Planos de Implementa√ß√£o](#planos-de-implementa√ß√£o)\n  - [Plano de A√ß√£o - Melhorias](#plano-de-a√ß√£o---melhorias)\n  - [Plano de Implementa√ß√£o - Controle de Equipamentos](#plano-de-implementa√ß√£o---controle-de-equipamentos)\n- [Configura√ß√µes Avan√ßadas](#configura√ß√µes-avan√ßadas)\n- [Troubleshooting](#troubleshooting)\n- [Contribui√ß√£o](#contribui√ß√£o)\n\n## üéØ Vis√£o Geral\n\nO **TI OSN System** √© uma solu√ß√£o completa para gerenciamento de atividades de TI, desenvolvida para facilitar a organiza√ß√£o e o acompanhamento de tarefas di√°rias, lembretes recorrentes, solicita√ß√µes de suporte t√©cnico, tutoriais e gest√£o de equipamentos. O sistema centraliza todas as opera√ß√µes de TI em uma √∫nica plataforma, permitindo que usu√°rios de todos os setores possam registrar e acompanhar suas solicita√ß√µes de forma organizada e eficiente.\n\n### üöÄ Principais Benef√≠cios\n- **Centraliza√ß√£o**: Todas as opera√ß√µes de TI em um s√≥ lugar\n- **Automa√ß√£o**: Lembretes recorrentes com controle inteligente\n- **Rastreabilidade**: Hist√≥rico completo de todas as opera√ß√µes\n- **Relat√≥rios**: Exporta√ß√£o de dados em Excel e PDF\n- **Interface Responsiva**: Funciona em desktop e mobile\n- **Controle de Acesso**: Permiss√µes baseadas em roles\n\n## üîß Funcionalidades Principais\n\n### üìÖ Gest√£o de Lembretes e Tarefas\n- **Lembretes Recorrentes**: Di√°rios, quinzenais, mensais e anuais\n- **Controle Inteligente**: Pausar, reativar ou cancelar lembretes\n- **Data de Fim**: Definir t√©rmino autom√°tico da recorr√™ncia\n- **Status Visual**: Ativo, pausado, cancelado, conclu√≠do\n- **Filtros Avan√ßados**: Por status, data, respons√°vel, setor\n- **Recorr√™ncia Autom√°tica**: Cria√ß√£o autom√°tica de novos lembretes\n- **Notifica√ß√µes**: Alertas por e-mail para lembretes vencidos\n\n### üé´ Sistema de Chamados de TI\n- **Abertura de Chamados**: T√≠tulo, descri√ß√£o, prioridade e setor\n- **Acompanhamento**: Status em tempo real (Aberto, Em Andamento, Resolvido, Fechado)\n- **Coment√°rios**: Sistema de coment√°rios nos chamados\n- **Notifica√ß√µes**: E-mails autom√°ticos na abertura e atualiza√ß√£o\n- **Filtros**: Por status, prioridade, setor e data\n- **Relat√≥rios**: Exporta√ß√£o de chamados para Excel/PDF\n\n#### Funcionalidades Implementadas\n\n1. **Abertura de Novos Chamados:** Usu√°rios autenticados podem criar novos chamados para a TI atrav√©s de um formul√°rio dedicado. √â necess√°rio fornecer um t√≠tulo claro, uma descri√ß√£o detalhada do problema ou solicita√ß√£o e definir a prioridade inicial (Baixa, M√©dia, Alta, Cr√≠tica).\n\n2. **Listagem de Chamados:** Uma se√ß√£o permite visualizar os chamados existentes. Usu√°rios comuns podem ver os chamados que abriram ou os chamados relacionados ao seu setor. Administradores e a equipe de TI t√™m uma vis√£o completa de todos os chamados.\n\n3. **Filtros de Listagem:** A tela de listagem oferece filtros por status (Aberto, Em Andamento, Resolvido, Fechado), prioridade e, para administradores/TI, por setor. Isso facilita a localiza√ß√£o e o gerenciamento dos chamados.\n\n4. **Detalhes do Chamado:** √â poss√≠vel visualizar os detalhes completos de um chamado espec√≠fico, incluindo todas as informa√ß√µes registradas na abertura, datas de cria√ß√£o e atualiza√ß√£o, solicitante, setor e o respons√°vel pela TI (se atribu√≠do).\n\n5. **Notifica√ß√µes por E-mail:** Ao abrir um novo chamado, o sistema envia automaticamente notifica√ß√µes por e-mail para o usu√°rio solicitante e para a equipe de TI.\n\n#### Como Utilizar\n\n1. **Acessar:** Ap√≥s fazer login no sistema, acesse o menu \"Chamados\".\n2. **Abrir Chamado:** Clique em \"Abrir Novo Chamado\" na tela de listagem. Preencha o formul√°rio com t√≠tulo, descri√ß√£o e prioridade. Clique em \"Abrir Chamado\" para submeter.\n3. **Listar e Filtrar:** Acesse a se√ß√£o \"Chamados\" para ver a lista. Utilize os filtros na parte superior para refinar a visualiza√ß√£o por status, prioridade ou setor (se aplic√°vel).\n4. **Ver Detalhes:** Clique no bot√£o \"Detalhes\" na linha correspondente ao chamado na lista para visualizar todas as informa√ß√µes.\n\n### üìö Sistema de Tutoriais\n- **Cria√ß√£o de Tutoriais**: Suporte a Markdown e imagens\n- **Categoriza√ß√£o**: Organiza√ß√£o por categorias\n- **Coment√°rios e Feedback**: Sistema de avalia√ß√£o dos tutoriais\n- **Visualiza√ß√µes**: Controle de visualiza√ß√µes por tutorial\n- **Exporta√ß√£o PDF**: Gera√ß√£o de tutoriais em PDF\n- **Permiss√µes**: Apenas TI pode criar/editar tutoriais\n\n### üñ•Ô∏è Gest√£o de Equipamentos\n- **Solicita√ß√µes**: Formul√°rio completo para solicitar equipamentos\n- **Aprova√ß√£o**: Fluxo de aprova√ß√£o por TI/Admin\n- **Dados T√©cnicos**: Preenchimento de especifica√ß√µes t√©cnicas\n- **Controle de Status**: Solicitado, Aprovado, Entregue, Devolvido, Negado\n- **Rastreamento**: Hist√≥rico completo de movimenta√ß√µes\n\n#### Campos do Modelo\n\n##### Campos Principais\n- **Descri√ß√£o** - Descri√ß√£o detalhada do equipamento\n- **Patrim√¥nio** - N√∫mero do patrim√¥nio do equipamento\n- **Data de entrega** - Data prevista/real da entrega\n- **Solicitante** - Usu√°rio que solicitou o equipamento\n- **Data de devolu√ß√£o** - Data de devolu√ß√£o do equipamento\n- **Confer√™ncia** - Status de confer√™ncia do equipamento\n- **Observa√ß√£o** - Observa√ß√µes adicionais\n- **Quem recebeu** - Usu√°rio que recebeu o equipamento\n\n##### Campos Adicionais Essenciais\n- **Status** - (Solicitado, Aprovado, Entregue, Devolvido, Negado)\n- **Data da solicita√ß√£o** - Data autom√°tica da solicita√ß√£o\n- **Quem aprovou** - Usu√°rio TI que aprovou a solicita√ß√£o\n- **Data de aprova√ß√£o** - Data em que foi aprovado\n- **Tipo de equipamento** - Categoria (notebook, monitor, etc.)\n- **Setor/Destino** - Para onde o equipamento vai\n- **Motivo da solicita√ß√£o** - Justificativa da solicita√ß√£o\n\n#### Fluxo de Usu√°rio\n\n##### Para Usu√°rio Comum:\n1. Acessar \"Equipamentos\" no menu\n2. Clicar em \"Nova Solicita√ß√£o\"\n3. Preencher formul√°rio com dados do equipamento\n4. Enviar solicita√ß√£o\n5. Acompanhar status na listagem\n\n##### Para TI/Admin:\n1. Acessar \"Equipamentos\" no menu\n2. Ver todas as solicita√ß√µes pendentes\n3. Aprovar ou recusar solicita√ß√µes\n4. Marcar como entregue quando equipamento for entregue\n5. Marcar como devolvido quando equipamento for devolvido\n\n### üìä Dashboard e Relat√≥rios\n- **M√©tricas em Tempo Real**: Contadores de atividades\n- **Gr√°ficos Interativos**: Visualiza√ß√£o de dados por per√≠odo\n- **Filtros Din√¢micos**: Por setor, usu√°rio e per√≠odo\n- **Exporta√ß√£o**: Excel e PDF com formata√ß√£o profissional\n- **An√°lises**: Tend√™ncias e estat√≠sticas de uso\n\n### üë• Gest√£o de Usu√°rios\n- **Controle de Acesso**: Admin, TI e Usu√°rio comum\n- **Gest√£o de Setores**: Cria√ß√£o e administra√ß√£o de setores\n- **Perfis**: Edi√ß√£o de dados pessoais e setoriais\n- **Ativa√ß√£o/Desativa√ß√£o**: Controle de acesso de usu√°rios\n\n## üì± Progressive Web App (PWA)\n\n### Vis√£o Geral\nO TI OSN System funciona como um Progressive Web App (PWA), permitindo que os usu√°rios instalem o aplicativo em seus dispositivos e acessem funcionalidades mesmo quando estiverem offline. Esta funcionalidade melhora significativamente a experi√™ncia do usu√°rio, garantindo acesso cont√≠nuo ao sistema independentemente do status da conex√£o.\n\n### üîÑ Funcionalidades Offline\n- **Navega√ß√£o Offline**: Acesso √†s p√°ginas j√° visitadas mesmo sem conex√£o com a internet\n- **Cache Inteligente**: Armazenamento de recursos est√°ticos e dados importantes\n- **Sincroniza√ß√£o em Segundo Plano**: Envio autom√°tico de dados quando a conex√£o for restabelecida\n- **P√°gina Offline Personalizada**: Interface amig√°vel informando o status de conex√£o\n- **Armazenamento Local**: Dados tempor√°rios salvos no dispositivo at√© a reconex√£o\n\n### üîÑ Como Funciona o Modo Offline\n\n1. **Primeira Visita**:\n   - O Service Worker √© registrado e instalado automaticamente\n   - Recursos essenciais s√£o armazenados em cache (HTML, CSS, JS, imagens)\n   - Dados b√°sicos s√£o sincronizados para uso offline\n   - O cache inicial inclui a p√°gina offline personalizada\n\n   ```javascript\n   // Trecho do sw.js - Instala√ß√£o do Service Worker\n   self.addEventListener('install', event => {\n       console.log('[SW] Installing...');\n       event.waitUntil(\n           caches.open(CACHE_NAME)\n               .then(cache => {\n                   console.log('[SW] Caching static assets');\n                   return cache.addAll(STATIC_ASSETS);\n               })\n               .then(() => {\n                   console.log('[SW] Installation complete');\n                   return self.skipWaiting();\n               })\n       );\n   });\n   ```\n\n2. **Durante a Navega√ß√£o**:\n   - P√°ginas visitadas s√£o automaticamente armazenadas em cache\n   - Dados importantes s√£o salvos localmente\n   - Interface indica quando o usu√°rio est√° trabalhando offline atrav√©s de um badge visual\n   - O `OfflineManager` monitora constantemente o status da conex√£o\n\n   ```javascript\n   // Trecho do offline-support.js - Monitoramento de conex√£o\n   window.addEventListener('online', () => {\n       this.isOnline = true;\n       this.showConnectionStatus('online');\n       this.syncPendingData();\n   });\n\n   window.addEventListener('offline', () => {\n       this.isOnline = false;\n       this.showConnectionStatus('offline');\n   });\n   ```\n\n3. **Quando Offline**:\n   - O sistema detecta a falta de conex√£o usando `navigator.onLine`\n   - Recursos s√£o servidos do cache local atrav√©s do Service Worker\n   - Novas a√ß√µes (criar tarefas, atualizar lembretes) s√£o interceptadas e armazenadas no localStorage\n   - P√°gina offline personalizada (`offline.html`) √© exibida para rotas n√£o cacheadas\n   - Um indicador visual mostra ao usu√°rio que est√° trabalhando no modo offline\n\n   ```javascript\n   // Trecho do sw.js - Fallback para p√°gina offline\n   .catch(() => {\n       // P√°gina offline para navega√ß√£o\n       if (request.mode === 'navigate') {\n           return caches.match(OFFLINE_URL);\n       }\n   });\n   ```\n\n4. **Ao Reconectar**:\n   - Detec√ß√£o autom√°tica de conex√£o restabelecida atrav√©s do evento 'online'\n   - Sincroniza√ß√£o em segundo plano dos dados pendentes usando Background Sync API\n   - Os formul√°rios armazenados no localStorage s√£o enviados ao servidor\n   - Atualiza√ß√£o do cache com novos dados do servidor\n   - Notifica√ß√£o ao usu√°rio sobre a sincroniza√ß√£o bem-sucedida\n\n   ```javascript\n   // Trecho do offline-support.js - Sincroniza√ß√£o de dados\n   async syncPendingData() {\n       const pendingForms = JSON.parse(localStorage.getItem('pendingForms') || '[]');\n       \n       if (pendingForms.length === 0) return;\n\n       let syncCount = 0;\n       const errors = [];\n\n       for (const formData of pendingForms) {\n           try {\n               const response = await fetch(formData.action, {\n                   method: formData.method,\n                   headers: {\n                       'Content-Type': 'application/x-www-form-urlencoded',\n                   },\n                   body: new URLSearchParams(formData.data)\n               });\n\n               if (response.ok) {\n                   syncCount++;\n                   // Remover do localStorage\n                   const remaining = pendingForms.filter(f => f.key !== formData.key);\n                   localStorage.setItem('pendingForms', JSON.stringify(remaining));\n               }\n           } catch (error) {\n               errors.push(`Erro de rede: ${error.message}`);\n           }\n       }\n\n       // Mostrar resultados\n       if (syncCount > 0) {\n           window.components.toast('success', 'Sincroniza√ß√£o', \n               `${syncCount} formul√°rio(s) sincronizado(s) com sucesso!`);\n       }\n   }\n   ```\n\n### üîî Notifica√ß√µes Push\n\n#### Tipos de Notifica√ß√µes\n- **Lembretes Vencendo**: Notifica√ß√µes para lembretes pr√≥ximos do vencimento\n- **Chamados Atualizados**: Alertas sobre atualiza√ß√µes em chamados\n- **Tarefas Vencidas**: Avisos sobre tarefas em atraso\n- **Notifica√ß√µes Manuais**: Sistema de notifica√ß√µes para eventos importantes\n\n#### Implementa√ß√£o\n- **Controle de Permiss√µes**: Solicita√ß√£o e gerenciamento de permiss√µes de notifica√ß√£o\n- **Personaliza√ß√£o**: √çcones, sons e a√ß√µes personalizadas nas notifica√ß√µes\n- **Polling Autom√°tico**: Verifica√ß√£o peri√≥dica de atualiza√ß√µes\n\n```javascript\n// Trecho do notifications.js - Solicita√ß√£o de permiss√£o\nasync requestPermission() {\n    if (Notification.permission === 'granted') {\n        return 'granted';\n    }\n\n    if (Notification.permission !== 'denied') {\n        const permission = await Notification.requestPermission();\n        return permission;\n    }\n\n    return Notification.permission;\n}\n\n// Trecho do notifications.js - Verifica√ß√£o de atualiza√ß√µes\nasync checkForUpdates() {\n    try {\n        const response = await fetch('/api/notifications');\n        const data = JSON.parse(await response.text());\n        \n        // Lembretes vencendo\n        if (data.reminders_expiring && data.reminders_expiring.length > 0) {\n            data.reminders_expiring.forEach(reminder => {\n                this.showNotification('üîî Lembrete Vencendo!', {\n                    body: `${reminder.name} - Respons√°vel: ${reminder.responsible}`,\n                    tag: `reminder-${reminder.id}`,\n                    requireInteraction: true\n                });\n            });\n        }\n\n        // Chamados atualizados e tarefas vencidas...\n    } catch (error) {\n        console.error('Erro ao verificar notifica√ß√µes:', error);\n    }\n}\n\n// Trecho do sw.js - Tratamento de eventos de notifica√ß√£o\nself.addEventListener('push', event => {\n    const options = {\n        body: event.data ? event.data.text() : 'Nova notifica√ß√£o do TI OSN System',\n        icon: '/static/icons/icon-192x192.png',\n        badge: '/static/icons/badge-72x72.png',\n        vibrate: [100, 50, 100],\n        actions: [\n            {\n                action: 'explore',\n                title: 'Ver detalhes',\n                icon: '/static/icons/checkmark.png'\n            },\n            {\n                action: 'close',\n                title: 'Fechar',\n                icon: '/static/icons/xmark.png'\n            }\n        ]\n    };\n\n    event.waitUntil(\n        self.registration.showNotification('TI OSN System', options)\n    );\n});\n```\n\n#### Fluxo de Notifica√ß√µes\n1. **Inicializa√ß√£o**: Ao carregar a p√°gina, o sistema solicita permiss√£o para notifica√ß√µes\n2. **Verifica√ß√£o Peri√≥dica**: A cada minuto, o sistema verifica atualiza√ß√µes no servidor\n3. **Exibi√ß√£o**: Notifica√ß√µes s√£o exibidas com √≠cones e a√ß√µes personalizadas\n4. **Intera√ß√£o**: O usu√°rio pode interagir com as notifica√ß√µes para navegar diretamente para o conte√∫do relevante\n5. **Auto-fechamento**: Notifica√ß√µes s√£o automaticamente fechadas ap√≥s 10 segundos se n√£o houver intera√ß√£o\n\n### üì≤ Instala√ß√£o do PWA\n\n#### Recursos de Instala√ß√£o\n- **Chrome/Edge**: Clique no √≠cone de instala√ß√£o na barra de endere√ßos ou no menu \"Instalar App\"\n- **Firefox**: Clique no menu e selecione \"Instalar\" quando a op√ß√£o aparecer\n- **Safari (iOS)**: Toque em \"Compartilhar\" e depois em \"Adicionar √† Tela de In√≠cio\"\n- **P√°gina Dedicada**: Interface espec√≠fica com instru√ß√µes de instala√ß√£o em `/install-pwa`\n- **Atalhos**: Acesso r√°pido a funcionalidades espec√≠ficas direto da tela inicial\n\n#### Implementa√ß√£o\n\n```javascript\n// Trecho do install_pwa.html - Captura do evento de instala√ß√£o\nlet deferredPrompt;\n\nwindow.addEventListener('beforeinstallprompt', (e) => {\n    // Previne o comportamento padr√£o do navegador\n    e.preventDefault();\n    // Armazena o evento para uso posterior\n    deferredPrompt = e;\n    // Exibe o bot√£o de instala√ß√£o\n    document.getElementById('installButton').style.display = 'block';\n});\n\n// Trecho do install_pwa.html - Manipula√ß√£o do bot√£o de instala√ß√£o\ndocument.getElementById('installButton').addEventListener('click', async () => {\n    if (deferredPrompt) {\n        // Mostra o prompt de instala√ß√£o\n        deferredPrompt.prompt();\n        // Aguarda a escolha do usu√°rio\n        const { outcome } = await deferredPrompt.userChoice;\n        // Registra a escolha do usu√°rio\n        console.log(`Usu√°rio ${outcome === 'accepted' ? 'aceitou' : 'recusou'} a instala√ß√£o`);\n        // Limpa a refer√™ncia ao prompt\n        deferredPrompt = null;\n        // Esconde o bot√£o de instala√ß√£o\n        document.getElementById('installButton').style.display = 'none';\n        \n        if (outcome === 'accepted') {\n            // Exibe mensagem de sucesso\n            showToast('Aplicativo instalado com sucesso!', 'success');\n        }\n    }\n});\n```\n\n#### Benef√≠cios Destacados na Interface\n1. **Acesso R√°pido**: √çcone na tela inicial para acesso com um toque\n2. **Experi√™ncia Imersiva**: Interface em tela cheia sem elementos do navegador\n3. **Notifica√ß√µes Push**: Receba alertas mesmo com o aplicativo fechado\n4. **Funcionamento Offline**: Acesse recursos essenciais sem conex√£o √† internet\n5. **Sincroniza√ß√£o Autom√°tica**: Dados enviados automaticamente quando a conex√£o for restaurada\n\n#### Processo de Instala√ß√£o\n1. O usu√°rio acessa a p√°gina de instala√ß√£o ou recebe o prompt autom√°tico\n2. O sistema detecta o navegador e exibe instru√ß√µes espec√≠ficas\n3. Ao clicar em \"Instalar Agora\", o prompt nativo do navegador √© exibido\n4. Ap√≥s a confirma√ß√£o, o aplicativo √© instalado e pode ser acessado como um aplicativo nativo\n\n### ‚öôÔ∏è Implementa√ß√£o T√©cnica\n- **Service Worker (sw.js)**:\n  - Gerencia o ciclo de vida do cache e intercepta requisi√ß√µes de rede\n  - Implementa diferentes estrat√©gias de cache para diferentes tipos de conte√∫do\n  - Gerencia eventos de sincroniza√ß√£o em segundo plano e notifica√ß√µes push\n  - Fornece uma p√°gina offline personalizada quando n√£o h√° conex√£o\n  - Registrado automaticamente em `base.html` quando o navegador suporta\n\n- **Manifest.json**:\n  - Define metadados do aplicativo (nome, descri√ß√£o, √≠cones, cores)\n  - Configura comportamento de instala√ß√£o e exibi√ß√£o (standalone)\n  - Define atalhos para funcionalidades principais (Novo Lembrete, Nova Tarefa, Abrir Chamado)\n  - Especifica screenshots para diferentes dispositivos\n  - Configura orienta√ß√£o e tema do aplicativo\n\n- **Estrat√©gias de Cache**:\n  - **Cache First**: Para recursos est√°ticos (CSS, JS, imagens)\n    ```javascript\n    // Exemplo do sw.js\n    if (STATIC_ASSETS.includes(url.pathname) || url.pathname.startsWith('/static/')) {\n        event.respondWith(\n            caches.match(request)\n                .then(response => {\n                    return response || fetch(request);\n                })\n        );\n    }\n    ```\n  - **Network First**: Para APIs e conte√∫do din√¢mico\n    ```javascript\n    // Exemplo do sw.js\n    if (url.pathname.startsWith('/api/') || request.method !== 'GET') {\n        event.respondWith(\n            fetch(request)\n                .then(response => {\n                    // Cache successful responses\n                    if (response.status === 200) {\n                        const responseClone = response.clone();\n                        caches.open(CACHE_NAME)\n                            .then(cache => {\n                                cache.put(request, responseClone);\n                            });\n                    }\n                    return response;\n                })\n                .catch(() => {\n                    // Fallback para cache se offline\n                    return caches.match(request);\n                })\n        );\n    }\n    ```\n  - **Stale-While-Revalidate**: Para conte√∫do que pode ser atualizado em segundo plano\n  - **Fallback Offline**: P√°gina personalizada quando n√£o h√° conex√£o\n\n- **Gerenciamento de Dados Offline**:\n  - **OfflineManager**: Classe JavaScript que gerencia o estado de conex√£o\n  - **Intercepta√ß√£o de Formul√°rios**: Armazena dados de formul√°rios enviados offline\n  - **Sincroniza√ß√£o Autom√°tica**: Envia dados armazenados quando a conex√£o √© restabelecida\n  - **Indicador Visual**: Badge que mostra o status de conex√£o atual\n\n- **APIs Utilizadas**:\n  - **Cache API**: Armazenamento de recursos para uso offline\n  - **IndexedDB**: Armazenamento estruturado de dados para sincroniza√ß√£o\n  - **Background Sync API**: Sincroniza√ß√£o de dados quando a conex√£o √© restabelecida\n    ```javascript\n    // Exemplo do sw.js\n    self.addEventListener('sync', event => {\n        if (event.tag === 'background-sync-reminders') {\n            event.waitUntil(syncReminders());\n        }\n        if (event.tag === 'background-sync-tasks') {\n            event.waitUntil(syncTasks());\n        }\n    });\n    ```\n  - **Notification API**: Gerenciamento de notifica√ß√µes push\n  - **Navigator.onLine**: Detec√ß√£o de status de conex√£o\n  - **localStorage**: Armazenamento tempor√°rio de dados offline\n\n## üõ†Ô∏è Stack Tecnol√≥gica\n\n### Backend\n- **Python 3.7+**: Linguagem principal\n- **Flask 3.1.1**: Framework web\n- **SQLAlchemy 2.0.41**: ORM para banco de dados\n- **Flask-WTF 1.2.2**: Formul√°rios e valida√ß√£o\n- **Flask-Mail 0.10.0**: Envio de e-mails\n- **APScheduler 3.11.0**: Tarefas agendadas\n- **Alembic 1.16.1**: Migra√ß√µes de banco\n\n### Frontend\n- **Bootstrap 5**: Framework CSS responsivo\n- **Font Awesome**: √çcones\n- **JavaScript**: Interatividade e AJAX\n- **Chart.js**: Gr√°ficos interativos\n\n### Banco de Dados\n- **SQLite**: Banco padr√£o (desenvolvimento)\n- **PostgreSQL**: Banco de produ√ß√£o (opcional)\n\n### Bibliotecas de Suporte\n- **Pandas 2.2.3**: Manipula√ß√£o de dados\n- **XlsxWriter 3.2.3**: Exporta√ß√£o Excel\n- **ReportLab 4.4.1**: Gera√ß√£o de PDFs\n- **Markdown 3.8.2**: Formata√ß√£o de texto\n- **python-dateutil 2.9.0**: Manipula√ß√£o de datas\n\n## üìÅ Estrutura do Projeto\n\n```\nti_reminder_app/\n‚îú‚îÄ‚îÄ app/\n‚îÇ   ‚îú‚îÄ‚îÄ __init__.py              # Configura√ß√£o da aplica√ß√£o\n‚îÇ   ‚îú‚îÄ‚îÄ routes.py                # Rotas principais\n‚îÇ   ‚îú‚îÄ‚îÄ models.py                # Modelos do banco de dados\n‚îÇ   ‚îú‚îÄ‚îÄ forms.py                 # Formul√°rios\n‚îÇ   ‚îú‚îÄ‚îÄ auth.py                  # Autentica√ß√£o\n‚îÇ   ‚îú‚îÄ‚îÄ auth_utils.py            # Utilit√°rios de autentica√ß√£o\n‚îÇ   ‚îú‚îÄ‚îÄ forms_auth.py            # Formul√°rios de auth\n‚îÇ   ‚îú‚îÄ‚îÄ email_utils.py           # Utilit√°rios de e-mail\n‚îÇ   ‚îú‚îÄ‚îÄ templates/               # Templates HTML\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ base.html           # Template base\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.html          # P√°gina inicial\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ reminders.html      # Gest√£o de lembretes\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tasks.html          # Gest√£o de tarefas\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dashboard.html      # Dashboard\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ users.html          # Gest√£o de usu√°rios\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tutoriais.html      # Lista de tutoriais\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tutorial_form.html  # Formul√°rio de tutoriais\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tutorial_detalhe.html # Detalhes do tutorial\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ chamados/           # Templates de chamados\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ equipment/          # Templates de equipamentos\n‚îÇ   ‚îî‚îÄ‚îÄ static/                 # Arquivos est√°ticos\n‚îÇ       ‚îú‚îÄ‚îÄ style.css           # Estilos CSS\n‚îÇ       ‚îú‚îÄ‚îÄ js/                 # JavaScript\n‚îÇ       ‚îú‚îÄ‚îÄ icons/              # √çcones PWA\n‚îÇ       ‚îú‚îÄ‚îÄ manifest.json       # Manifest PWA\n‚îÇ       ‚îî‚îÄ‚îÄ sw.js              # Service Worker\n‚îú‚îÄ‚îÄ migrations/                 # Migra√ß√µes do banco\n‚îú‚îÄ‚îÄ instance/                   # Banco de dados\n‚îú‚îÄ‚îÄ config.py                   # Configura√ß√µes\n‚îú‚îÄ‚îÄ run.py                      # Script de execu√ß√£o\n‚îú‚îÄ‚îÄ requirements.txt            # Depend√™ncias\n‚îú‚îÄ‚îÄ wsgi.py                     # WSGI para produ√ß√£o\n‚îî‚îÄ‚îÄ README.md                   # Esta documenta√ß√£o\n```\n\n## üöÄ Instala√ß√£o e Configura√ß√£o\n\n### Pr√©-requisitos\n- **Python 3.7 ou superior**\n- **pip** (gerenciador de pacotes Python)\n- **Git** (para clonar o reposit√≥rio)\n\n### Passo a Passo\n\n#### 1. Clone o Reposit√≥rio\n```bash\ngit clone [URL_DO_REPOSITORIO]\ncd ti_reminder_app\n```\n\n#### 2. Crie o Ambiente Virtual\n```bash\n# Windows\npython -m venv venv\nvenv\\Scripts\\activate\n\n# Linux/macOS\npython -m venv venv\nsource venv/bin/activate\n```\n\n#### 3. Instale as Depend√™ncias\n```bash\npip install -r requirements.txt\n```\n\n#### 4. Configure as Vari√°veis de Ambiente\nCrie um arquivo `.env` na raiz do projeto:\n\n```env\n# Configura√ß√µes B√°sicas\nSECRET_KEY=sua-chave-secreta-aqui\nFLASK_ENV=development\nFLASK_DEBUG=True\n\n# Banco de Dados (SQLite - padr√£o)\nDATABASE_URL=sqlite:///reminder.db\n\n# Banco de Dados (PostgreSQL - opcional)\n# DATABASE_URL=postgresql://postgres:postgres@localhost:5432/ti_reminder_db\n\n# Configura√ß√µes de E-mail\nMAIL_SERVER=smtp.gmail.com\nMAIL_PORT=587\nMAIL_USE_TLS=True\nMAIL_USERNAME=seu-email@gmail.com\nMAIL_PASSWORD=sua-senha-ou-app-password\nMAIL_DEFAULT_SENDER=seu-email@gmail.com\nTI_EMAIL=ti@empresa.com\n\n# Configura√ß√µes Opcionais\nUPLOAD_FOLDER=app/static/uploads\nMAX_CONTENT_LENGTH=16777216\n```\n\n#### 5. Inicialize o Banco de Dados\n```bash\n# Criar as tabelas\nflask db upgrade\n\n# Ou se preferir, execute o script de migra√ß√£o\npython migration_reminder_control.py\n```\n\n### Configura√ß√£o do PostgreSQL\n\n#### Pr√©-requisitos\n\n1. PostgreSQL instalado e em execu√ß√£o\n2. Python 3.8 ou superior\n3. Todas as depend√™ncias do projeto instaladas (`pip install -r requirements.txt`)\n\n#### Configura√ß√£o Autom√°tica\n\nO sistema foi configurado para inicializar automaticamente o banco de dados PostgreSQL na primeira execu√ß√£o. Siga os passos abaixo:\n\n1. Certifique-se de que o PostgreSQL est√° instalado e em execu√ß√£o\n2. Verifique se as credenciais no arquivo `.env` est√£o corretas:\n   ```\n   DATABASE_URL=postgresql://postgres:postgres@localhost:5432/ti_reminder_db\n   ```\n   Substitua `postgres:postgres` pelo seu usu√°rio e senha do PostgreSQL, se necess√°rio.\n3. Execute o aplicativo normalmente:\n   ```\n   python run.py\n   ```\n   Na primeira execu√ß√£o, o sistema ir√°:\n   - Criar o banco de dados `ti_reminder_db` se n√£o existir\n   - Inicializar as migra√ß√µes do Flask-Migrate\n   - Aplicar todas as migra√ß√µes necess√°rias\n\n#### Configura√ß√£o Manual\n\nSe preferir configurar manualmente o banco de dados, siga os passos abaixo:\n\n1. Certifique-se de que o PostgreSQL est√° instalado e em execu√ß√£o\n2. Verifique se as credenciais no arquivo `.env` est√£o corretas\n3. Execute o script de configura√ß√£o:\n   ```\n   python setup_postgres.py\n   ```\n   Este script ir√°:\n   - Criar o banco de dados `ti_reminder_db` se n√£o existir\n   - Inicializar as migra√ß√µes do Flask-Migrate\n   - Aplicar todas as migra√ß√µes necess√°rias\n\n#### Backup e Restaura√ß√£o\n\n##### Backup do Banco de Dados\n\n```bash\npg_dump -U postgres ti_reminder_db > backup_$(date +%Y%m%d).sql\n```\n\n##### Restaura√ß√£o do Backup\n\n```bash\npsql -U postgres ti_reminder_db < backup_20231201.sql\n```\n\n#### 6. Crie um Usu√°rio Administrador\n```bash\npython create_admin.py\n```\n\n#### 7. Execute a Aplica√ß√£o\n```bash\npython run.py\n```\n\n#### 8. Acesse a Aplica√ß√£o\nAbra seu navegador e acesse: **http://127.0.0.1:5000**\n\n### Configura√ß√£o de E-mail (Opcional)\n\nPara que as notifica√ß√µes funcionem:\n\n1. **Gmail**: Use \"App Password\" em vez da senha normal\n2. **Outros provedores**: Configure SMTP conforme necess√°rio\n3. **Teste**: Verifique se os e-mails est√£o sendo enviados\n\n## üìñ Como Utilizar\n\n### üîê Primeiro Acesso\n1. Acesse a aplica√ß√£o\n2. Fa√ßa login com as credenciais criadas\n3. Configure seu perfil e setor\n\n## üìã Planos de Implementa√ß√£o\n\n### Plano de A√ß√£o - Melhorias\n\nEste plano define a implementa√ß√£o das funcionalidades restantes do sistema TI OSN System, organizadas por prioridade e depend√™ncias.\n\n#### FASE 1: CONTROLE DE LEMBRETES (Prioridade ALTA)\n\n**Objetivo**: Completar a funcionalidade de controle de lembretes recorrentes\n\n1. **Atualizar L√≥gica de Recorr√™ncia**\n2. **Adicionar Rota de Controle de Status**\n3. **Atualizar Formul√°rio de Lembretes**\n4. **Atualizar Template de Lembretes**\n\n#### FASE 2: SEGURAN√áA AVAN√áADA (Prioridade ALTA)\n\n**Objetivo**: Implementar autentica√ß√£o de dois fatores e logs de auditoria\n\n1. **Instalar Depend√™ncias**\n2. **Criar Modelo de Logs de Auditoria**\n3. **Adicionar Campos 2FA ao Usu√°rio**\n4. **Criar Utilit√°rio de Auditoria**\n5. **Implementar 2FA**\n\n### Plano de Implementa√ß√£o - Controle de Equipamentos\n\n**Objetivo**: Implementa√ß√£o de funcionalidade para controle de equipamentos solicitados para o setor de TI, permitindo solicita√ß√£o, aprova√ß√£o, entrega e devolu√ß√£o de equipamentos.\n\n#### Plano de Implementa√ß√£o Detalhado\n\n##### Fase 1: Modelo de Dados\n1. **Criar modelo `EquipmentRequest`** em `app/models.py`\n2. **Criar migration** para a nova tabela\n3. **Executar migration** para criar a tabela no banco\n\n##### Fase 2: Rotas e Controllers\n4. **Criar rotas** em `app/routes.py`\n\n##### Fase 3: Templates\n5. **Criar templates** para listagem, formul√°rio e detalhes\n\n##### Fase 4: Menu e Navega√ß√£o\n6. **Adicionar item no menu** \"Equipamentos\"\n7. **Configurar permiss√µes** (usu√°rio comum vs TI)\n\n##### Fase 5: Funcionalidades Avan√ßadas\n8. **Relat√≥rios** (opcional)\n9. **Notifica√ß√µes** (opcional)\n10. **Filtros e busca** (opcional)\n\n### üìÖ Gest√£o de Lembretes\n\n#### Criar um Lembrete\n1. Acesse **\"Lembretes\"** no menu\n2. Preencha o formul√°rio:\n   - **Nome**: Descri√ß√£o do lembrete\n   - **Tipo**: Categoria do lembrete\n   - **Vencimento**: Data de vencimento\n   - **Respons√°vel**: Quem deve executar\n   - **Frequ√™ncia**: Di√°rio, quinzenal, mensal, anual\n   - **Status**: Ativo, pausado, cancelado\n   - **Pausar at√©**: Data para pausa tempor√°ria\n   - **Data de fim**: T√©rmino da recorr√™ncia\n   - **Setor**: Setor respons√°vel\n\n#### Controle de Recorr√™ncia\n- **Pausar**: Clique no bot√£o ‚è∏Ô∏è para pausar temporariamente\n- **Reativar**: Clique no bot√£o ‚ñ∂Ô∏è para reativar\n- **Cancelar**: Mude o status para \"cancelado\"\n- **Data de fim**: Define quando a recorr√™ncia para automaticamente\n\n#### Marcar como Conclu√≠do\n- Clique no bot√£o ‚úÖ para marcar como realizado\n- Lembretes conclu√≠dos ficam em verde na lista\n\n### üé´ Sistema de Chamados\n\n#### Abrir um Chamado\n1. Acesse **\"Chamados\"** ‚Üí **\"Abrir Novo Chamado\"**\n2. Preencha:\n   - **T√≠tulo**: Resumo do problema\n   - **Descri√ß√£o**: Detalhes completos\n   - **Prioridade**: Baixa, M√©dia, Alta, Cr√≠tica\n3. Clique em **\"Abrir Chamado\"**\n\n#### Acompanhar Chamados\n- **Lista**: Veja todos os seus chamados\n- **Filtros**: Por status, prioridade, data\n- **Detalhes**: Clique no chamado para ver informa√ß√µes completas\n- **Coment√°rios**: Adicione coment√°rios para acompanhamento\n\n### üìö Tutoriais\n\n#### Criar Tutorial (TI/Admin)\n1. Acesse **\"Tutoriais\"** ‚Üí **\"Novo Tutorial\"**\n2. Preencha:\n   - **T√≠tulo**: Nome do tutorial\n   - **Categoria**: Organiza√ß√£o\n   - **Conte√∫do**: Use Markdown para formata√ß√£o\n   - **Imagens**: Adicione imagens explicativas\n3. Clique em **\"Salvar\"**\n\n#### Usar Tutoriais\n- **Lista**: Veja todos os tutoriais dispon√≠veis\n- **Busca**: Encontre tutoriais por t√≠tulo ou categoria\n- **Visualizar**: Clique para ver o tutorial completo\n- **Feedback**: Marque se foi √∫til ou n√£o\n- **Coment√°rios**: Adicione d√∫vidas ou sugest√µes\n- **Exportar**: Baixe em PDF\n\n### üñ•Ô∏è Equipamentos\n\n#### Solicitar Equipamento\n1. Acesse **\"Equipamentos\"** ‚Üí **\"Nova Solicita√ß√£o\"**\n2. Preencha:\n   - **Descri√ß√£o**: O que precisa\n   - **Tipo**: Computador, impressora, etc.\n   - **Motivo**: Justificativa da solicita√ß√£o\n   - **Setor de destino**: Onde ser√° usado\n   - **Data de entrega**: Quando precisa\n3. Clique em **\"Solicitar\"**\n\n#### Aprovar/Rejeitar (TI/Admin)\n- **Lista**: Veja todas as solicita√ß√µes\n- **Aprovar**: Mude status para \"Aprovado\"\n- **Rejeitar**: Mude status para \"Negado\"\n- **Dados t√©cnicos**: Preencha especifica√ß√µes\n- **Entregar**: Confirme a entrega\n\n### üìä Dashboard e Relat√≥rios\n\n#### Visualizar Dashboard\n- **M√©tricas**: Contadores em tempo real\n- **Gr√°ficos**: Tend√™ncias por per√≠odo\n- **Filtros**: Por setor, usu√°rio, data\n- **Atualiza√ß√£o**: Dados atualizados automaticamente\n\n#### Exportar Relat√≥rios\n1. Acesse **\"Dashboard\"**\n2. Configure os filtros desejados\n3. Clique em **\"Exportar Excel\"** ou **\"Exportar PDF\"**\n4. Baixe o arquivo gerado\n\n## ‚öôÔ∏è Configura√ß√µes Avan√ßadas\n\n### Configura√ß√£o de Banco de Dados\n\n#### SQLite (Padr√£o)\n```python\n# config.py\nSQLALCHEMY_DATABASE_URI = 'sqlite:///reminder.db'\n```\n\n#### PostgreSQL (Produ√ß√£o)\n```python\n# config.py\nSQLALCHEMY_DATABASE_URI = 'postgresql://user:password@localhost/ti_reminder'\n```\n\n### Configura√ß√£o de E-mail\n\n#### Gmail\n```env\nMAIL_SERVER=smtp.gmail.com\nMAIL_PORT=587\nMAIL_USE_TLS=True\nMAIL_USERNAME=seu-email@gmail.com\nMAIL_PASSWORD=sua-app-password\n```\n\n#### Outlook/Hotmail\n```env\nMAIL_SERVER=smtp-mail.outlook.com\nMAIL_PORT=587\nMAIL_USE_TLS=True\n```\n\n### Configura√ß√£o de Upload\n\n```python\n# config.py\nUPLOAD_FOLDER = 'app/static/uploads'\nMAX_CONTENT_LENGTH = 16 * 1024 * 1024  # 16MB\nALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}\n```\n\n### Configura√ß√£o de Logs\n\n```python\n# config.py\nimport logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s %(levelname)s: %(message)s',\n    handlers=[\n        logging.FileHandler('ti_reminder.log'),\n        logging.StreamHandler()\n    ]\n)\n```\n\n## üîß Troubleshooting\n\n### Problemas Comuns\n\n#### Erro de M√≥dulo n√£o Encontrado\n```bash\n# Solu√ß√£o: Instalar depend√™ncias\npip install -r requirements.txt\n```\n\n#### Erro de Banco de Dados\n```bash\n# Solu√ß√£o: Recriar banco\nrm instance/reminder.db\nflask db upgrade\n```\n\n#### Erro de E-mail\n```bash\n# Verificar configura√ß√µes SMTP\n# Usar App Password para Gmail\n# Verificar firewall/antiv√≠rus\n```\n\n#### Erro de Permiss√µes\n```bash\n# Windows: Executar como administrador\n# Linux: sudo chmod +x run.py\n```\n\n#### Lembretes n√£o Recorrem\n```bash\n# Verificar se o scheduler est√° ativo\n# Verificar logs da aplica√ß√£o\n# Verificar status dos lembretes\n```\n\n### Logs e Debug\n\n#### Habilitar Debug\n```python\n# config.py\nFLASK_DEBUG = True\n```\n\n#### Verificar Logs\n```bash\n# Logs da aplica√ß√£o\ntail -f ti_reminder.log\n\n# Logs do sistema\njournalctl -u ti-reminder -f\n```\n\n### Backup e Restaura√ß√£o\n\n#### Backup do Banco\n```bash\n# SQLite\ncp instance/reminder.db backup_$(date +%Y%m%d).db\n\n# PostgreSQL\npg_dump ti_reminder > backup_$(date +%Y%m%d).sql\n```\n\n#### Restaurar Backup\n```bash\n# SQLite\ncp backup_20231201.db instance/reminder.db\n\n# PostgreSQL\npsql ti_reminder < backup_20231201.sql\n```\n\n## ü§ù Contribui√ß√£o\n\n### Como Contribuir\n\n1. **Fork** o projeto\n2. **Crie** uma branch para sua feature\n3. **Commit** suas mudan√ßas\n4. **Push** para a branch\n5. **Abra** um Pull Request\n\n### Padr√µes de C√≥digo\n\n- **Python**: PEP 8\n- **HTML**: Indenta√ß√£o de 2 espa√ßos\n- **CSS**: BEM methodology\n- **JavaScript**: ES6+\n\n### Testes\n\n```bash\n# Executar testes\npython -m pytest tests/\n\n# Cobertura de c√≥digo\npython -m pytest --cov=app tests/\n```\n\n## üìÑ Licen√ßa\n\nEste projeto est√° sob a licen√ßa MIT. Veja o arquivo `LICENSE` para mais detalhes.\n\n## üìû Suporte\n\n### Contato\n- **Email**: suporte@ti-reminder.com\n- **Issues**: [GitHub Issues](https://github.com/seu-usuario/ti-reminder/issues)\n- **Documenta√ß√£o**: [Wiki](https://github.com/seu-usuario/ti-reminder/wiki)\n\n### Comunidade\n- **Discord**: [Servidor da Comunidade](https://discord.gg/ti-reminder)\n- **Telegram**: [Grupo de Usu√°rios](https://t.me/ti-reminder)\n\n---\n\n**PageUp Sistemas Desenvolvido com ‚ù§Ô∏è por O√©zios Normando**\n\n*√öltima atualiza√ß√£o: Dezembro 2024*\n","size_bytes":36564},"config.py":{"content":"import os\n\nclass Config:\n    SECRET_KEY = os.environ.get('SECRET_KEY') or 'changeme'\n    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL') or 'sqlite:///reminder.db'\n    SQLALCHEMY_TRACK_MODIFICATIONS = False\n    MAIL_SERVER = 'smtp.gmail.com'\n    MAIL_PORT = 587\n    MAIL_USE_TLS = True\n    MAIL_USERNAME = os.environ.get('MAIL_USERNAME')\n    MAIL_PASSWORD = os.environ.get('MAIL_PASSWORD')\n    MAIL_DEFAULT_SENDER = os.environ.get('MAIL_DEFAULT_SENDER') or 'reminder@example.com'\n","size_bytes":489},"create_admin_postgres.py":{"content":"import sys\nimport os\nsys.path.insert(0, os.path.abspath(os.path.dirname(__file__)))\nfrom flask import Flask\nfrom app.models import db, User\nfrom dotenv import load_dotenv\n\n# Carregar vari√°veis de ambiente\nload_dotenv()\n\n# Altere conforme desejado\nADMIN_USERNAME = 'admin'\nADMIN_EMAIL = 'admin@admin.com'\nADMIN_PASSWORD = 'admin123'\n\n# Criar aplica√ß√£o Flask com configura√ß√£o expl√≠cita para PostgreSQL\napp = Flask(__name__)\napp.config['SQLALCHEMY_DATABASE_URI'] = os.environ.get('DATABASE_URL')\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\ndb.init_app(app)\n\nwith app.app_context():\n    # Verificar se o usu√°rio admin j√° existe\n    if not User.query.filter_by(username=ADMIN_USERNAME).first():\n        user = User(\n            username=ADMIN_USERNAME,\n            email=ADMIN_EMAIL,\n            is_admin=True,\n            ativo=True\n        )\n        user.set_password(ADMIN_PASSWORD)\n        db.session.add(user)\n        db.session.commit()\n        print('Usu√°rio admin criado com sucesso!')\n    else:\n        print('Usu√°rio admin j√° existe.')","size_bytes":1060},"fix_migrations.py":{"content":"import os\nimport sys\nimport psycopg2\nfrom urllib.parse import urlparse\nfrom dotenv import load_dotenv\n\n# Carregar vari√°veis de ambiente\nload_dotenv()\n\ndef fix_migrations():\n    \"\"\"\n    Corrige problemas com migra√ß√µes duplicadas.\n    Remove a migra√ß√£o conflitante e limpa o estado do banco de dados.\n    \n    Returns:\n        bool: True se a corre√ß√£o foi bem-sucedida, False caso contr√°rio.\n    \"\"\"\n    try:\n        print(\"=== Corre√ß√£o de Migra√ß√µes do TI Reminder App ===\")\n        print(\"Este script ir√° corrigir problemas com migra√ß√µes duplicadas.\")\n        print(\"ATEN√á√ÉO: Este processo pode causar perda de dados se executado incorretamente.\")\n        \n        confirm = input(\"\\nDeseja prosseguir com a corre√ß√£o? (s/n): \")\n        if confirm.lower() != 's':\n            print(\"Corre√ß√£o cancelada.\")\n            return False\n        \n        # Obter a URL do banco de dados do arquivo .env\n        database_url = os.environ.get('DATABASE_URL')\n        \n        if not database_url or not database_url.startswith('postgresql'):\n            print(\"Erro: DATABASE_URL n√£o configurada ou n√£o √© PostgreSQL.\")\n            print(\"Verifique o arquivo .env e configure DATABASE_URL=postgresql://usuario:senha@localhost:5432/ti_reminder_db\")\n            return False\n        \n        # Parsear a URL do banco de dados\n        url = urlparse(database_url)\n        dbname = url.path[1:]\n        user = url.username\n        password = url.password\n        host = url.hostname\n        port = url.port\n        \n        # Conectar ao banco de dados PostgreSQL\n        conn = psycopg2.connect(\n            dbname=dbname,\n            user=user,\n            password=password,\n            host=host,\n            port=port\n        )\n        conn.autocommit = True\n        cursor = conn.cursor()\n        \n        # 1. Remover a tabela alembic_version para limpar o estado das migra√ß√µes\n        print(\"\\nLimpando estado das migra√ß√µes...\")\n        cursor.execute(\"DROP TABLE IF EXISTS alembic_version;\")\n        print(\"Tabela alembic_version removida com sucesso.\")\n        \n        # 2. Remover o arquivo de flag para for√ßar a reinicializa√ß√£o\n        if os.path.exists('db_initialized.flag'):\n            os.remove('db_initialized.flag')\n            print(\"Arquivo de flag removido com sucesso.\")\n        \n        # 3. Remover migra√ß√µes conflitantes\n        migration_files = [\n            'migrations/versions/99c62be90766_initial.py',\n            'migrations/versions/aa0bcd2a67ee_initial.py'\n        ]\n        \n        for file in migration_files:\n            if os.path.exists(file):\n                os.remove(file)\n                print(f\"Arquivo de migra√ß√£o {file} removido com sucesso.\")\n        \n        # 4. Limpar o diret√≥rio de migra√ß√µes\n        if os.path.exists('migrations/versions/__pycache__'):\n            for file in os.listdir('migrations/versions/__pycache__'):\n                os.remove(os.path.join('migrations/versions/__pycache__', file))\n            print(\"Cache de migra√ß√µes limpo com sucesso.\")\n        \n        cursor.close()\n        conn.close()\n        \n        print(\"\\n=== Corre√ß√£o conclu√≠da com sucesso! ===\")\n        print(\"Agora voc√™ pode executar 'python run.py' para inicializar o banco de dados novamente.\")\n        return True\n    except Exception as e:\n        print(f\"Erro ao corrigir migra√ß√µes: {str(e)}\")\n        return False\n\nif __name__ == \"__main__\":\n    fix_migrations()","size_bytes":3444},"init_db.py":{"content":"import os\nimport sys\nimport psycopg2\nfrom urllib.parse import urlparse\nfrom flask import Flask\nfrom flask_migrate import Migrate\nfrom dotenv import load_dotenv\n\n# Carregar vari√°veis de ambiente\nload_dotenv()\n\ndef init_postgres_db():\n    \"\"\"\n    Inicializa o banco de dados PostgreSQL.\n    Cria o banco de dados se n√£o existir.\n    \n    Returns:\n        bool: True se a inicializa√ß√£o foi bem-sucedida, False caso contr√°rio.\n    \"\"\"\n    try:\n        # Obter a URL do banco de dados do arquivo .env\n        database_url = os.environ.get('DATABASE_URL')\n        \n        if not database_url or not database_url.startswith('postgresql'):\n            print(\"Erro: DATABASE_URL n√£o configurada ou n√£o √© PostgreSQL.\")\n            print(\"Verifique o arquivo .env e configure DATABASE_URL=postgresql://usuario:senha@localhost:5432/ti_reminder_db\")\n            return False\n        \n        # Parsear a URL do banco de dados\n        url = urlparse(database_url)\n        dbname = url.path[1:]\n        user = url.username\n        password = url.password\n        host = url.hostname\n        port = url.port\n        \n        # Conectar ao servidor PostgreSQL (banco postgres padr√£o)\n        conn = psycopg2.connect(\n            dbname=\"postgres\",\n            user=user,\n            password=password,\n            host=host,\n            port=port\n        )\n        conn.autocommit = True\n        cursor = conn.cursor()\n        \n        # Verificar se o banco de dados j√° existe\n        cursor.execute(f\"SELECT 1 FROM pg_catalog.pg_database WHERE datname = '{dbname}'\")\n        exists = cursor.fetchone()\n        \n        if not exists:\n            # Criar o banco de dados\n            cursor.execute(f\"CREATE DATABASE {dbname}\")\n            print(f\"Banco de dados '{dbname}' criado com sucesso!\")\n        else:\n            print(f\"Banco de dados '{dbname}' j√° existe.\")\n        \n        cursor.close()\n        conn.close()\n        \n        return True\n    except Exception as e:\n        print(f\"Erro ao inicializar banco de dados PostgreSQL: {str(e)}\")\n        return False\n\ndef init_migrations():\n    \"\"\"\n    Inicializa as migra√ß√µes do Flask-Migrate.\n    \n    Returns:\n        bool: True se a inicializa√ß√£o foi bem-sucedida, False caso contr√°rio.\n    \"\"\"\n    try:\n        # Criar uma aplica√ß√£o Flask tempor√°ria para inicializar as migra√ß√µes\n        app = Flask(__name__)\n        app.config['SQLALCHEMY_DATABASE_URI'] = os.environ.get('DATABASE_URL')\n        app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\n        \n        # Importar os modelos e inicializar o banco de dados\n        from app.models import db\n        db.init_app(app)\n        \n        # Inicializar o Flask-Migrate\n        migrate = Migrate(app, db)\n        \n        with app.app_context():\n            # Verificar se a pasta migrations/versions existe\n            if not os.path.exists('migrations/versions'):\n                # Se n√£o existir, criar a estrutura de migra√ß√µes\n                os.system('flask db init')\n                \n                # Criar uma migra√ß√£o inicial se n√£o houver nenhuma\n                if not os.listdir('migrations/versions'):\n                    os.system('flask db migrate -m \"initial\"')\n                \n                # Aplicar as migra√ß√µes\n                os.system('flask db upgrade')\n            else:\n                # Se j√° existem migra√ß√µes, apenas verificar se h√° altera√ß√µes pendentes\n                # e aplicar as migra√ß√µes existentes sem criar novas\n                print(\"Migra√ß√µes j√° existem. Aplicando migra√ß√µes existentes...\")\n                os.system('flask db upgrade')\n        \n        return True\n    except Exception as e:\n        print(f\"Erro ao inicializar migra√ß√µes: {str(e)}\")\n        return False\n\nif __name__ == \"__main__\":\n    # Se executado diretamente, inicializar o banco de dados e as migra√ß√µes\n    if init_postgres_db():\n        print(\"Banco de dados PostgreSQL inicializado com sucesso!\")\n        if init_migrations():\n            print(\"Migra√ß√µes inicializadas com sucesso!\")\n            # Criar arquivo de flag\n            with open('db_initialized.flag', 'w') as f:\n                f.write('1')\n        else:\n            print(\"Falha ao inicializar migra√ß√µes.\")\n    else:\n        print(\"Falha ao inicializar banco de dados PostgreSQL.\")","size_bytes":4318},"replit.md":{"content":"# TI OSN System - Replit Environment Setup\n\n## Project Overview\nThis is the TI OSN System, a comprehensive IT management web application built with Flask. The system provides management for reminders, tasks, support tickets, tutorials, and equipment with features like Progressive Web App (PWA) support, offline functionality, and a professional dashboard.\n\n## Current Status\n‚úÖ **Setup Complete** - The application is successfully running in the Replit environment.\n\n## Recent Changes (September 05, 2025)\n- Configured Python 3.11 environment\n- Installed all required Flask dependencies\n- Configured PostgreSQL database connection (using Replit's built-in PostgreSQL)\n- Set up Flask application to run on 0.0.0.0:5000 for Replit proxy compatibility\n- Configured workflow to run the Flask server\n- Set up deployment configuration for autoscale deployment with Gunicorn\n\n## Project Architecture\n- **Backend**: Flask 3.1.2 with SQLAlchemy, APScheduler, Flask-Mail\n- **Database**: PostgreSQL (heliumdb) with Alembic migrations\n- **Frontend**: Bootstrap 5 + JavaScript (PWA-enabled)\n- **Features**: Authentication, Dashboard, Reminders, Tasks, Support Tickets, Tutorials, Equipment Management\n- **Deployment**: Gunicorn WSGI server for production\n\n## Environment Configuration\n- **Host**: 0.0.0.0 (required for Replit proxy)\n- **Port**: 5000 (required by Replit)\n- **Database**: PostgreSQL (configured via DATABASE_URL environment variable)\n- **Debug Mode**: Enabled in development\n- **PWA**: Service Worker and manifest.json configured\n\n## Key Files\n- `run.py`: Main application entry point\n- `app/__init__.py`: Flask app factory\n- `config.py`: Application configuration\n- `wsgi.py`: WSGI entry point for production\n- `requirements.txt`: Python dependencies\n- Database initialization handled by `init_db.py`\n\n## Database Status\n- PostgreSQL connection configured and working\n- Database initialized with existing flag system\n- Migrations managed through Flask-Migrate/Alembic\n\n## Workflow Configuration\n- **Flask Server**: Runs `python run.py` on port 5000\n- **Output Type**: webview (for website preview)\n- **Auto-restart**: Enabled\n\n## Deployment Configuration\n- **Target**: autoscale (stateless web application)\n- **Production Server**: Gunicorn with reuse-port for performance\n- **Command**: `gunicorn --bind=0.0.0.0:5000 --reuse-port wsgi:app`\n\n## User Preferences\n- Standard Flask development practices\n- Bootstrap UI framework\n- PostgreSQL database preference\n- PWA functionality enabled","size_bytes":2491},"run.py":{"content":"from app import create_app\nimport logging\nimport sys\nimport socket\nimport os\nfrom init_db import init_postgres_db, init_migrations\n\n# Configure logging\nlogging.basicConfig(level=logging.DEBUG)\nlogger = logging.getLogger(__name__)\n\n# Inicializar banco de dados PostgreSQL se necess√°rio\ntry:\n    # Verificar se √© a primeira execu√ß√£o\n    db_initialized = os.path.exists('db_initialized.flag')\n    if not db_initialized:\n        logger.info(\"Inicializando banco de dados PostgreSQL...\")\n        if init_postgres_db():\n            logger.info(\"Inicializando migra√ß√µes do Flask...\")\n            init_migrations()\n            # Criar arquivo de flag para indicar que o banco foi inicializado\n            with open('db_initialized.flag', 'w') as f:\n                f.write('1')\n            logger.info(\"Configura√ß√£o do banco de dados conclu√≠da com sucesso!\")\n        else:\n            logger.error(\"Falha na configura√ß√£o do banco de dados.\")\n    else:\n        logger.info(\"Banco de dados j√° inicializado anteriormente.\")\n\n    # Criar aplica√ß√£o\n    app = create_app()\n    logger.info(\"Application created successfully\")\nexcept Exception as e:\n    logger.error(f\"Error creating application: {str(e)}\")\n    raise\n\nif __name__ == '__main__':\n    try:\n        modo_rede = '--rede' in sys.argv\n        if modo_rede:\n            # Descobre IP local real (IPv4, n√£o localhost)\n            import re\n            local_ip = None\n            try:\n                # Tenta obter o IP real da rede local (ignora localhost)\n                s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n                s.connect(('8.8.8.8', 80))\n                local_ip = s.getsockname()[0]\n            except Exception as e:\n                logger.error(f\"Error getting local IP: {str(e)}\")\n                # Fallback para hostname\n                local_ip = socket.gethostbyname(socket.gethostname())\n            finally:\n                s.close()\n            # Confirma que n√£o √© localhost\n            if local_ip.startswith('127.') or local_ip == '0.0.0.0':\n                # Busca todos os IPs poss√≠veis\n                ips = socket.getaddrinfo(socket.gethostname(), None)\n                for result in ips:\n                    ip = result[4][0]\n                    if re.match(r'^192\\.168\\.', ip):\n                        local_ip = ip\n                        break\n            logger.info(f\"Starting in network mode on {local_ip}\")\n            print(f'\\n>>> Servidor dispon√≠vel na rede: http://{local_ip}:5000/ <<<\\n')\n            app.run(debug=True, host='0.0.0.0')\n        else:\n            logger.info(\"Starting in debug mode\")\n            app.run(debug=True, host='0.0.0.0', port=5000)\n    except Exception as e:\n        logger.error(f\"Error starting application: {str(e)}\")\n        raise\n\n","size_bytes":2788},"setup_postgres.py":{"content":"import os\nimport sys\nfrom init_db import init_postgres_db, init_migrations\n\ndef setup_postgres():\n    print(\"=== Configura√ß√£o do PostgreSQL para o TI Reminder App ===\")\n    print(\"Este script ir√° criar o banco de dados PostgreSQL e inicializar as migra√ß√µes.\")\n    print(\"Certifique-se de que o PostgreSQL est√° instalado e em execu√ß√£o.\")\n    print(\"\\nConfigura√ß√£o atual (arquivo .env):\")\n    \n    # Ler configura√ß√£o atual\n    with open('.env', 'r') as f:\n        for line in f:\n            if line.startswith('DATABASE_URL='):\n                print(f\"  {line.strip()}\")\n    \n    confirm = input(\"\\nDeseja prosseguir com a configura√ß√£o? (s/n): \")\n    if confirm.lower() != 's':\n        print(\"Configura√ß√£o cancelada.\")\n        return\n    \n    # Inicializar banco de dados\n    print(\"\\nInicializando banco de dados PostgreSQL...\")\n    if init_postgres_db():\n        print(\"Banco de dados PostgreSQL inicializado com sucesso!\")\n        \n        # Inicializar migra√ß√µes\n        print(\"\\nInicializando migra√ß√µes do Flask...\")\n        if init_migrations():\n            print(\"Migra√ß√µes inicializadas com sucesso!\")\n            \n            # Criar arquivo de flag\n            with open('db_initialized.flag', 'w') as f:\n                f.write('1')\n            \n            print(\"\\n=== Configura√ß√£o conclu√≠da com sucesso! ===\")\n            print(\"O sistema est√° pronto para ser executado com PostgreSQL.\")\n            print(\"Execute 'python run.py' para iniciar a aplica√ß√£o.\")\n        else:\n            print(\"Falha ao inicializar migra√ß√µes.\")\n    else:\n        print(\"Falha ao inicializar banco de dados PostgreSQL.\")\n\nif __name__ == \"__main__\":\n    setup_postgres()","size_bytes":1691},"wsgi.py":{"content":"from app import create_app\n\napp = create_app()\n","size_bytes":47},"app/__init__.py":{"content":"from flask import Flask\nfrom flask_sqlalchemy import SQLAlchemy\nfrom flask_mail import Mail\nfrom flask_apscheduler import APScheduler\nfrom flask_migrate import Migrate\nfrom flask_bootstrap import Bootstrap\nfrom .email_utils import mail_init_app\n\nmail = Mail()\ndb = SQLAlchemy()\nscheduler = APScheduler()\nmigrate = Migrate()\nbootstrap = Bootstrap()\n\ndef create_app():\n    app = Flask(__name__)\n    app.config.from_object('config.Config')\n    db.init_app(app)\n    mail_init_app(app, mail)\n    scheduler.init_app(app)\n    scheduler.start()\n    migrate.init_app(app, db)\n    bootstrap.init_app(app)\n\n    from . import routes\n    app.register_blueprint(routes.bp)\n\n    # Registrar blueprint de autentica√ß√£o\n    from .auth import bp_auth\n    app.register_blueprint(bp_auth, url_prefix='/auth')\n\n    return app\n","size_bytes":806},"app/auth.py":{"content":"from flask import Blueprint, render_template, redirect, url_for, flash, request, session\nfrom .forms_auth import RegistrationForm, LoginForm, RequestPasswordResetForm, ResetPasswordForm\nfrom .models import User, db\nfrom werkzeug.security import generate_password_hash, check_password_hash\nfrom flask_mail import Message\nfrom . import mail\n\nbp_auth = Blueprint('auth', __name__)\n\n@bp_auth.route('/register', methods=['GET', 'POST'])\ndef register():\n    form = RegistrationForm()\n    if form.validate_on_submit():\n        # Verifica se j√° existe um usu√°rio com o mesmo nome de usu√°rio ou email\n        existing_user = User.query.filter(\n            (User.username == form.username.data) | \n            (User.email == form.email.data)\n        ).first()\n        \n        if existing_user:\n            flash('Nome de usu√°rio ou email j√° est√° em uso.', 'danger')\n            return render_template('register.html', form=form)\n            \n        user = User(\n            username=form.username.data, \n            email=form.email.data,\n            is_admin=False,  # Usu√°rios comuns n√£o s√£o administradores\n            is_ti=False,     # Nem fazem parte da equipe de TI\n            ativo=True\n        )\n        user.set_password(form.password.data)\n        \n        try:\n            db.session.add(user)\n            db.session.commit()\n            flash('Usu√°rio registrado com sucesso! Fa√ßa login.', 'success')\n            return redirect(url_for('auth.login'))\n        except Exception as e:\n            db.session.rollback()\n            flash('Ocorreu um erro ao registrar o usu√°rio. Por favor, tente novamente.', 'danger')\n            \n    return render_template('register.html', form=form)\n\n@bp_auth.route('/login', methods=['GET', 'POST'])\ndef login():\n    form = LoginForm()\n    if form.validate_on_submit():\n        user = User.query.filter_by(username=form.username.data).first()\n        if user and user.check_password(form.password.data):\n            session['user_id'] = user.id\n            session['username'] = user.username\n            session['is_admin'] = user.is_admin\n            flash('Login realizado com sucesso!', 'success')\n            return redirect(url_for('main.dashboard'))\n        else:\n            return redirect(url_for('auth.login', error='invalid_credentials'))\n    return render_template('login.html', form=form)\n\n@bp_auth.route('/logout')\ndef logout():\n    session.clear()\n    flash('Logout realizado.', 'info')\n    return redirect(url_for('auth.login'))\n\n@bp_auth.route('/reset_password_request', methods=['GET', 'POST'])\ndef reset_password_request():\n    # Se o usu√°rio j√° est√° logado, redireciona para a p√°gina principal\n    if 'user_id' in session:\n        return redirect(url_for('main.dashboard'))\n    \n    form = RequestPasswordResetForm()\n    if form.validate_on_submit():\n        user = User.query.filter_by(email=form.email.data).first()\n        if user:\n            token = user.generate_reset_token()\n            from .email_utils import send_password_reset_email\n            send_password_reset_email(user, token)\n            flash('Um email com instru√ß√µes para redefinir sua senha foi enviado.', 'info')\n            return redirect(url_for('auth.login'))\n        else:\n            flash('Email n√£o encontrado.', 'danger')\n    \n    return render_template('reset_password_request.html', form=form)\n\n@bp_auth.route('/reset_password/<token>', methods=['GET', 'POST'])\ndef reset_password(token):\n    # Se o usu√°rio j√° est√° logado, redireciona para a p√°gina principal\n    if 'user_id' in session:\n        return redirect(url_for('main.dashboard'))\n    \n    # Encontrar o usu√°rio com este token\n    user = User.query.filter_by(reset_token=token).first()\n    \n    if not user or not user.verify_reset_token(token):\n        flash('O link de redefini√ß√£o de senha √© inv√°lido ou expirou.', 'danger')\n        return redirect(url_for('auth.reset_password_request'))\n    \n    form = ResetPasswordForm()\n    if form.validate_on_submit():\n        user.set_password(form.password.data)\n        user.clear_reset_token()\n        db.session.commit()\n        flash('Sua senha foi redefinida com sucesso!', 'success')\n        return redirect(url_for('auth.login'))\n    \n    return render_template('reset_password.html', form=form)\n","size_bytes":4282},"app/auth_utils.py":{"content":"from functools import wraps\nfrom flask import session, redirect, url_for, flash\n\ndef login_required(f):\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        if 'user_id' not in session:\n            return redirect(url_for('auth.login', need_login=True))\n        # Bloqueia usu√°rios inativos\n        from .models import User\n        user = User.query.get(session['user_id'])\n        if user and not user.ativo:\n            session.clear()\n            flash('Seu acesso foi desativado pelo administrador.', 'danger')\n            return redirect(url_for('auth.login'))\n        return f(*args, **kwargs)\n    return decorated_function\n\ndef admin_required(view_func):\n    @wraps(view_func)\n    def wrapped_view(*args, **kwargs):\n        if 'user_id' not in session or not session.get('is_admin', False):\n            flash('Acesso restrito ao administrador.', 'danger')\n            return redirect(url_for('main.dashboard'))\n        return view_func(*args, **kwargs)\n    return wrapped_view\n","size_bytes":999},"app/email_utils.py":{"content":"from flask_mail import Mail, Message\nfrom flask import current_app\n\nmail = Mail()\n\ndef mail_init_app(app, mail_instance):\n    global mail\n    mail = mail_instance\n    mail.init_app(app)\n\ndef send_email(subject, recipients, body, html_body=None):\n    # Ensure we are using the mail instance initialized with the app context\n    # This might require passing 'mail' around or using current_app.extensions['mail']\n    # For simplicity, assuming 'mail' is globally accessible after init\n    try:\n        msg = Message(subject, recipients=recipients, body=body, html=html_body)\n        # Ensure sender is configured, fallback to default if needed\n        if not msg.sender:\n             msg.sender = current_app.config.get('MAIL_DEFAULT_SENDER')\n        mail.send(msg)\n        print(f\"Email sent to {recipients} with subject: {subject}\") # Log success\n    except Exception as e:\n        print(f\"Error sending email: {e}\") # Log error\n        # Handle error appropriately (log, flash message, etc.)\n\ndef send_chamado_aberto_email(chamado):\n    user_email = chamado.solicitante.email\n    # Define TI email recipient(s) - maybe from config or a specific group\n    ti_recipients = [current_app.config.get('TI_EMAIL_GROUP', 'ti@example.com')] # Example\n    \n    subject_user = f\"Chamado #{chamado.id} Aberto: {chamado.titulo}\"\n    body_user = f\"\"\"Ol√° {chamado.solicitante.username},\n\nSeu chamado \"{chamado.titulo}\" (ID: {chamado.id}) foi aberto com sucesso.\n\nPrioridade: {chamado.prioridade}\nStatus: {chamado.status}\n\nVoc√™ pode acompanhar o status em [link para o chamado].\n\nObrigado,\nSistema de Chamados TI\"\"\"\n    # Potentially add HTML version\n    send_email(subject_user, [user_email], body_user)\n\n    subject_ti = f\"Novo Chamado #{chamado.id} Aberto por {chamado.solicitante.username} ({chamado.setor.name}): {chamado.titulo}\"\n    body_ti = f\"Um novo chamado foi aberto:\\n\\nID: {chamado.id}\\nT√≠tulo: {chamado.titulo}\\nSolicitante: {chamado.solicitante.username} ({chamado.solicitante.email})\\nSetor: {chamado.setor.name}\\nPrioridade: {chamado.prioridade}\\nStatus: {chamado.status}\\nDescri√ß√£o:\\n{chamado.descricao}\\n\\nAcesse o sistema para mais detalhes e atribui√ß√£o.\"\n    # Potentially add HTML version\n    send_email(subject_ti, ti_recipients, body_ti)\n    \ndef send_password_reset_email(user, token):\n    \"\"\"Envia um email com instru√ß√µes para redefinir a senha\"\"\"\n    reset_url = f\"{current_app.config.get('BASE_URL', 'http://localhost:5000')}/auth/reset_password/{token}\"\n    \n    subject = \"Redefini√ß√£o de Senha - TI OSN System\"\n    body = f\"\"\"Ol√° {user.username},\n\nVoc√™ solicitou a redefini√ß√£o de sua senha no TI OSN System.\n\nPara redefinir sua senha, clique no link abaixo ou copie e cole no seu navegador:\n\n{reset_url}\n\nEste link √© v√°lido por 1 hora.\n\nSe voc√™ n√£o solicitou esta redefini√ß√£o, ignore este email e nenhuma altera√ß√£o ser√° feita.\n\nAtenciosamente,\nEquipe TI OSN System\"\"\"\n    \n    html_body = f\"\"\"<p>Ol√° {user.username},</p>\n<p>Voc√™ solicitou a redefini√ß√£o de sua senha no TI OSN System.</p>\n<p>Para redefinir sua senha, <a href=\"{reset_url}\">clique aqui</a> ou copie e cole o link abaixo no seu navegador:</p>\n<p>{reset_url}</p>\n<p>Este link √© v√°lido por 1 hora.</p>\n<p>Se voc√™ n√£o solicitou esta redefini√ß√£o, ignore este email e nenhuma altera√ß√£o ser√° feita.</p>\n<p>Atenciosamente,<br>Equipe TI OSN System</p>\"\"\"\n    \n    send_email(subject, [user.email], body, html_body)\n\ndef send_chamado_atualizado_email(chamado, atualizacao):\n    \"\"\"Envia e-mail de notifica√ß√£o quando um chamado √© atualizado\"\"\"\n    from flask import url_for, render_template_string\n    \n    # Destinat√°rios: solicitante e respons√°vel TI (se houver)\n    recipients = [chamado.solicitante.email]\n    if chamado.responsavel_ti and chamado.responsavel_ti.email != chamado.solicitante.email:\n        recipients.append(chamado.responsavel_ti.email)\n    \n    # URL do chamado (usando _external=True para URL completa)\n    chamado_url = url_for('main.detalhe_chamado', id=chamado.id, _external=True)\n    \n    # Assunto do e-mail\n    subject = f\"Atualiza√ß√£o no Chamado #{chamado.id}: {chamado.titulo}\"\n    \n    # Corpo do e-mail em texto simples\n    body = f\"\"\"Ol√°,\n\nO chamado \"{chamado.titulo}\" (ID: {chamado.id}) foi atualizado.\n\nAtualiza√ß√£o: {atualizacao.texto}\n\nStatus atual: {chamado.status}\nRespons√°vel TI: {chamado.responsavel_ti.username if chamado.responsavel_ti else 'N√£o atribu√≠do'}\n\nAcesse o chamado em: {chamado_url}\n\nAtenciosamente,\nSistema de Chamados TI\"\"\"\n    \n    # Corpo do e-mail em HTML\n    # Definir a cor do badge com base no status\n    status_color = (\n        '#198754' if chamado.status == 'Resolvido' else \n        '#fd7e14' if chamado.status == 'Em Andamento' else \n        '#dc3545' if chamado.status == 'Fechado' else '#0d6efd'\n    )\n    \n    html_body = f\"\"\"\n    <!DOCTYPE html>\n    <html>\n    <head>\n        <meta charset=\"UTF-8\">\n        <title>{subject}</title>\n        <style>\n            body {{ font-family: Arial, sans-serif; line-height: 1.6; }}\n            .container {{ max-width: 600px; margin: 0 auto; padding: 20px; }}\n            .header {{ background-color: #f8f9fa; padding: 15px; border-radius: 5px; margin-bottom: 20px; }}\n            .chamado-info {{ margin-bottom: 20px; }}\n            .status-badge {{\n                display: inline-block;\n                padding: 3px 8px;\n                border-radius: 3px;\n                font-size: 0.9em;\n                font-weight: bold;\n                color: white;\n            }}\n            .btn-primary {{\n                display: inline-block;\n                padding: 10px 20px;\n                background-color: #0d6efd;\n                color: white;\n                text-decoration: none;\n                border-radius: 5px;\n                margin-top: 15px;\n            }}\n            .footer {{ margin-top: 30px; font-size: 0.9em; color: #6c757d; }}\n        </style>\n    </head>\n    <body>\n        <div class=\"container\">\n            <div class=\"header\">\n                <h2>Atualiza√ß√£o no Chamado #{chamado.id}</h2>\n                <h3>{chamado.titulo}</h3>\n            </div>\n            \n            <div class=\"chamado-info\">\n                <p><strong>Atualiza√ß√£o:</strong> {atualizacao.texto}</p>\n                <p>\n                    <strong>Status:</strong> \n                    <span class=\"status-badge\" style=\"background-color: {status_color}\">\n                        {chamado.status}\n                    </span>\n                </p>\n                <p><strong>Respons√°vel TI:</strong> {chamado.responsavel_ti.username if chamado.responsavel_ti else 'N√£o atribu√≠do'}</p>\n                <p><strong>Data da Atualiza√ß√£o:</strong> {atualizacao.data_criacao.strftime('%d/%m/%Y %H:%M:%S')}</p>\n            </div>\n            \n            <a href=\"{chamado_url}\" class=\"btn-primary\">Ver Detalhes do Chamado</a>\n            \n            <div class=\"footer\">\n                <p>Este √© um e-mail autom√°tico, por favor n√£o responda.</p>\n                <p>Atenciosamente,<br>Sistema de Chamados TI</p>\n            </div>\n        </div>\n    </body>\n    </html>\n    \"\"\"\n    \n    # Envia o e-mail\n    send_email(subject, recipients, body, html_body)\n\n\n\n","size_bytes":7197},"app/forms.py":{"content":"from flask_wtf import FlaskForm\nfrom wtforms import StringField, DateField, SelectField, BooleanField, SubmitField, PasswordField, ValidationError, TextAreaField\nfrom wtforms.validators import DataRequired, Length, EqualTo, Optional\nfrom flask_wtf.file import FileAllowed, FileField\n\nclass ReminderForm(FlaskForm):\n    name = StringField('Nome', validators=[DataRequired()])\n    type = StringField('Tipo', validators=[DataRequired()])\n    due_date = DateField('Vencimento', validators=[DataRequired()])\n    responsible = StringField('Respons√°vel', validators=[DataRequired()])\n    frequency = SelectField('Frequ√™ncia', choices=[('','Nenhuma'),('diario','Di√°rio'),('quinzenal','Quinzenal'),('mensal','Mensal'),('anual','Anual')])\n    sector_id = SelectField('Setor', coerce=int, choices=[], validators=[])\n    new_sector = StringField('Novo setor')\n    status = SelectField('Status', choices=[\n        ('ativo','Ativo'),\n        ('pausado','Pausado'),\n        ('cancelado','Cancelado')\n    ], default='ativo')\n    pause_until = DateField('Pausar at√©', validators=[Optional()])\n    end_date = DateField('Data de fim', validators=[Optional()])\n    submit = SubmitField('Salvar')\n\nclass TaskForm(FlaskForm):\n    description = StringField('Descri√ß√£o', validators=[DataRequired()])\n    date = DateField('Data', validators=[DataRequired()])\n    responsible = StringField('Respons√°vel', validators=[DataRequired()])\n    completed = BooleanField('Conclu√≠da')\n    sector_id = SelectField('Setor', coerce=int, choices=[], validators=[])\n    new_sector = StringField('Novo setor')\n    submit = SubmitField('Salvar')\n\nfrom wtforms import TextAreaField, SelectField, StringField, SubmitField, TextAreaField, BooleanField, validators\n\nclass ChamadoForm(FlaskForm):\n    titulo = StringField(\"T√≠tulo\", validators=[DataRequired()])\n    descricao = TextAreaField(\"Descri√ß√£o\", validators=[DataRequired()])\n    prioridade = SelectField(\"Prioridade\", choices=[(\"Baixa\", \"Baixa\"), (\"Media\", \"M√©dia\"), (\"Alta\", \"Alta\"), (\"Critica\", \"Cr√≠tica\")], default=\"Media\", validators=[DataRequired()])\n    setor_id = SelectField(\"Setor\", coerce=int, validators=[Optional()])\n    new_sector = StringField('Novo setor')\n    submit = SubmitField(\"Abrir Chamado\")\n    \n    def __init__(self, *args, **kwargs):\n        super(ChamadoForm, self).__init__(*args, **kwargs)\n        from .models import Sector\n        # Carrega os setores dispon√≠veis\n        self.setor_id.choices = [(0, '-- Selecione um setor --')] + [(s.id, s.name) for s in Sector.query.order_by('name').all()]\n\nclass UserRegisterForm(FlaskForm):\n    username = StringField('Nome de Usu√°rio', validators=[DataRequired()])\n    email = StringField('Email', validators=[DataRequired()])\n    password = PasswordField('Senha', validators=[\n        DataRequired(),\n        Length(min=6, message='A senha deve ter pelo menos 6 caracteres')\n    ])\n    confirm_password = PasswordField('Confirmar Senha', validators=[\n        DataRequired(),\n        EqualTo('password', message='As senhas n√£o conferem')\n    ])\n    is_admin = BooleanField('√â Administrador')\n    is_ti = BooleanField('√â da Equipe de TI')\n    submit = SubmitField('Registrar')\n\nclass UserEditForm(FlaskForm):\n    username = StringField('Nome de Usu√°rio', validators=[DataRequired()])\n    email = StringField('Email', validators=[DataRequired()])\n    is_admin = BooleanField('√â Administrador')\n    is_ti = BooleanField('√â da Equipe de TI')\n    sector_id = SelectField('Setor', coerce=int, validators=[Optional()], choices=[])\n    change_password = BooleanField('Alterar Senha')\n    new_password = PasswordField('Nova Senha', validators=[\n        Optional(),\n        Length(min=6, message='A senha deve ter pelo menos 6 caracteres')\n    ])\n    confirm_password = PasswordField('Confirmar Nova Senha', validators=[\n        Optional(),\n        EqualTo('new_password', message='As senhas n√£o conferem')\n    ])\n    submit = SubmitField('Salvar Altera√ß√µes')\n    \n    def __init__(self, *args, **kwargs):\n        super(UserEditForm, self).__init__(*args, **kwargs)\n        from .models import Sector\n        # Carrega os setores dispon√≠veis\n        self.sector_id.choices = [(0, '-- Selecione um setor --')] + [(s.id, s.name) for s in Sector.query.order_by('name').all()]\n\n    def validate(self, **kwargs):\n        # Executa as valida√ß√µes padr√£o primeiro\n        if not super().validate():\n            return False\n\n        # Valida√ß√£o personalizada para a senha\n        if self.change_password.data and not self.new_password.data:\n            self.new_password.errors.append('Por favor, insira a nova senha')\n            return False\n            \n        return True\n\nclass ChamadoAdminForm(FlaskForm):\n    \"\"\"Formul√°rio para a√ß√µes administrativas em chamados\"\"\"\n    status = SelectField('Status', choices=[\n        ('Aberto', 'Aberto'),\n        ('Em Andamento', 'Em Andamento'),\n        ('Pendente', 'Pendente'),\n        ('Resolvido', 'Resolvido'),\n        ('Fechado', 'Fechado')\n    ], validators=[validators.DataRequired()])\n    \n    # Usando StringField em vez de SelectField com coerce=int para evitar erros com valores vazios\n    responsavel_ti_id = StringField('Respons√°vel TI', validators=[validators.Optional()])\n    \n    comentario = TextAreaField('Adicionar Coment√°rio', validators=[\n        validators.Optional(),\n        validators.Length(max=1000, message='O coment√°rio n√£o pode ter mais que 1000 caracteres')\n    ])\n    \n    notificar_solicitante = BooleanField('Notificar solicitante', default=True)\n    \n    submit = SubmitField('Atualizar Chamado')\n    \n    def validate_responsavel_ti_id(self, field):\n        # Permite valor vazio ou um n√∫mero inteiro\n        if field.data and not field.data.strip():\n            field.data = None\n        elif field.data:\n            try:\n                # Tenta converter para inteiro, mas n√£o armazena o valor convertido\n                # apenas valida que √© um n√∫mero inteiro v√°lido\n                int(field.data)\n            except ValueError:\n                raise validators.ValidationError('ID do respons√°vel deve ser um n√∫mero inteiro')\n\nclass TutorialForm(FlaskForm):\n    titulo = StringField('T√≠tulo', validators=[DataRequired()])\n    conteudo = TextAreaField('Conte√∫do', validators=[DataRequired()])\n    categoria = StringField('Categoria', validators=[Optional()])\n    imagem = FileField('Imagem', validators=[FileAllowed(['jpg', 'jpeg', 'png', 'gif'], 'Apenas imagens s√£o permitidas!')])\n    submit = SubmitField('Salvar Tutorial')\n\nclass ComentarioTutorialForm(FlaskForm):\n    texto = TextAreaField('Coment√°rio', validators=[DataRequired()])\n    submit = SubmitField('Enviar Coment√°rio')\n\nclass FeedbackTutorialForm(FlaskForm):\n    util = BooleanField('Este tutorial foi √∫til para voc√™?')\n    submit = SubmitField('Enviar Feedback')\n\n","size_bytes":6829},"app/forms_auth.py":{"content":"from flask_wtf import FlaskForm\nfrom wtforms import StringField, PasswordField, BooleanField, SubmitField\nfrom wtforms.validators import DataRequired, Email, EqualTo, ValidationError, Length\nfrom .models import User\n\nclass RegistrationForm(FlaskForm):\n    username = StringField('Usu√°rio', validators=[DataRequired()])\n    email = StringField('Email', validators=[DataRequired(), Email()])\n    password = PasswordField('Senha', validators=[DataRequired()])\n    password2 = PasswordField('Repita a senha', validators=[DataRequired(), EqualTo('password')])\n    submit = SubmitField('Registrar')\n\n    def validate_username(self, username):\n        user = User.query.filter_by(username=username.data).first()\n        if user:\n            raise ValidationError('Nome de usu√°rio j√° existe.')\n\n    def validate_email(self, email):\n        user = User.query.filter_by(email=email.data).first()\n        if user:\n            raise ValidationError('Email j√° cadastrado.')\n\nclass LoginForm(FlaskForm):\n    username = StringField('Usu√°rio', validators=[DataRequired()])\n    password = PasswordField('Senha', validators=[DataRequired()])\n    remember_me = BooleanField('Lembrar-me')\n    submit = SubmitField('Entrar')\n\nclass RequestPasswordResetForm(FlaskForm):\n    email = StringField('Email', validators=[DataRequired(), Email()])\n    submit = SubmitField('Solicitar Redefini√ß√£o')\n    \n    def validate_email(self, email):\n        user = User.query.filter_by(email=email.data).first()\n        if not user:\n            raise ValidationError('N√£o existe uma conta com esse email.')\n\nclass ResetPasswordForm(FlaskForm):\n    password = PasswordField('Nova Senha', validators=[DataRequired(), Length(min=6)])\n    password2 = PasswordField('Confirmar Nova Senha', validators=[DataRequired(), EqualTo('password')])\n    submit = SubmitField('Redefinir Senha')\n","size_bytes":1848},"app/models.py":{"content":"from flask_sqlalchemy import SQLAlchemy\nfrom datetime import datetime, timedelta\nfrom werkzeug.security import generate_password_hash, check_password_hash\nimport secrets\nfrom . import db\n\nclass User(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    username = db.Column(db.String(64), unique=True, nullable=False)\n    email = db.Column(db.String(120), unique=True, nullable=False)\n    password_hash = db.Column(db.String(128), nullable=False)\n    is_admin = db.Column(db.Boolean, default=False)\n    is_ti = db.Column(db.Boolean, default=False)  # Indica se o usu√°rio √© da equipe de TI\n    ativo = db.Column(db.Boolean, default=True)  # Para ativa√ß√£o/desativa√ß√£o\n    sector_id = db.Column(db.Integer, db.ForeignKey('sector.id'), nullable=True)\n    sector = db.relationship('Sector', backref='usuarios')\n    reminders = db.relationship('Reminder', backref='usuario', lazy=True)\n    tasks = db.relationship('Task', backref='usuario', lazy=True)\n    reset_token = db.Column(db.String(100), nullable=True)\n    reset_token_expiry = db.Column(db.DateTime, nullable=True)\n\n    def set_password(self, password):\n        self.password_hash = generate_password_hash(password)\n\n    def check_password(self, password):\n        return check_password_hash(self.password_hash, password)\n        \n    def generate_reset_token(self):\n        # Gera um token aleat√≥rio para redefini√ß√£o de senha\n        token = secrets.token_hex(32)\n        self.reset_token = token\n        # Define a expira√ß√£o para 1 hora a partir de agora\n        self.reset_token_expiry = datetime.utcnow() + timedelta(hours=1)\n        db.session.commit()\n        return token\n        \n    def verify_reset_token(self, token):\n        # Verifica se o token √© v√°lido e n√£o expirou\n        if self.reset_token != token:\n            return False\n        if self.reset_token_expiry < datetime.utcnow():\n            return False\n        return True\n        \n    def clear_reset_token(self):\n        # Limpa o token ap√≥s uso\n        self.reset_token = None\n        self.reset_token_expiry = None\n        db.session.commit()\n\nclass Sector(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(100), unique=True, nullable=False)\n    reminders = db.relationship('Reminder', backref='sector', lazy=True)\n    tasks = db.relationship('Task', backref='sector', lazy=True)\n\nclass Reminder(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(120), nullable=False)\n    type = db.Column(db.String(50), nullable=False)\n    due_date = db.Column(db.Date, nullable=False)\n    responsible = db.Column(db.String(100), nullable=False)\n    frequency = db.Column(db.String(20), nullable=True)\n    notified = db.Column(db.Boolean, default=False)\n    completed = db.Column(db.Boolean, default=False)\n    sector_id = db.Column(db.Integer, db.ForeignKey('sector.id'), nullable=True)\n    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=True)\n    status = db.Column(db.String(20), default='ativo')  # ativo, pausado, cancelado\n    pause_until = db.Column(db.Date, nullable=True)  # Data at√© quando o lembrete est√° pausado\n    end_date = db.Column(db.Date, nullable=True)  # Data de t√©rmino da recorr√™ncia\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n\nclass Task(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    description = db.Column(db.String(200), nullable=False)\n    date = db.Column(db.Date, default=datetime.utcnow)\n    responsible = db.Column(db.String(100), nullable=False)\n    completed = db.Column(db.Boolean, default=False)\n    sector_id = db.Column(db.Integer, db.ForeignKey('sector.id'), nullable=True)\n    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=True)\n\n\n\nclass Chamado(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    titulo = db.Column(db.String(120), nullable=False)\n    descricao = db.Column(db.Text, nullable=False)\n    status = db.Column(db.String(50), nullable=False, default='Aberto') # Ex: Aberto, Em Andamento, Resolvido, Fechado\n    prioridade = db.Column(db.String(50), nullable=False, default='Media') # Ex: Baixa, Media, Alta, Critica\n    data_abertura = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)\n    data_ultima_atualizacao = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n    data_fechamento = db.Column(db.DateTime, nullable=True)\n    solicitante_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)\n    setor_id = db.Column(db.Integer, db.ForeignKey('sector.id'), nullable=False)\n    responsavel_ti_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=True)\n    \n    # Campos de SLA\n    prazo_sla = db.Column(db.DateTime, nullable=True)  # Data limite para cumprimento do SLA\n    data_primeira_resposta = db.Column(db.DateTime, nullable=True)  # Quando o chamado foi atendido pela primeira vez\n    sla_cumprido = db.Column(db.Boolean, default=None, nullable=True)  # True=cumprido, False=vencido, None=em andamento\n    tempo_resposta_horas = db.Column(db.Float, nullable=True)  # Tempo de resposta em horas\n\n    solicitante = db.relationship('User', foreign_keys=[solicitante_id], backref='chamados_solicitados')\n    setor = db.relationship('Sector', backref='chamados')\n    responsavel_ti = db.relationship('User', foreign_keys=[responsavel_ti_id], backref='chamados_responsaveis')\n\n    @property\n    def status_sla(self):\n        \"\"\"Retorna o status visual do SLA: 'cumprido', 'vencido', 'atencao', 'normal'\"\"\"\n        if self.sla_cumprido is True:\n            return 'cumprido'\n        elif self.sla_cumprido is False:\n            return 'vencido'\n        elif self.prazo_sla:\n            agora = datetime.utcnow()\n            tempo_restante = self.prazo_sla - agora\n            if tempo_restante.total_seconds() < 0:\n                return 'vencido'\n            elif tempo_restante.total_seconds() < 3600:  # Menos de 1 hora restante\n                return 'atencao'\n        return 'normal'\n    \n    @property\n    def tempo_restante_sla(self):\n        \"\"\"Retorna o tempo restante para o SLA em formato leg√≠vel\"\"\"\n        if not self.prazo_sla:\n            return None\n        \n        agora = datetime.utcnow()\n        diferenca = self.prazo_sla - agora\n        \n        if diferenca.total_seconds() < 0:\n            # SLA vencido\n            diferenca = agora - self.prazo_sla\n            horas = int(diferenca.total_seconds() // 3600)\n            minutos = int((diferenca.total_seconds() % 3600) // 60)\n            return f\"Vencido h√° {horas}h {minutos}m\"\n        else:\n            # SLA ainda v√°lido\n            horas = int(diferenca.total_seconds() // 3600)\n            minutos = int((diferenca.total_seconds() % 3600) // 60)\n            return f\"{horas}h {minutos}m restantes\"\n\n    def calcular_sla(self):\n        \"\"\"Calcula e define o prazo de SLA baseado na prioridade\"\"\"\n        sla_config = SlaConfig.query.filter_by(prioridade=self.prioridade).first()\n        if sla_config:\n            self.prazo_sla = self.data_abertura + timedelta(hours=sla_config.tempo_resposta_horas)\n    \n    def marcar_primeira_resposta(self):\n        \"\"\"Marca a primeira resposta e calcula o tempo de resposta\"\"\"\n        if not self.data_primeira_resposta:\n            self.data_primeira_resposta = datetime.utcnow()\n            if self.prazo_sla:\n                diferenca = self.data_primeira_resposta - self.data_abertura\n                self.tempo_resposta_horas = diferenca.total_seconds() / 3600\n                self.sla_cumprido = self.data_primeira_resposta <= self.prazo_sla\n\n    def __repr__(self):\n        return f'<Chamado {self.id}: {self.titulo}>'\n\n\nclass ComentarioChamado(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    chamado_id = db.Column(db.Integer, db.ForeignKey('chamado.id'), nullable=False)\n    usuario_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)\n    texto = db.Column(db.Text, nullable=False)\n    data_criacao = db.Column(db.DateTime, default=datetime.utcnow)\n    tipo = db.Column(db.String(20), default='comentario')  # 'comentario' ou 'atualizacao'\n    \n    # Relacionamentos\n    chamado = db.relationship('Chamado', backref=db.backref('comentarios', lazy=True, order_by='ComentarioChamado.data_criacao.desc()'))\n    usuario = db.relationship('User')\n    \n    def __repr__(self):\n        return f'<Comentario {self.id} do Chamado {self.chamado_id}>'\n\nclass Tutorial(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    titulo = db.Column(db.String(150), nullable=False)\n    conteudo = db.Column(db.Text, nullable=False)\n    data_criacao = db.Column(db.DateTime, default=datetime.utcnow, nullable=False)\n    autor_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)\n    categoria = db.Column(db.String(100), nullable=True)\n\n    autor = db.relationship('User', backref='tutoriais')\n\n    def __repr__(self):\n        return f'<Tutorial {self.id}: {self.titulo}>'\n\nclass TutorialImage(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    tutorial_id = db.Column(db.Integer, db.ForeignKey('tutorial.id'), nullable=False)\n    filename = db.Column(db.String(255), nullable=False)\n    upload_date = db.Column(db.DateTime, default=datetime.utcnow)\n\n    tutorial = db.relationship('Tutorial', backref=db.backref('imagens', lazy=True))\n\n    def __repr__(self):\n        return f'<TutorialImage {self.id} - {self.filename}>'\n\nclass ComentarioTutorial(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    tutorial_id = db.Column(db.Integer, db.ForeignKey('tutorial.id'), nullable=False)\n    usuario_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)\n    texto = db.Column(db.Text, nullable=False)\n    data_criacao = db.Column(db.DateTime, default=datetime.utcnow)\n    chamado_id = db.Column(db.Integer, db.ForeignKey('chamado.id'), nullable=True)  # Integra√ß√£o opcional com chamado\n\n    tutorial = db.relationship('Tutorial', backref=db.backref('comentarios', lazy=True, order_by='ComentarioTutorial.data_criacao.desc()'))\n    usuario = db.relationship('User')\n    chamado = db.relationship('Chamado')\n\n    def __repr__(self):\n        return f'<ComentarioTutorial {self.id} do Tutorial {self.tutorial_id}>'\n\nclass FeedbackTutorial(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    tutorial_id = db.Column(db.Integer, db.ForeignKey('tutorial.id'), nullable=False)\n    usuario_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)\n    util = db.Column(db.Boolean, nullable=False)  # True = √∫til, False = n√£o √∫til\n    data = db.Column(db.DateTime, default=datetime.utcnow)\n\n    tutorial = db.relationship('Tutorial', backref=db.backref('feedbacks', lazy=True))\n    usuario = db.relationship('User')\n\n    def __repr__(self):\n        return f'<FeedbackTutorial {self.id} - Tutorial {self.tutorial_id} - Util: {self.util}>'\n\nclass VisualizacaoTutorial(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    tutorial_id = db.Column(db.Integer, db.ForeignKey('tutorial.id'), nullable=False)\n    usuario_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=True)  # Pode ser nulo para visitantes\n    data = db.Column(db.DateTime, default=datetime.utcnow)\n\n    tutorial = db.relationship('Tutorial', backref=db.backref('visualizacoes', lazy=True))\n    usuario = db.relationship('User')\n\n    def __repr__(self):\n        return f'<VisualizacaoTutorial {self.id} - Tutorial {self.tutorial_id}>'\n\n\nclass EquipmentRequest(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    \n    # Campos principais (solicitados)\n    description = db.Column(db.Text, nullable=False)  # Descri√ß√£o do equipamento\n    patrimony = db.Column(db.String(50), nullable=True)  # N√∫mero do patrim√¥nio\n    delivery_date = db.Column(db.Date, nullable=True)  # Data de entrega\n    return_date = db.Column(db.Date, nullable=True)  # Data de devolu√ß√£o\n    conference_status = db.Column(db.String(50), nullable=True)  # Status de confer√™ncia\n    observations = db.Column(db.Text, nullable=True)  # Observa√ß√µes\n    \n    # Campos de relacionamento\n    requester_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)  # Solicitante\n    received_by_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=True)  # Quem recebeu\n    approved_by_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=True)  # Quem aprovou\n    \n    # Campos de status e controle\n    status = db.Column(db.String(20), nullable=False, default='Solicitado')  # Solicitado, Aprovado, Entregue, Devolvido, Negado\n    request_date = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)  # Data da solicita√ß√£o\n    approval_date = db.Column(db.DateTime, nullable=True)  # Data de aprova√ß√£o\n    \n    # Campos adicionais\n    equipment_type = db.Column(db.String(50), nullable=True)  # Tipo de equipamento (notebook, monitor, etc.)\n    destination_sector = db.Column(db.String(100), nullable=True)  # Setor/Destino\n    request_reason = db.Column(db.Text, nullable=True)  # Motivo da solicita√ß√£o\n    \n    # Timestamps\n    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)\n    updated_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow, onupdate=datetime.utcnow)\n    \n    # Relacionamentos\n    requester = db.relationship('User', foreign_keys=[requester_id], backref='equipment_requests_solicitadas')\n    received_by = db.relationship('User', foreign_keys=[received_by_id], backref='equipment_requests_recebidas')\n    approved_by = db.relationship('User', foreign_keys=[approved_by_id], backref='equipment_requests_aprovadas')\n    \n    def __repr__(self):\n        return f'<EquipmentRequest {self.id}: {self.description[:50]}...>'\n    \n    def get_status_display(self):\n        \"\"\"Retorna o status em portugu√™s\"\"\"\n        status_map = {\n            'Solicitado': 'Solicitado',\n            'Aprovado': 'Aprovado',\n            'Entregue': 'Entregue',\n            'Devolvido': 'Devolvido',\n            'Negado': 'Negado'\n        }\n        return status_map.get(self.status, self.status)\n    \n    def can_be_approved_by(self, user):\n        \"\"\"Verifica se o usu√°rio pode aprovar esta solicita√ß√£o\"\"\"\n        return user.is_admin or user.is_ti\n    \n    def can_be_edited_by(self, user):\n        \"\"\"Verifica se o usu√°rio pode editar esta solicita√ß√£o\"\"\"\n        return (user.id == self.requester_id or \n                user.is_admin or \n                user.is_ti)\n\n\nclass SlaConfig(db.Model):\n    \"\"\"Tabela para configurar os tempos de SLA por prioridade\"\"\"\n    id = db.Column(db.Integer, primary_key=True)\n    prioridade = db.Column(db.String(50), nullable=False, unique=True)  # Baixa, Media, Alta, Critica\n    tempo_resposta_horas = db.Column(db.Integer, nullable=False)  # Tempo em horas para primeira resposta\n    tempo_resolucao_horas = db.Column(db.Integer, nullable=True)  # Tempo total para resolu√ß√£o (futuro)\n    ativo = db.Column(db.Boolean, default=True)\n    \n    def __repr__(self):\n        return f'<SlaConfig {self.prioridade}: {self.tempo_resposta_horas}h>'\n    \n    @classmethod\n    def get_tempo_sla(cls, prioridade):\n        \"\"\"Retorna o tempo de SLA para uma prioridade espec√≠fica\"\"\"\n        config = cls.query.filter_by(prioridade=prioridade, ativo=True).first()\n        return config.tempo_resposta_horas if config else 24  # Default 24 horas\n    \n    @classmethod\n    def criar_configuracoes_padrao(cls):\n        \"\"\"Cria as configura√ß√µes padr√£o de SLA\"\"\"\n        configuracoes_padrao = [\n            {'prioridade': 'Critica', 'tempo_resposta_horas': 2},\n            {'prioridade': 'Alta', 'tempo_resposta_horas': 4},\n            {'prioridade': 'Media', 'tempo_resposta_horas': 24},\n            {'prioridade': 'Baixa', 'tempo_resposta_horas': 72},\n        ]\n        \n        for config in configuracoes_padrao:\n            if not cls.query.filter_by(prioridade=config['prioridade']).first():\n                nova_config = cls(**config)\n                db.session.add(nova_config)\n        \n        db.session.commit()\n\n","size_bytes":16067},"app/routes.py":{"content":"from flask import Blueprint, render_template, redirect, url_for, request, flash, session, jsonify\nfrom datetime import date, datetime, timedelta, time\nfrom dateutil.relativedelta import relativedelta\nfrom .models import Reminder, Task, Sector, User, db, Tutorial, TutorialImage, VisualizacaoTutorial, FeedbackTutorial, EquipmentRequest, Chamado, ComentarioChamado, ComentarioTutorial # Importados modelos necess√°rios\nfrom .forms import ReminderForm, TaskForm, TutorialForm, ComentarioTutorialForm, FeedbackTutorialForm, ChamadoForm, ChamadoAdminForm, UserEditForm # Importados formul√°rios necess√°rios\nfrom .auth_utils import login_required\nfrom functools import wraps\nfrom flask import current_app\nimport os\nfrom werkzeug.utils import secure_filename\nimport markdown\n\n# Fun√ß√£o para exigir que o usu√°rio seja administrador\ndef admin_required(f):\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        if not session.get('is_admin'):\n            flash('Acesso restrito ao administrador.', 'danger')\n            return redirect(url_for('main.index'))\n        return f(*args, **kwargs)\n    return decorated_function\n\n\nbp = Blueprint('main', __name__)\n\n@bp.route('/')\n@login_required\ndef index():\n    # Importa√ß√£o local para evitar depend√™ncia circular se outros m√≥dulos importarem main.py diretamente\n    from .models import Chamado, EquipmentRequest\n\n    search = request.args.get('search', '').strip().lower()\n    status = request.args.get('status', '').strip().lower()\n\n    # --- Recorr√™ncia autom√°tica de lembretes ---\n    if session.get('is_admin'):\n        reminders = Reminder.query.all()\n    else:\n        reminders = Reminder.query.filter_by(user_id=session.get('user_id')).all()\n\n    # Recorr√™ncia autom√°tica\n    for r in reminders:\n        if (r.due_date < date.today() and \n            not r.notified and \n            r.frequency and \n            r.status == 'ativo' and\n            (not r.end_date or r.end_date > date.today()) and\n            (not r.pause_until or r.pause_until <= date.today())):\n            if r.frequency == 'diario':\n                next_due = r.due_date + relativedelta(days=1)\n            elif r.frequency == 'quinzenal':\n                next_due = r.due_date + relativedelta(days=15)\n            elif r.frequency == 'mensal':\n                next_due = r.due_date + relativedelta(months=1)\n            elif r.frequency == 'anual':\n                next_due = r.due_date + relativedelta(years=1)\n            else:\n                continue\n            novo = Reminder(\n                name=r.name,\n                type=r.type,\n                due_date=next_due,\n                responsible=r.responsible,\n                frequency=r.frequency,\n                sector_id=r.sector_id,\n                user_id=r.user_id,\n                status=r.status,\n                pause_until=r.pause_until,\n                end_date=r.end_date\n            )\n            db.session.add(novo)\n            r.notified = True  # marca o lembrete antigo para n√£o duplicar\n            db.session.commit()\n\n    # Consulta de lembretes e tarefas\n    user_id = session.get('user_id')\n    is_admin = session.get('is_admin')\n    is_ti = session.get('is_ti', False)\n    \n    if is_admin:\n        reminders_count = Reminder.query.count()\n        reminders_today = Reminder.query.filter(Reminder.due_date <= date.today()).all()\n        tasks_today = Task.query.filter(Task.date <= date.today()).all()\n        # Buscar chamados abertos (n√£o fechados)\n        chamados_abertos = Chamado.query.filter(\n            Chamado.status != 'Fechado'\n        ).order_by(\n            Chamado.data_abertura.desc()\n        ).limit(10).all()  # Limita a 10 chamados mais recentes\n        # Buscar equipamentos\n        equipamentos_count = EquipmentRequest.query.count()\n    else:\n        reminders_count = Reminder.query.filter_by(user_id=user_id).count()\n        reminders_today = Reminder.query.filter(\n            Reminder.due_date <= date.today(),\n            Reminder.user_id == user_id\n        ).all()\n        tasks_today = Task.query.filter(\n            Task.date <= date.today(),\n            Task.user_id == user_id\n        ).all()\n        # Buscar chamados do usu√°rio ou do setor do usu√°rio\n        user = User.query.get(user_id)\n        primeiro_lembrete = Reminder.query.filter_by(user_id=user_id).first()\n        setor_id_usuario = primeiro_lembrete.sector_id if primeiro_lembrete and primeiro_lembrete.sector_id else None\n\n        chamados_abertos = Chamado.query.filter(\n            (Chamado.solicitante_id == user_id) |\n            (Chamado.setor_id == setor_id_usuario),\n            Chamado.status != 'Fechado'\n        ).order_by(\n            Chamado.data_abertura.desc()\n        ).limit(10).all()  # Limita a 10 chamados mais recentes\n        \n        # Buscar equipamentos do usu√°rio\n        if is_ti:\n            equipamentos_count = EquipmentRequest.query.count()\n        else:\n            equipamentos_count = EquipmentRequest.query.filter_by(requester_id=user_id).count()\n\n    # --- FILTRO E BUSCA LEMBRETES ---\n    reminders_today_pend = [r for r in reminders_today if not r.completed]\n    reminders_today_done = [r for r in reminders_today if r.completed]\n    if search:\n        reminders_today_pend = [r for r in reminders_today_pend if search in r.name.lower() or search in r.responsible.lower()]\n        reminders_today_done = [r for r in reminders_today_done if search in r.name.lower() or search in r.responsible.lower()]\n    if status == 'pendente':\n        reminders_today_done = []\n    elif status == 'realizado':\n        reminders_today_pend = []\n\n    # --- FILTRO E BUSCA TAREFAS ---\n    tasks_today_pend = [t for t in tasks_today if not t.completed]\n    tasks_today_done = [t for t in tasks_today if t.completed]\n    if search:\n        tasks_today_pend = [t for t in tasks_today_pend if search in t.description.lower() or search in t.responsible.lower()]\n        tasks_today_done = [t for t in tasks_today_done if search in t.description.lower() or search in t.responsible.lower()]\n    if status == 'pendente':\n        tasks_today_done = []\n    elif status == 'realizado':\n        tasks_today_pend = []\n        \n    # --- ATIVIDADES RECENTES ---\n    # Combinar atividades recentes de diferentes fontes\n    atividades_recentes = []\n    \n    # Adicionar lembretes recentes\n    for r in reminders_today[:5]:  # Limitar a 5 lembretes mais recentes\n        atividades_recentes.append({\n            'tipo': 'lembrete',\n            'data': r.due_date,\n            'titulo': r.name,\n            'status': 'Realizado' if r.completed else 'Pendente',\n            'icone': 'bell',\n            'cor': 'success' if r.completed else 'warning'\n        })\n    \n    # Adicionar tarefas recentes\n    for t in tasks_today[:5]:  # Limitar a 5 tarefas mais recentes\n        atividades_recentes.append({\n            'tipo': 'tarefa',\n            'data': t.date,\n            'titulo': t.description,\n            'status': 'Conclu√≠da' if t.completed else 'Pendente',\n            'icone': 'tasks',\n            'cor': 'success' if t.completed else 'primary'\n        })\n    \n    # Adicionar chamados recentes\n    for c in chamados_abertos[:5]:  # Limitar a 5 chamados mais recentes\n        atividades_recentes.append({\n            'tipo': 'chamado',\n            'data': c.data_abertura,\n            'titulo': c.titulo,\n            'status': c.status,\n            'icone': 'ticket-alt',\n            'cor': 'info' if c.status == 'Em Andamento' else 'warning'\n        })\n    \n    # Ordenar atividades por data (mais recentes primeiro)\n    # Converter todas as datas para datetime para evitar erro de compara√ß√£o entre date e datetime\n    for atividade in atividades_recentes:\n        if isinstance(atividade['data'], date) and not isinstance(atividade['data'], datetime):\n            # Converter date para datetime\n            atividade['data'] = datetime.combine(atividade['data'], time.min)\n    \n    atividades_recentes.sort(key=lambda x: x['data'], reverse=True)\n    \n    # Limitar a 10 atividades no total\n    atividades_recentes = atividades_recentes[:10]\n    \n    # Calcular estat√≠sticas de SLA (apenas para administradores)\n    sla_vencidos = 0\n    sla_criticos = 0\n    sla_ok = 0\n    performance_sla = 0\n    \n    if is_admin:\n        # Buscar todos os chamados abertos com SLA\n        chamados_com_sla = Chamado.query.filter(\n            Chamado.status != 'Fechado',\n            Chamado.prazo_sla.isnot(None)\n        ).all()\n        \n        for chamado in chamados_com_sla:\n            status_sla = chamado.obter_status_sla()\n            if status_sla == 'vencido':\n                sla_vencidos += 1\n            elif status_sla == 'proximo_vencimento':\n                sla_criticos += 1\n            elif status_sla == 'dentro_prazo':\n                sla_ok += 1\n        \n        # Calcular performance de SLA dos √∫ltimos 30 dias\n        from datetime import timedelta\n        trinta_dias_atras = datetime.utcnow() - timedelta(days=30)\n        \n        chamados_fechados_30_dias = Chamado.query.filter(\n            Chamado.data_fechamento >= trinta_dias_atras,\n            Chamado.data_fechamento.isnot(None),\n            Chamado.sla_cumprido.isnot(None)\n        ).all()\n        \n        if chamados_fechados_30_dias:\n            sla_cumpridos = len([c for c in chamados_fechados_30_dias if c.sla_cumprido])\n            performance_sla = round((sla_cumpridos / len(chamados_fechados_30_dias)) * 100)\n\n    return render_template(\n        'index.html',\n        lembretes_count=reminders_count,\n        tarefas_count=len(tasks_today_pend),\n        chamados_count=len(chamados_abertos),\n        equipamentos_count=equipamentos_count,\n        reminders_today_pend=reminders_today_pend,\n        reminders_today_done=reminders_today_done,\n        tasks_today_pend=tasks_today_pend,\n        tasks_today_done=tasks_today_done,\n        chamados_abertos=chamados_abertos,\n        atividades_recentes=atividades_recentes,\n        ultimo_acesso=datetime.now().strftime('%d/%m/%Y %H:%M'),\n        is_admin=session.get('is_admin', False),\n        sla_vencidos=sla_vencidos,\n        sla_criticos=sla_criticos,\n        sla_ok=sla_ok,\n        performance_sla=performance_sla\n    )\n\n# --- Lembretes ---\nfrom dateutil.relativedelta import relativedelta\nimport pandas as pd\nfrom flask import send_file, make_response\nfrom io import BytesIO\nfrom reportlab.lib.pagesizes import letter\nfrom reportlab.pdfgen import canvas\n\n@bp.route('/reminders/complete/<int:id>', methods=['POST'])\ndef complete_reminder(id):\n    if session.get('is_admin'):\n        reminder = Reminder.query.get_or_404(id)\n    else:\n        reminder = Reminder.query.filter_by(id=id, user_id=session.get('user_id')).first_or_404()\n    reminder.completed = True\n    db.session.commit()\n    flash('Lembrete marcado como realizado!', 'success')\n    return redirect(url_for('main.reminders'))\n\n@bp.route('/reminders/toggle_status/<int:id>', methods=['POST'])\n@login_required\ndef toggle_reminder_status(id):\n    if session.get('is_admin'):\n        reminder = Reminder.query.get_or_404(id)\n    else:\n        reminder = Reminder.query.filter_by(id=id, user_id=session.get('user_id')).first_or_404()\n    \n    # Obter o status desejado do formul√°rio, se fornecido\n    target_status = request.form.get('target_status')\n    \n    if target_status == 'cancelado':\n        reminder.status = 'cancelado'\n        flash('Lembrete cancelado!', 'danger')\n    elif reminder.status == 'ativo':\n        reminder.status = 'pausado'\n        flash('Lembrete pausado!', 'warning')\n    elif reminder.status == 'pausado':\n        reminder.status = 'ativo'\n        reminder.pause_until = None\n        flash('Lembrete reativado!', 'success')\n    elif reminder.status == 'cancelado':\n        reminder.status = 'ativo'\n        flash('Lembrete reativado!', 'success')\n    \n    db.session.commit()\n    return redirect(url_for('main.reminders'))\n\nfrom flask import request\n\n@bp.route('/reminders/json')\n@login_required\ndef reminders_json():\n    # Mesma l√≥gica de ordena√ß√£o e filtro da rota principal\n    order_by = request.args.get('order_by', 'id')\n    order = request.args.get('order', 'desc')\n    page = request.args.get('page', 1, type=int)\n    per_page = 10\n\n    if session.get('is_admin'):\n        query = Reminder.query\n    else:\n        query = Reminder.query.filter_by(user_id=session.get('user_id'))\n\n    # Aplica a ordena√ß√£o\n    if order_by == 'due_date':\n        query = query.order_by(getattr(Reminder.due_date, order)())\n    elif order_by == 'name':\n        query = query.order_by(getattr(Reminder.name, order)())\n    else:  # id ou padr√£o\n        query = query.order_by(Reminder.id.desc())\n\n    # Aplica a pagina√ß√£o\n    pagination = query.paginate(page=page, per_page=per_page, error_out=False)\n    reminders = pagination.items\n\n    # Converte para dicion√°rio para serializa√ß√£o JSON\n    reminders_data = []\n    for r in reminders:\n        reminders_data.append({\n            'id': r.id,\n            'name': r.name,\n            'type': r.type,\n            'due_date': r.due_date.isoformat(),\n            'responsible': r.responsible,\n            'frequency': r.frequency,\n            'sector': r.sector.name if r.sector else '',\n            'completed': r.completed,\n            'status_control': r.status,  # Campo de controle de status (ativo, pausado, cancelado)\n            'pause_until': r.pause_until.isoformat() if r.pause_until else None,\n            'end_date': r.end_date.isoformat() if r.end_date else None,\n            'created_at': r.created_at.isoformat() if r.created_at else None,\n            'status': 'completed' if r.completed else\n                     'expired' if r.due_date < date.today() else\n                     'ok' if r.due_date == date.today() else\n                     'alert' if (r.due_date - date.today()).days <= 7 else\n                     'pending'\n        })\n\n    return jsonify({\n        'reminders': reminders_data,\n        'total': pagination.total,\n        'pages': pagination.pages,\n        'current_page': pagination.page,\n        'has_next': pagination.has_next,\n        'has_prev': pagination.has_prev\n    })\n\n@bp.route('/reminders', methods=['GET', 'POST'])\n@login_required\ndef reminders():\n    form = ReminderForm()\n\n    # Popular o select de setores\n    from .models import Sector\n    sectors = Sector.query.order_by(Sector.name).all()\n    form.sector_id.choices = [(0, 'Selecione')] + [(s.id, s.name) for s in sectors]\n\n    if form.validate_on_submit():\n        # L√≥gica do setor: se novo setor preenchido, criar e usar\n        sector_id = form.sector_id.data\n        new_sector_name = form.new_sector.data.strip() if form.new_sector.data else ''\n        if new_sector_name:\n            existing = Sector.query.filter_by(name=new_sector_name).first()\n            if existing:\n                sector = existing\n            else:\n                sector = Sector(name=new_sector_name)\n                db.session.add(sector)\n                db.session.commit()\n            sector_id = sector.id\n        elif sector_id == 0:\n            sector_id = None\n\n        reminder = Reminder(\n            name=form.name.data,\n            type=form.type.data,\n            due_date=form.due_date.data,\n            responsible=form.responsible.data,\n            frequency=form.frequency.data,\n            sector_id=sector_id,\n            user_id=session.get('user_id'),\n            status=form.status.data,\n            pause_until=form.pause_until.data,\n            end_date=form.end_date.data,\n            created_at=datetime.now()\n        )\n        db.session.add(reminder)\n        db.session.commit()\n        flash('Lembrete cadastrado com sucesso!', 'success')\n        return redirect(url_for('main.reminders'))\n\n    return render_template('reminders.html', form=form)\n\n@bp.route('/reminders/edit/<int:id>', methods=['GET', 'POST'])\n@login_required\ndef edit_reminder(id):\n    from .models import Sector\n    # Admin pode editar qualquer lembrete, usu√°rio comum s√≥ os pr√≥prios\n    if session.get('is_admin'):\n        reminder = Reminder.query.get_or_404(id)\n    else:\n        reminder = Reminder.query.filter_by(id=id, user_id=session.get('user_id')).first_or_404()\n    form = ReminderForm(obj=reminder)\n    # Popular o select de setores\n    sectors = Sector.query.order_by(Sector.name).all()\n    form.sector_id.choices = [(0, 'Selecione')] + [(s.id, s.name) for s in sectors]\n    if reminder.sector_id:\n        form.sector_id.data = reminder.sector_id\n    if form.validate_on_submit():\n        # L√≥gica do setor: se novo setor preenchido, criar e usar\n        sector_id = form.sector_id.data\n        new_sector_name = form.new_sector.data.strip() if form.new_sector.data else ''\n        if new_sector_name:\n            existing = Sector.query.filter_by(name=new_sector_name).first()\n            if existing:\n                sector = existing\n            else:\n                sector = Sector(name=new_sector_name)\n                db.session.add(sector)\n                db.session.commit()\n            sector_id = sector.id\n        elif sector_id == 0:\n            sector_id = None\n        form.populate_obj(reminder)\n        reminder.sector_id = sector_id\n        db.session.commit()\n        flash('Lembrete atualizado!', 'success')\n        return redirect(url_for('main.reminders'))\n    return render_template('reminders.html', reminders=Reminder.query.all(), form=form, edit_id=id)\n\n@bp.route('/reminders/delete/<int:id>', methods=['POST'])\ndef delete_reminder(id):\n    reminder = Reminder.query.get_or_404(id)\n    db.session.delete(reminder)\n    db.session.commit()\n    flash('Lembrete exclu√≠do!', 'success')\n    return redirect(url_for('main.reminders'))\n\n# --- API de Notifica√ß√µes ---\n# Rota movida para o final do arquivo para evitar duplica√ß√£o\n\n# Chamados atualizados recentemente (√∫ltimas 24 horas)\n    yesterday = datetime.now() - timedelta(hours=24)\n    \n    # Buscar chamados do usu√°rio ou que o usu√°rio √© respons√°vel\n    chamados_query = Chamado.query.filter(\n        Chamado.data_ultima_atualizacao > yesterday\n    )\n    \n    # Se n√£o for TI, filtrar apenas chamados do usu√°rio\n    if not is_ti:\n        chamados_query = chamados_query.filter(\n            Chamado.solicitante_id == user_id\n        )\n    \n    chamados_updated = [{\n        'id': c.id,\n        'titulo': c.titulo,\n        'status': c.status,\n        'ultima_atualizacao': c.data_ultima_atualizacao.strftime('%d/%m/%Y %H:%M')\n    } for c in chamados_query.all()]\n    \n    return jsonify({\n        'reminders_expiring': reminders_expiring,\n        'tasks_overdue': tasks_overdue,\n        'chamados_updated': chamados_updated\n    })\n\n# --- Administra√ß√£o de Usu√°rios ---\n@bp.route('/admin/users')\n@login_required\n@admin_required\ndef users_admin():\n    from .models import User\n    users = User.query.order_by(User.id).all()\n    return render_template('users.html', users=users)\n\n@bp.route('/admin/users/edit/<int:id>', methods=['GET', 'POST'])\n@login_required\n@admin_required\ndef edit_user(id):\n    from .models import User, Sector\n    from .forms import UserEditForm\n\n    user = User.query.get_or_404(id)\n    form = UserEditForm(obj=user)\n\n    # Define o setor atual do usu√°rio no formul√°rio\n    if user.sector_id:\n        form.sector_id.data = user.sector_id\n\n    # Se o usu√°rio for o pr√≥prio, n√£o pode remover os privil√©gios de admin\n    if user.id == session.get('user_id'):\n        form.is_admin.data = True  # Garante que o admin n√£o remova seus pr√≥prios privil√©gios\n\n    if form.validate_on_submit():\n        # Verifica se o email j√° est√° em uso por outro usu√°rio\n        existing_user = User.query.filter(User.email == form.email.data, User.id != user.id).first()\n        if existing_user:\n            flash('Este email j√° est√° em uso por outro usu√°rio.', 'danger')\n            return redirect(url_for('main.edit_user', id=user.id))\n\n        # Verifica se o nome de usu√°rio j√° est√° em uso por outro usu√°rio\n        existing_username = User.query.filter(User.username == form.username.data, User.id != user.id).first()\n        if existing_username:\n            flash('Este nome de usu√°rio j√° est√° em uso por outro usu√°rio.', 'danger')\n            return redirect(url_for('main.edit_user', id=user.id))\n\n        # Atualiza os dados b√°sicos\n        user.username = form.username.data\n        user.email = form.email.data\n\n        # Atualiza o setor\n        user.sector_id = form.sector_id.data if form.sector_id.data != 0 else None\n\n        # Atualiza o status de TI (qualquer usu√°rio pode ser marcado como TI)\n        user.is_ti = form.is_ti.data\n\n        # Impede que o pr√≥prio administrador remova seus privil√©gios\n        if user.id == session.get('user_id'):\n            user.is_admin = True  # Garante que o admin n√£o remova seus pr√≥prios privil√©gios\n        else:\n            # Verifica se √© o √∫ltimo administrador ativo\n            if user.is_admin and not form.is_admin.data:\n                admin_count = User.query.filter_by(is_admin=True, ativo=True).count()\n                if admin_count <= 1:  # Se for o √∫nico admin ativo\n                    flash('N√£o √© poss√≠vel remover os privil√©gios de administrador do √∫ltimo administrador ativo.', 'danger')\n                    return redirect(url_for('main.edit_user', id=user.id))\n\n            user.is_admin = form.is_admin.data\n\n        # Atualiza a senha se solicitado\n        if form.change_password.data and form.new_password.data:\n            if len(form.new_password.data) < 6:\n                flash('A senha deve ter pelo menos 6 caracteres.', 'danger')\n                return redirect(url_for('main.edit_user', id=user.id))\n\n            user.set_password(form.new_password.data)\n            flash('Senha alterada com sucesso!', 'success')\n\n        try:\n            db.session.commit()\n            flash('Usu√°rio atualizado com sucesso!', 'success')\n            return redirect(url_for('main.users_admin'))\n        except Exception as e:\n            db.session.rollback()\n            flash('Ocorreu um erro ao atualizar o usu√°rio. Por favor, tente novamente.', 'danger')\n            return redirect(url_for('main.edit_user', id=user.id))\n\n    return render_template('edit_user.html', form=form, user=user)\n\n@bp.route('/admin/users/toggle/<int:id>', methods=['POST'])\n@login_required\n@admin_required\ndef toggle_user(id):\n    from .models import User\n\n    user = User.query.get_or_404(id)\n\n    # Impede que o usu√°rio desative a si mesmo\n    if id == session.get('user_id'):\n        flash('Voc√™ n√£o pode desativar sua pr√≥pria conta.', 'danger')\n        return redirect(url_for('main.users_admin'))\n\n    # Verifica se est√° tentando desativar o √∫ltimo administrador ativo\n    if user.is_admin and user.ativo:  # Se for admin e estiver ativo\n        admin_count = User.query.filter_by(is_admin=True, ativo=True).count()\n        if admin_count <= 1:  # Se for o √∫nico admin ativo\n            flash('N√£o √© poss√≠vel desativar o √∫ltimo administrador ativo do sistema.', 'danger')\n            return redirect(url_for('main.users_admin'))\n\n    user.ativo = not user.ativo\n\n    try:\n        db.session.commit()\n        status = 'ativado' if user.ativo else 'desativado'\n        flash(f'Usu√°rio {status} com sucesso!', 'success')\n    except Exception as e:\n        db.session.rollback()\n        flash('Ocorreu um erro ao atualizar o status do usu√°rio.', 'danger')\n\n    return redirect(url_for('main.users_admin'))\n\n@bp.route('/admin/users/delete/<int:id>', methods=['POST'])\n@login_required\n@admin_required\ndef delete_user(id):\n    from .models import User\n\n    user = User.query.get_or_404(id)\n\n    # Impede que o usu√°rio exclua a si mesmo\n    if id == session.get('user_id'):\n        flash('Voc√™ n√£o pode excluir sua pr√≥pria conta.', 'danger')\n        return redirect(url_for('main.users_admin'))\n\n    # Verifica se est√° tentando excluir o √∫ltimo administrador ativo\n    if user.is_admin and user.ativo:  # Se for admin e estiver ativo\n        admin_count = User.query.filter_by(is_admin=True, ativo=True).count()\n        if admin_count <= 1:  # Se for o √∫nico admin ativo\n            flash('N√£o √© poss√≠vel excluir o √∫ltimo administrador ativo do sistema.', 'danger')\n            return redirect(url_for('main.users_admin'))\n\n    try:\n        db.session.delete(user)\n        db.session.commit()\n        flash('Usu√°rio exclu√≠do com sucesso!', 'success')\n    except Exception as e:\n        db.session.rollback()\n        flash('Ocorreu um erro ao excluir o usu√°rio. Por favor, tente novamente.', 'danger')\n\n    return redirect(url_for('main.users_admin'))\n\n@bp.route('/register', methods=['GET', 'POST'])\n@login_required\n@admin_required\ndef register():\n    from .models import User\n    from .forms import UserRegisterForm\n\n    form = UserRegisterForm()\n\n    if form.validate_on_submit():\n        # Verifica se j√° existe um usu√°rio com o mesmo nome de usu√°rio ou email\n        existing_user = User.query.filter(\n            (User.username == form.username.data) |\n            (User.email == form.email.data)\n        ).first()\n\n        if existing_user:\n            flash('Nome de usu√°rio ou email j√° est√° em uso.', 'danger')\n            return render_template('register_admin.html', form=form, title='Registrar Novo Usu√°rio')\n\n        # Cria o novo usu√°rio\n        user = User(\n            username=form.username.data,\n            email=form.email.data,\n            is_admin=form.is_admin.data if hasattr(form, 'is_admin') else False,\n            is_ti=form.is_ti.data if hasattr(form, 'is_ti') else False,\n            ativo=True\n        )\n\n        # Define a senha\n        user.set_password(form.password.data)\n\n        try:\n            db.session.add(user)\n            db.session.commit()\n            flash('Usu√°rio criado com sucesso!', 'success')\n            return redirect(url_for('main.users_admin'))\n        except Exception as e:\n            db.session.rollback()\n            flash('Ocorreu um erro ao criar o usu√°rio. Por favor, tente novamente.', 'danger')\n\n    return render_template('register_admin.html', form=form, title='Registrar Novo Usu√°rio')\n\n@bp.route('/admin/users/reset_password/<int:id>', methods=['POST'])\n@login_required\n@admin_required\ndef reset_user_password(id):\n    from .models import User\n    from werkzeug.security import generate_password_hash\n    import string\n    import secrets\n\n    user = User.query.get_or_404(id)\n\n    # Gerar uma senha aleat√≥ria segura\n    alphabet = string.ascii_letters + string.digits + '!@#$%&*'\n    while True:\n        password = ''.join(secrets.choice(alphabet) for i in range(12))\n        # Garantir que a senha tenha pelo menos um caractere especial e um n√∫mero\n        if (any(c.islower() for c in password)\n            and any(c.isupper() for c in password)\n            and any(c.isdigit() for c in password)\n            and any(c in '!@#$%&*' for c in password)):\n            break\n\n    # Definir a nova senha\n    user.set_password(password)\n    db.session.commit()\n\n    # Aqui voc√™ pode adicionar o c√≥digo para enviar a nova senha por email\n    # send_password_reset_email(user.email, password)\n\n    flash(f'Senha redefinida com sucesso! Nova senha: {password} - Recomenda-se copiar e enviar ao usu√°rio por um canal seguro.', 'success')\n    return redirect(url_for('main.users_admin'))\n\n# --- Rotas principais ---\n\n@bp.route('/dashboard')\ndef dashboard():\n    from flask import request, session\n    from .models import Sector, User, Chamado, Task, Reminder # Adicionado Chamado, Task, Reminder\n    from datetime import datetime # Adicionado datetime\n\n    task_status = request.args.get('task_status', '')\n    reminder_status = request.args.get('reminder_status', '')\n    chamado_status = request.args.get('chamado_status', '') # Novo filtro para chamados\n    start_date_str = request.args.get('start_date', '')\n    end_date_str = request.args.get('end_date', '')\n    sector_id = request.args.get('sector_id', type=int)\n    user_id = request.args.get('user_id', type=int)\n\n    # Convers√£o de datas\n    start_date = None\n    if start_date_str:\n        try:\n            start_date = datetime.strptime(start_date_str, '%Y-%m-%d').date()\n        except ValueError:\n            flash('Data inicial inv√°lida.', 'warning')\n    end_date = None\n    if end_date_str:\n        try:\n            end_date = datetime.strptime(end_date_str, '%Y-%m-%d').date()\n        except ValueError:\n            flash('Data final inv√°lida.', 'warning')\n\n    # Listas para filtros\n    sectors = Sector.query.order_by(Sector.name).all()\n    users = User.query.order_by(User.username).all()\n\n    task_query = Task.query\n    reminder_query = Reminder.query\n    chamado_query = Chamado.query # Nova query para chamados\n    equipment_query = EquipmentRequest.query # Query para equipamentos\n\n    # Filtros\n    current_user_id = session.get('user_id')\n    is_admin = session.get('is_admin', False)\n    is_ti = session.get('is_ti', False) # Verifica se o usu√°rio √© de TI\n\n    if not is_admin and not is_ti: # Se n√£o for admin nem TI, filtra por tarefas do usu√°rio\n        task_query = task_query.filter(Task.user_id == current_user_id)\n        reminder_query = reminder_query.filter(Reminder.user_id == current_user_id)\n        chamado_query = chamado_query.filter(Chamado.solicitante_id == current_user_id)\n        equipment_query = equipment_query.filter(EquipmentRequest.requester_id == current_user_id)\n    elif not is_admin and is_ti: # Se for TI mas n√£o admin, pode ver chamados do setor\n        user = User.query.get(current_user_id)\n        primeiro_lembrete = Reminder.query.filter_by(user_id=current_user_id).first()\n        setor_id_usuario = primeiro_lembrete.sector_id if primeiro_lembrete and primeiro_lembrete.sector_id else None\n        chamado_query = chamado_query.filter((Chamado.solicitante_id == current_user_id) | (Chamado.setor_id == setor_id_usuario))\n        # TI pode ver todas as solicita√ß√µes de equipamento\n        equipment_query = EquipmentRequest.query\n\n    if task_status == 'done':\n        task_query = task_query.filter(Task.completed == True)\n    elif task_status == 'pending':\n        task_query = task_query.filter(Task.completed == False, Task.date >= date.today()) # Apenas pendentes n√£o vencidas\n    elif task_status == 'expired':\n        task_query = task_query.filter(Task.completed == False, Task.date < date.today())\n\n    if reminder_status == 'done':\n        reminder_query = reminder_query.filter(Reminder.completed == True)\n    elif reminder_status == 'pending':\n        reminder_query = reminder_query.filter(Reminder.completed == False)\n        # Adicionar l√≥gica para lembretes vencidos se necess√°rio, similar a tarefas\n\n    if chamado_status: # Filtro de status para chamados\n        chamado_query = chamado_query.filter(Chamado.status == chamado_status)\n\n    if start_date:\n        task_query = task_query.filter(Task.date >= start_date)\n        reminder_query = reminder_query.filter(Reminder.due_date >= start_date)\n        chamado_query = chamado_query.filter(Chamado.data_abertura >= start_date)\n        equipment_query = equipment_query.filter(EquipmentRequest.request_date >= start_date)\n    if end_date:\n        task_query = task_query.filter(Task.date <= end_date)\n        reminder_query = reminder_query.filter(Reminder.due_date <= end_date)\n        chamado_query = chamado_query.filter(Chamado.data_abertura <= end_date)\n        equipment_query = equipment_query.filter(EquipmentRequest.request_date <= end_date)\n\n    if sector_id:\n        task_query = task_query.filter(Task.sector_id == sector_id)\n        reminder_query = reminder_query.filter(Reminder.sector_id == sector_id)\n        chamado_query = chamado_query.filter(Chamado.setor_id == sector_id)\n        equipment_query = equipment_query.filter(EquipmentRequest.destination_sector.contains(Sector.query.get(sector_id).name if Sector.query.get(sector_id) else '')) # Filtro por setor de destino para equipamentos\n\n    if user_id and (is_admin or is_ti): # Admin ou TI pode filtrar por qualquer usu√°rio\n        task_query = task_query.filter(Task.user_id == user_id)\n        reminder_query = reminder_query.filter(Reminder.user_id == user_id)\n        chamado_query = chamado_query.filter(Chamado.solicitante_id == user_id)\n        equipment_query = equipment_query.filter(EquipmentRequest.requester_id == user_id)\n\n    # Totais\n    tasks_all = task_query.all()\n    reminders_all = reminder_query.all()\n    chamados_all = chamado_query.all()\n    equipamentos_all = equipment_query.all() # Obt√©m as solicita√ß√µes de equipamento filtradas\n\n    tasks_total = len(tasks_all)\n    reminders_total = len(reminders_all)\n    chamados_total = len(chamados_all)\n    equipamentos_total = len(equipamentos_all) # Total de equipamentos solicitados\n\n    tasks_done = len([t for t in tasks_all if t.completed])\n    tasks_pending = len([t for t in tasks_all if not t.completed and t.date >= date.today()])\n    tasks_expired = len([t for t in tasks_all if not t.completed and t.date < date.today()])\n\n    reminders_done = len([r for r in reminders_all if r.completed])\n    reminders_pending = len([r for r in reminders_all if not r.completed]) # Adicionar l√≥gica de vencidos se houver\n\n    chamados_aberto = len([c for c in chamados_all if c.status == 'Aberto'])\n    chamados_em_andamento = len([c for c in chamados_all if c.status == 'Em Andamento'])\n    chamados_resolvido = len([c for c in chamados_all if c.status == 'Resolvido']) # Novo\n    chamados_fechado = len([c for c in chamados_all if c.status == 'Fechado'])\n    # Adicionar outros status de chamado conforme necess√°rio\n\n    # Contagens de status para equipamentos\n    equipamentos_solicitados = len([e for e in equipamentos_all if e.status == 'Solicitado'])\n    equipamentos_aprovados = len([e for e in equipamentos_all if e.status == 'Aprovado'])\n    equipamentos_entregues = len([e for e in equipamentos_all if e.status == 'Entregue'])\n    equipamentos_devolvidos = len([e for e in equipamentos_all if e.status == 'Devolvido'])\n    equipamentos_negados = len([e for e in equipamentos_all if e.status == 'Negado'])\n\n\n    # --- Dados para Gr√°ficos de Linha (por m√™s, √∫ltimos 12 meses) ---\n    from collections import OrderedDict\n    from datetime import date, timedelta # date j√° estava, timedelta adicionado\n    from dateutil.relativedelta import relativedelta # Adicionado relativedelta\n    import calendar\n    today = date.today()\n    meses = []\n    for i in range(11, -1, -1):\n        m = (today.replace(day=1) - relativedelta(months=i))\n        meses.append(m)\n    meses_labels = [m.strftime('%b/%Y') for m in meses]\n    tarefas_por_mes = [0]*12\n    tarefas_concluidas_por_mes = [0]*12\n    lembretes_por_mes = [0]*12\n    lembretes_realizados_por_mes = [0]*12\n    chamados_por_mes = [0]*12 # Para chamados\n    equipamentos_por_mes = [0]*12 # Para equipamentos\n\n    for idx, m in enumerate(meses):\n        prox = (m + relativedelta(months=1))\n        tarefas_mes = [t for t in tasks_all if t.date >= m and t.date < prox]\n        tarefas_por_mes[idx] = len(tarefas_mes)\n        tarefas_concluidas_por_mes[idx] = len([t for t in tarefas_mes if t.completed])\n        lembretes_mes = [r for r in reminders_all if r.due_date >= m and r.due_date < prox]\n        lembretes_por_mes[idx] = len(lembretes_mes)\n        lembretes_realizados_por_mes[idx] = len([r for r in lembretes_mes if r.completed])\n        chamados_mes = [c for c in chamados_all if c.data_abertura.date() >= m and c.data_abertura.date() < prox]\n        chamados_por_mes[idx] = len(chamados_mes)\n        equipamentos_mes = [e for e in equipamentos_all if e.request_date.date() >= m and e.request_date.date() < prox]\n        equipamentos_por_mes[idx] = len(equipamentos_mes)\n\n\n    # --- Dados para Gr√°fico de Barra (por setor) ---\n    setores_labels = [s.name for s in sectors]\n    tarefas_por_setor = [len([t for t in tasks_all if t.sector_id == s.id]) for s in sectors]\n    lembretes_por_setor = [len([r for r in reminders_all if r.sector_id == s.id]) for s in sectors]\n    chamados_por_setor = [len([c for c in chamados_all if c.setor_id == s.id]) for s in sectors] # Novo\n    equipamentos_por_setor = [len([e for e in equipamentos_all if s.name in e.destination_sector]) for s in sectors] # Equipamentos por setor de destino\n\n\n    # --- Tutoriais: agrega√ß√£o ---\n    tutoriais = Tutorial.query.all()\n    total_tutoriais = len(tutoriais)\n    # Visualiza√ß√µes por tutorial\n    visualizacoes_por_tutorial = {t.id: 0 for t in tutoriais}\n    for v in VisualizacaoTutorial.query.all():\n        if v.tutorial_id in visualizacoes_por_tutorial:\n            visualizacoes_por_tutorial[v.tutorial_id] += 1\n    # Top 5 mais visualizados\n    top_tutoriais_ids = sorted(visualizacoes_por_tutorial, key=visualizacoes_por_tutorial.get, reverse=True)[:5]\n    top_tutoriais = [Tutorial.query.get(tid) for tid in top_tutoriais_ids]\n    top_tutoriais_labels = [t.titulo for t in top_tutoriais if t]\n    top_tutoriais_values = [visualizacoes_por_tutorial[t.id] for t in top_tutoriais if t]\n    # Feedbacks agregados\n    feedbacks = FeedbackTutorial.query.all()\n    feedbacks_util = sum(1 for f in feedbacks if f.util)\n    feedbacks_nao_util = sum(1 for f in feedbacks if not f.util)\n    # Feedback por tutorial (top 5 mais feedbacks)\n    feedbacks_por_tutorial = {t.id: 0 for t in tutoriais}\n    for f in feedbacks:\n        if f.tutorial_id in feedbacks_por_tutorial:\n            feedbacks_por_tutorial[f.tutorial_id] += 1\n    top_feedback_ids = sorted(feedbacks_por_tutorial, key=feedbacks_por_tutorial.get, reverse=True)[:5]\n    top_feedback_tutoriais = [Tutorial.query.get(tid) for tid in top_feedback_ids]\n    top_feedback_labels = [t.titulo for t in top_feedback_tutoriais if t]\n    top_feedback_values = [feedbacks_por_tutorial[t.id] for t in top_feedback_tutoriais if t]\n    # Tutorial mais visualizado e mais √∫til\n    tutorial_mais_visualizado = Tutorial.query.get(top_tutoriais_ids[0]) if top_tutoriais_ids else None\n    tutorial_mais_util = None\n    max_util = -1\n    for t in tutoriais:\n        util = sum(1 for f in t.feedbacks if f.util)\n        if util > max_util:\n            max_util = util\n            tutorial_mais_util = t\n\n    # Filtros para tutoriais\n    tutorial_query = Tutorial.query\n    if not is_admin and not is_ti: # Usu√°rio comum s√≥ v√™ os seus\n        tutorial_query = tutorial_query.filter(Tutorial.autor_id == current_user_id)\n    if sector_id:\n        tutorial_query = tutorial_query.join(User).filter(User.sector_id == sector_id)\n    if user_id and (is_admin or is_ti): # Admin ou TI pode filtrar por autor\n        tutorial_query = tutorial_query.filter(Tutorial.autor_id == user_id)\n    if start_date:\n        tutorial_query = tutorial_query.filter(Tutorial.data_criacao >= start_date)\n    if end_date:\n        tutorial_query = tutorial_query.filter(Tutorial.data_criacao <= end_date)\n    tutoriais = tutorial_query.all()\n\n    return render_template('dashboard.html',\n        tasks_total=tasks_total,\n        tasks_done=tasks_done,\n        tasks_pending=tasks_pending,\n        tasks_expired=tasks_expired,\n        reminders_total=reminders_total,\n        reminders_done=reminders_done,\n        reminders_pending=reminders_pending,\n        chamados_total=chamados_total,\n        chamados_aberto=chamados_aberto,\n        chamados_em_andamento=chamados_em_andamento,\n        chamados_resolvido=chamados_resolvido, # Novo\n        chamados_fechado=chamados_fechado,\n        equipamentos_total=equipamentos_total, # Total de equipamentos\n        equipamentos_solicitados=equipamentos_solicitados,\n        equipamentos_aprovados=equipamentos_aprovados,\n        equipamentos_entregues=equipamentos_entregues,\n        equipamentos_devolvidos=equipamentos_devolvidos,\n        equipamentos_negados=equipamentos_negados,\n        sectors=sectors,\n        users=users,\n        selected_sector=sector_id,\n        selected_user=user_id,\n        meses_labels=meses_labels,\n        tarefas_por_mes=tarefas_por_mes,\n        tarefas_concluidas_por_mes=tarefas_concluidas_por_mes,\n        lembretes_por_mes=lembretes_por_mes,\n        lembretes_realizados_por_mes=lembretes_realizados_por_mes,\n        chamados_por_mes=chamados_por_mes,\n        equipamentos_por_mes=equipamentos_por_mes,\n        setores_labels=setores_labels,\n        tarefas_por_setor=tarefas_por_setor,\n        lembretes_por_setor=lembretes_por_setor,\n        chamados_por_setor=chamados_por_setor, # Novo\n        equipamentos_por_setor=equipamentos_por_setor,\n        total_tutoriais=total_tutoriais,\n        top_tutoriais_labels=top_tutoriais_labels,\n        top_tutoriais_values=top_tutoriais_values,\n        feedbacks_util=feedbacks_util,\n        feedbacks_nao_util=feedbacks_nao_util,\n        top_feedback_labels=top_feedback_labels,\n        top_feedback_values=top_feedback_values,\n        tutorial_mais_visualizado=tutorial_mais_visualizado,\n        tutorial_mais_util=tutorial_mais_util,\n    )\n\n@bp.route('/export/excel')\ndef export_excel():\n    from flask import request, session # session j√° estava importado globalmente, mas garantindo\n    from .models import Task, Reminder, Chamado, Sector, User, Tutorial # Adicionado Tutorial\n    from datetime import datetime, date # Adicionado datetime, date\n    import pandas as pd # pd j√° estava importado globalmente\n    from io import BytesIO # BytesIO j√° estava importado globalmente\n\n    task_status = request.args.get('task_status', '')\n    reminder_status = request.args.get('reminder_status', '')\n    chamado_status = request.args.get('chamado_status', '') # Novo\n    start_date_str = request.args.get('start_date', '')\n    end_date_str = request.args.get('end_date', '')\n    sector_id = request.args.get('sector_id', type=int)\n    user_id_filter = request.args.get('user_id', type=int) # Renomeado para evitar conflito com user_id da sess√£o\n\n    # Convers√£o de datas\n    start_date = None\n    if start_date_str:\n        try:\n            start_date = datetime.strptime(start_date_str, '%Y-%m-%d').date()\n        except ValueError:\n            pass # Ignorar data inv√°lida para exporta√ß√£o, ou poderia dar flash\n    end_date = None\n    if end_date_str:\n        try:\n            end_date = datetime.strptime(end_date_str, '%Y-%m-%d').date()\n        except ValueError:\n            pass\n\n    task_query = Task.query\n    reminder_query = Reminder.query\n    chamado_query = Chamado.query # Novo\n    equipment_query = EquipmentRequest.query # Query para equipamentos\n\n    current_user_id = session.get('user_id')\n    is_admin = session.get('is_admin', False)\n    is_ti = session.get('is_ti', False)\n\n    # Filtros de permiss√£o\n    if not is_admin and not is_ti:\n        task_query = task_query.filter(Task.user_id == current_user_id)\n        reminder_query = reminder_query.filter(Reminder.user_id == current_user_id)\n        chamado_query = chamado_query.filter(Chamado.solicitante_id == current_user_id)\n        equipment_query = equipment_query.filter(EquipmentRequest.requester_id == current_user_id)\n    elif not is_admin and is_ti:\n        user = User.query.get(current_user_id)\n        primeiro_lembrete = Reminder.query.filter_by(user_id=current_user_id).first()\n        setor_id_usuario = primeiro_lembrete.sector_id if primeiro_lembrete and primeiro_lembrete.sector_id else None\n        chamado_query = chamado_query.filter((Chamado.solicitante_id == current_user_id) | (Chamado.setor_id == setor_id_usuario))\n        equipment_query = EquipmentRequest.query # TI pode ver todas as solicita√ß√µes de equipamento\n\n    if task_status == 'done':\n        task_query = task_query.filter(Task.completed == True)\n    elif task_status == 'pending':\n        task_query = task_query.filter(Task.completed == False, Task.date >= date.today())\n    elif task_status == 'expired':\n        task_query = task_query.filter(Task.completed == False, Task.date < date.today())\n\n    if reminder_status == 'done':\n        reminder_query = reminder_query.filter(Reminder.completed == True)\n    elif reminder_status == 'pending':\n        reminder_query = reminder_query.filter(Reminder.completed == False)\n\n    if chamado_status:\n        chamado_query = chamado_query.filter(Chamado.status == chamado_status)\n\n    if start_date:\n        task_query = task_query.filter(Task.date >= start_date)\n        reminder_query = reminder_query.filter(Reminder.due_date >= start_date)\n        chamado_query = chamado_query.filter(Chamado.data_abertura >= start_date)\n        equipment_query = equipment_query.filter(EquipmentRequest.request_date >= start_date)\n    if end_date:\n        task_query = task_query.filter(Task.date <= end_date)\n        reminder_query = reminder_query.filter(Reminder.due_date <= end_date)\n        chamado_query = chamado_query.filter(Chamado.data_abertura <= end_date)\n        equipment_query = equipment_query.filter(EquipmentRequest.request_date <= end_date)\n\n    if sector_id:\n        task_query = task_query.filter(Task.sector_id == sector_id)\n        reminder_query = reminder_query.filter(Reminder.sector_id == sector_id)\n        chamado_query = chamado_query.filter(Chamado.setor_id == sector_id)\n        # Filtro para equipamentos por setor de destino\n        setor_nome = Sector.query.get(sector_id).name if Sector.query.get(sector_id) else ''\n        equipment_query = equipment_query.filter(EquipmentRequest.destination_sector.contains(setor_nome))\n\n\n    if user_id_filter and (is_admin or is_ti): # Admin ou TI pode filtrar por qualquer usu√°rio\n        task_query = task_query.filter(Task.user_id == user_id_filter)\n        reminder_query = reminder_query.filter(Reminder.user_id == user_id_filter)\n        chamado_query = chamado_query.filter(Chamado.solicitante_id == user_id_filter)\n        equipment_query = equipment_query.filter(EquipmentRequest.requester_id == user_id_filter)\n\n\n    export_type = request.args.get('export_type', 'all')\n    output = BytesIO()\n    with pd.ExcelWriter(output, engine='xlsxwriter') as writer:\n        workbook = writer.book\n        title_format = workbook.add_format({'bold': True, 'font_size': 14, 'align': 'center', 'valign': 'vcenter'})\n        header_format = workbook.add_format({'bold': True, 'text_wrap': True, 'valign': 'top', 'fg_color': '#D7E4BC', 'border': 1})\n\n        if export_type in ['all', 'tasks']:\n            tasks = task_query.all()\n            tasks_data = [{\n                'Descri√ß√£o': t.description,\n                'Data': t.date.strftime('%d/%m/%Y') if t.date else '',\n                'Respons√°vel': t.responsible,\n                'Setor': t.sector.name if t.sector else '',\n                'Usu√°rio': t.usuario.username if t.usuario else '',\n                'Conclu√≠da': 'Sim' if t.completed else 'N√£o'\n            } for t in tasks]\n            df_tasks = pd.DataFrame(tasks_data)\n            df_tasks.to_excel(writer, sheet_name='Tarefas', index=False, header=False, startrow=1)\n            worksheet_tasks = writer.sheets['Tarefas']\n            worksheet_tasks.merge_range('A1:F1', 'Relat√≥rio de Tarefas', title_format)\n            for col_num, value in enumerate(df_tasks.columns.values):\n                worksheet_tasks.write(0, col_num, value, header_format)\n            # Auto-ajustar colunas (exemplo)\n            for i, col in enumerate(df_tasks.columns):\n                column_len = max(df_tasks[col].astype(str).map(len).max(), len(col))\n                worksheet_tasks.set_column(i, i, column_len + 2)\n\n\n        if export_type in ['all', 'reminders']:\n            reminders = reminder_query.all()\n            reminders_data = [{\n                'Nome': r.name,\n                'Tipo': r.type,\n                'Vencimento': r.due_date.strftime('%d/%m/%Y') if r.due_date else '',\n                'Respons√°vel': r.responsible,\n                'Setor': r.sector.name if r.sector else '',\n                'Usu√°rio': r.user.username if r.user else '',\n                'Realizado': 'Sim' if r.completed else 'N√£o'\n            } for r in reminders]\n            df_reminders = pd.DataFrame(reminders_data)\n            df_reminders.to_excel(writer, sheet_name='Lembretes', index=False, header=False, startrow=1)\n            worksheet_reminders = writer.sheets['Lembretes']\n            worksheet_reminders.merge_range('A1:G1', 'Relat√≥rio de Lembretes', title_format)\n            for col_num, value in enumerate(df_reminders.columns.values):\n                worksheet_reminders.write(0, col_num, value, header_format)\n            for i, col in enumerate(df_reminders.columns):\n                column_len = max(df_reminders[col].astype(str).map(len).max(), len(col))\n                worksheet_reminders.set_column(i, i, column_len + 2)\n\n        if export_type in ['all', 'chamados']: # Novo bloco para chamados\n            chamados = chamado_query.all()\n            chamados_data = [{\n                'ID': c.id,\n                'T√≠tulo': c.titulo,\n                'Status': c.status,\n                'Prioridade': c.prioridade,\n                'Abertura': c.data_abertura.strftime('%d/%m/%Y %H:%M') if c.data_abertura else '',\n                'Solicitante': c.solicitante.username if c.solicitante else '',\n                'Setor': c.setor.name if c.setor else '',\n                'Respons√°vel TI': c.responsavel_ti.username if c.responsavel_ti else ''\n            } for c in chamados]\n            df_chamados = pd.DataFrame(chamados_data)\n            df_chamados.to_excel(writer, sheet_name='Chamados', index=False, header=False, startrow=1)\n            worksheet_chamados = writer.sheets['Chamados']\n            worksheet_chamados.merge_range('A1:H1', 'Relat√≥rio de Chamados', title_format)\n            for col_num, value in enumerate(df_chamados.columns.values):\n                worksheet_chamados.write(0, col_num, value, header_format)\n            for i, col in enumerate(df_chamados.columns):\n                column_len = max(df_chamados[col].astype(str).map(len).max(), len(col))\n                worksheet_chamados.set_column(i, i, column_len + 2)\n\n        if export_type in ['all', 'equipamentos']: # Bloco para equipamentos\n            equipamentos = equipment_query.all()\n            equipamentos_data = [{\n                'ID': e.id,\n                'Descri√ß√£o': e.description,\n                'Patrim√¥nio': e.patrimony,\n                'Tipo': e.equipment_type,\n                'Status': e.status,\n                'Solicitante': e.requester.username if e.requester else '',\n                'Data Solicita√ß√£o': e.request_date.strftime('%d/%m/%Y') if e.request_date else ''\n            } for e in equipamentos]\n            df_equipamentos = pd.DataFrame(equipamentos_data)\n            df_equipamentos.to_excel(writer, sheet_name='Equipamentos', index=False, header=False, startrow=1)\n            worksheet_equipamentos = writer.sheets['Equipamentos']\n            worksheet_equipamentos.merge_range('A1:G1', 'Relat√≥rio de Equipamentos', title_format)\n            for col_num, value in enumerate(df_equipamentos.columns.values):\n                worksheet_equipamentos.write(0, col_num, value, header_format)\n            for i, col in enumerate(df_equipamentos.columns):\n                column_len = max(df_equipamentos[col].astype(str).map(len).max(), len(col))\n                worksheet_equipamentos.set_column(i, i, column_len + 2)\n\n        if export_type in ['all', 'tutoriais']:\n            # Consulta para obter os tutoriais\n            tutorial_query = Tutorial.query\n            \n            # Aplicar filtros de data se fornecidos\n            if start_date:\n                tutorial_query = tutorial_query.filter(Tutorial.data_criacao >= start_date)\n            if end_date:\n                tutorial_query = tutorial_query.filter(Tutorial.data_criacao <= end_date)\n                \n            # Aplicar filtro de usu√°rio se fornecido\n            if user_id_filter and (is_admin or is_ti):\n                tutorial_query = tutorial_query.filter(Tutorial.autor_id == user_id_filter)\n                \n            # Obter todos os tutoriais filtrados\n            tutoriais = tutorial_query.all()\n            \n            tutoriais_data = [{\n                'T√≠tulo': t.titulo,\n                'Categoria': t.categoria or '',\n                'Autor': t.autor.username,\n                'Data de Cria√ß√£o': t.data_criacao.strftime('%d/%m/%Y %H:%M'),\n                'Visualiza√ß√µes': len(t.visualizacoes),\n                'Feedback √ötil': sum(1 for f in t.feedbacks if f.util),\n                'Feedback N√£o √ötil': sum(1 for f in t.feedbacks if not f.util)\n            } for t in tutoriais]\n            df_tutoriais = pd.DataFrame(tutoriais_data)\n            df_tutoriais.to_excel(writer, sheet_name='Tutoriais', index=False, header=False, startrow=1)\n            worksheet_tutoriais = writer.sheets['Tutoriais']\n            worksheet_tutoriais.merge_range('A1:G1', 'Relat√≥rio de Tutoriais', title_format)\n            for col_num, value in enumerate(df_tutoriais.columns.values):\n                worksheet_tutoriais.write(0, col_num, value, header_format)\n            for i, col in enumerate(df_tutoriais.columns):\n                column_len = max(df_tutoriais[col].astype(str).map(len).max(), len(col))\n                worksheet_tutoriais.set_column(i, i, column_len + 2)\n\n    output.seek(0)\n    # For√ßar mimetype correto para navegadores modernos\n    return send_file(\n        output,\n        download_name='relatorio_reminder.xlsx',\n        as_attachment=True,\n        mimetype='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'\n    )\n\n@bp.route('/export/pdf')\ndef export_pdf():\n    from flask import request, session, make_response # make_response adicionado\n    # Models j√° importados na export_excel, mas para clareza se esta fun√ß√£o for movida:\n    # from .models import Task, Reminder, Chamado, Sector, User\n    # datetime, date j√° importados\n    # from io import BytesIO # J√° importado\n    from reportlab.lib.pagesizes import letter, landscape\n    from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, PageBreak\n    from reportlab.lib.styles import getSampleStyleSheet\n    from reportlab.lib.units import inch\n    from reportlab.lib import colors\n\n    task_status = request.args.get('task_status', '')\n    reminder_status = request.args.get('reminder_status', '')\n    chamado_status = request.args.get('chamado_status', '') # Novo\n    export_type = request.args.get('export_type', 'all')\n\n    start_date_str = request.args.get('start_date', '')\n    end_date_str = request.args.get('end_date', '')\n    sector_id = request.args.get('sector_id', type=int)\n    user_id_filter = request.args.get('user_id', type=int)\n\n    start_date = None\n    if start_date_str:\n        try:\n            start_date = datetime.strptime(start_date_str, '%Y-%m-%d').date()\n        except ValueError: pass\n    end_date = None\n    if end_date_str:\n        try:\n            end_date = datetime.strptime(end_date_str, '%Y-%m-%d').date()\n        except ValueError: pass\n\n    task_query = Task.query\n    reminder_query = Reminder.query\n    chamado_query = Chamado.query\n    equipment_query = EquipmentRequest.query # Query para equipamentos\n\n    current_user_id = session.get('user_id')\n    is_admin = session.get('is_admin', False)\n    is_ti = session.get('is_ti', False)\n\n    # Filtros de permiss√£o\n    if not is_admin and not is_ti:\n        task_query = task_query.filter(Task.user_id == current_user_id)\n        reminder_query = reminder_query.filter(Reminder.user_id == current_user_id)\n        chamado_query = chamado_query.filter(Chamado.solicitante_id == current_user_id)\n        equipment_query = equipment_query.filter(EquipmentRequest.requester_id == current_user_id)\n    elif not is_admin and is_ti:\n        user = User.query.get(current_user_id)\n        primeiro_lembrete = Reminder.query.filter_by(user_id=current_user_id).first()\n        setor_id_usuario = primeiro_lembrete.sector_id if primeiro_lembrete and primeiro_lembrete.sector_id else None\n        chamado_query = chamado_query.filter((Chamado.solicitante_id == current_user_id) | (Chamado.setor_id == setor_id_usuario))\n        equipment_query = EquipmentRequest.query\n\n    if task_status == 'done':\n        task_query = task_query.filter(Task.completed == True)\n    elif task_status == 'pending':\n        task_query = task_query.filter(Task.completed == False, Task.date >= date.today())\n    elif task_status == 'expired':\n        task_query = task_query.filter(Task.completed == False, Task.date < date.today())\n\n    if reminder_status == 'done':\n        reminder_query = reminder_query.filter(Reminder.completed == True)\n    elif reminder_status == 'pending':\n        reminder_query = reminder_query.filter(Reminder.completed == False)\n\n    if chamado_status:\n        chamado_query = chamado_query.filter(Chamado.status == chamado_status)\n\n    if start_date:\n        task_query = task_query.filter(Task.date >= start_date)\n        reminder_query = reminder_query.filter(Reminder.due_date >= start_date)\n        chamado_query = chamado_query.filter(Chamado.data_abertura >= start_date)\n        equipment_query = equipment_query.filter(EquipmentRequest.request_date >= start_date)\n    if end_date:\n        task_query = task_query.filter(Task.date <= end_date)\n        reminder_query = reminder_query.filter(Reminder.due_date <= end_date)\n        chamado_query = chamado_query.filter(Chamado.data_abertura <= end_date)\n        equipment_query = equipment_query.filter(EquipmentRequest.request_date <= end_date)\n\n    if sector_id:\n        task_query = task_query.filter(Task.sector_id == sector_id)\n        reminder_query = reminder_query.filter(Reminder.sector_id == sector_id)\n        chamado_query = chamado_query.filter(Chamado.setor_id == sector_id)\n        setor_nome = Sector.query.get(sector_id).name if Sector.query.get(sector_id) else ''\n        equipment_query = equipment_query.filter(EquipmentRequest.destination_sector.contains(setor_nome))\n\n\n    if user_id_filter and (is_admin or is_ti):\n        task_query = task_query.filter(Task.user_id == user_id_filter)\n        reminder_query = reminder_query.filter(Reminder.user_id == user_id_filter)\n        chamado_query = chamado_query.filter(Chamado.solicitante_id == user_id_filter)\n        equipment_query = equipment_query.filter(EquipmentRequest.requester_id == user_id_filter)\n\n    buffer = BytesIO()\n    doc = SimpleDocTemplate(buffer, pagesize=landscape(letter), rightMargin=0.5*inch, leftMargin=0.5*inch, topMargin=0.5*inch, bottomMargin=0.5*inch)\n    elements = []\n    styles = getSampleStyleSheet()\n    title_style = styles['h2'] # Usar H2 para subt√≠tulos de se√ß√£o\n    title_style.alignment = 1 # Center\n    normal_style = styles['Normal']\n    normal_style.fontSize = 8 # Reduzir um pouco para caber mais dados\n\n\n    # Definindo larguras das colunas (ajustar conforme necess√°rio)\n    col_widths_tasks = [2.3*inch, 0.8*inch, 1.2*inch, 1.2*inch, 1.2*inch, 0.8*inch]\n    col_widths_reminders = [1.8*inch, 0.8*inch, 0.8*inch, 1.2*inch, 1.2*inch, 1.2*inch, 0.8*inch]\n    col_widths_chamados = [0.4*inch, 1.5*inch, 0.8*inch, 0.8*inch, 1.2*inch, 1.2*inch, 1.2*inch, 1.2*inch]\n    col_widths_equipamentos = [0.4*inch, 2*inch, 0.8*inch, 0.8*inch, 0.8*inch, 1*inch, 1*inch] # Larguras para equipamentos\n\n    table_style = TableStyle([\n        ('BACKGROUND', (0,0), (-1,0), colors.HexColor(\"#4F81BD\")), # Azul escuro para cabe√ßalho\n        ('TEXTCOLOR', (0,0), (-1,0), colors.whitesmoke),\n        ('ALIGN', (0,0), (-1,-1), 'CENTER'),\n        ('VALIGN', (0,0), (-1,-1), 'MIDDLE'),\n        ('FONTNAME', (0,0), (-1,0), 'Helvetica-Bold'),\n        ('FONTSIZE', (0,0), (-1,0), 9),\n        ('BOTTOMPADDING', (0,0), (-1,0), 10),\n        ('BACKGROUND', (0,1), (-1,-1), colors.HexColor(\"#DCE6F1\")), # Azul claro para dados\n        ('GRID', (0,0), (-1,-1), 0.5, colors.black),\n        ('LEFTPADDING', (0,0), (-1,-1), 3),\n        ('RIGHTPADDING', (0,0), (-1,-1), 3),\n    ])\n\n    # T√≠tulo Geral do Documento\n    elements.append(Paragraph(\"Relat√≥rio Geral - TI OSN System\", styles['h1']))\n    elements.append(Spacer(1, 0.3*inch))\n\n    if export_type in ['all', 'tasks']:\n        tasks = task_query.all()\n        elements.append(Paragraph(\"Relat√≥rio de Tarefas\", title_style))\n        elements.append(Spacer(1, 0.1*inch))\n        if tasks:\n            data_tasks = [[\"Descri√ß√£o\", \"Data\", \"Respons√°vel\", \"Setor\", \"Usu√°rio\", \"Conclu√≠da\"]]\n            for t in tasks:\n                data_tasks.append([\n                    Paragraph(t.description if t.description else '', normal_style),\n                    t.date.strftime('%d/%m/%Y') if t.date else '',\n                    Paragraph(t.responsible if t.responsible else '', normal_style),\n                    Paragraph(t.sector.name if t.sector else '', normal_style),\n                    Paragraph(t.usuario.username if t.usuario else '', normal_style),\n                    \"Sim\" if t.completed else \"N√£o\"\n                ])\n            table = Table(data_tasks, colWidths=col_widths_tasks)\n            table.setStyle(table_style)\n            elements.append(table)\n        else:\n            elements.append(Paragraph(\"Nenhuma tarefa encontrada.\", normal_style))\n        elements.append(PageBreak() if export_type == 'all' else Spacer(1, 0.3*inch))\n\n    if export_type in ['all', 'reminders']:\n        reminders = reminder_query.all()\n        elements.append(Paragraph(\"Relat√≥rio de Lembretes\", title_style))\n        elements.append(Spacer(1, 0.1*inch))\n        if reminders:\n            data_reminders = [[\"Nome\", \"Tipo\", \"Vencimento\", \"Respons√°vel\", \"Setor\", \"Usu√°rio\", \"Realizado\"]]\n            for r in reminders:\n                data_reminders.append([\n                    Paragraph(r.name if r.name else '', normal_style),\n                    Paragraph(r.type if r.type else '', normal_style),\n                    r.due_date.strftime('%d/%m/%Y') if r.due_date else '',\n                    Paragraph(r.responsible if r.responsible else '', normal_style),\n                    Paragraph(r.sector.name if r.sector else '', normal_style),\n                    Paragraph(r.user.username if r.user else '', normal_style),\n                    \"Sim\" if r.completed else \"N√£o\"\n                ])\n            table = Table(data_reminders, colWidths=col_widths_reminders)\n            table.setStyle(table_style)\n            elements.append(table)\n        else:\n            elements.append(Paragraph(\"Nenhum lembrete encontrado.\", normal_style))\n        elements.append(PageBreak() if export_type == 'all' else Spacer(1, 0.3*inch))\n\n    if export_type in ['all', 'chamados']:\n        chamados = chamado_query.all()\n        elements.append(Paragraph(\"Relat√≥rio de Chamados\", title_style))\n        elements.append(Spacer(1, 0.1*inch))\n        if chamados:\n            data_chamados = [[\"ID\", \"T√≠tulo\", \"Status\", \"Prioridade\", \"Abertura\", \"Solicitante\", \"Setor\", \"Resp. TI\"]]\n            for c in chamados:\n                data_chamados.append([\n                    str(c.id),\n                    Paragraph(c.titulo if c.titulo else '', normal_style),\n                    Paragraph(c.status if c.status else '', normal_style),\n                    Paragraph(c.prioridade if c.prioridade else '', normal_style),\n                    c.data_abertura.strftime('%d/%m/%Y %H:%M') if c.data_abertura else '',\n                    Paragraph(c.solicitante.username if c.solicitante else '', normal_style),\n                    Paragraph(c.setor.name if c.setor else '', normal_style),\n                    Paragraph(c.responsavel_ti.username if c.responsavel_ti else '', normal_style)\n                ])\n            table = Table(data_chamados, colWidths=col_widths_chamados)\n            table.setStyle(table_style)\n            elements.append(table)\n        else:\n            elements.append(Paragraph(\"Nenhum chamado encontrado.\", normal_style))\n        elements.append(PageBreak() if export_type == 'all' else Spacer(1, 0.3*inch))\n\n    if export_type in ['all', 'equipamentos']:\n        equipamentos = equipment_query.all()\n        elements.append(Paragraph(\"Relat√≥rio de Equipamentos\", title_style))\n        elements.append(Spacer(1, 0.1*inch))\n        if equipamentos:\n            data_equipamentos = [[\"ID\", \"Descri√ß√£o\", \"Patrim√¥nio\", \"Tipo\", \"Status\", \"Solicitante\", \"Data Solicita√ß√£o\"]]\n            for e in equipamentos:\n                data_equipamentos.append([\n                    str(e.id),\n                    Paragraph(e.description if e.description else '', normal_style),\n                    e.patrimony if e.patrimony else '',\n                    e.equipment_type if e.equipment_type else '',\n                    Paragraph(e.status if e.status else '', normal_style),\n                    Paragraph(e.requester.username if e.requester else '', normal_style),\n                    e.request_date.strftime('%d/%m/%Y') if e.request_date else ''\n                ])\n            table = Table(data_equipamentos, colWidths=col_widths_equipamentos)\n            table.setStyle(table_style)\n            elements.append(table)\n        else:\n            elements.append(Paragraph(\"Nenhum equipamento encontrado.\", normal_style))\n        elements.append(PageBreak() if export_type == 'all' else Spacer(1, 0.3*inch))\n\n    if not elements or all(isinstance(el, (Paragraph, Spacer)) and \"Nenhum\" in el.text for el in elements if isinstance(el, Paragraph)):\n         elements.append(Paragraph(\"Nenhum dado para exportar com os filtros selecionados.\", styles['Normal']))\n\n    tutorial_query = Tutorial.query\n    if not is_admin and not is_ti:\n        tutorial_query = tutorial_query.filter(Tutorial.autor_id == current_user_id)\n    if sector_id:\n        tutorial_query = tutorial_query.join(User).filter(User.sector_id == sector_id)\n    if user_id_filter and (is_admin or is_ti):\n        tutorial_query = tutorial_query.filter(Tutorial.autor_id == user_id_filter)\n    if start_date:\n        tutorial_query = tutorial_query.filter(Tutorial.data_criacao >= start_date)\n    if end_date:\n        tutorial_query = tutorial_query.filter(Tutorial.data_criacao <= end_date)\n    tutoriais = tutorial_query.all()\n    if export_type in ['all', 'tutoriais']:\n        elements.append(Paragraph(\"Relat√≥rio de Tutoriais\", title_style))\n        elements.append(Spacer(1, 0.1*inch))\n        if tutoriais:\n            data_tutoriais = [[\"T√≠tulo\", \"Categoria\", \"Autor\", \"Data de Cria√ß√£o\", \"Visualiza√ß√µes\", \"Feedback √ötil\", \"Feedback N√£o √ötil\"]]\n            for t in tutoriais:\n                data_tutoriais.append([\n                    Paragraph(t.titulo if t.titulo else '', normal_style),\n                    Paragraph(t.categoria if t.categoria else '', normal_style),\n                    Paragraph(t.autor.username if t.autor else '', normal_style),\n                    t.data_criacao.strftime('%d/%m/%Y %H:%M'),\n                    str(len(t.visualizacoes)),\n                    str(sum(1 for f in t.feedbacks if f.util)),\n                    str(sum(1 for f in t.feedbacks if not f.util))\n                ])\n            table = Table(data_tutoriais, colWidths=[2*inch, 1*inch, 1.2*inch, 1.2*inch, 1*inch, 1*inch, 1*inch])\n            table.setStyle(table_style)\n            elements.append(table)\n        else:\n            elements.append(Paragraph(\"Nenhum tutorial encontrado.\", normal_style))\n        elements.append(PageBreak() if export_type == 'all' else Spacer(1, 0.3*inch))\n\n    doc.build(elements)\n    buffer.seek(0)\n    response = make_response(buffer.getvalue())\n    response.headers['Content-Type'] = 'application/pdf'\n    response.headers['Content-Disposition'] = 'attachment; filename=relatorio_ti_reminder.pdf'\n    return response\n\n# --- Tarefas ---\n@bp.route('/tasks', methods=['GET', 'POST'])\n@login_required\ndef tasks():\n    from .models import Sector\n    form = TaskForm()\n    # Popular o select de setores\n    sectors = Sector.query.order_by(Sector.name).all()\n    form.sector_id.choices = [(0, 'Selecione')] + [(s.id, s.name) for s in sectors]\n    page = request.args.get('page', 1, type=int)\n    per_page = 10\n    # Filtros e busca\n    status_filter = request.args.get('status', '')\n    search = request.args.get('search', '').strip()\n    date_filter = request.args.get('date', '')\n    query = Task.query\n    if status_filter == 'expired':\n        query = query.filter(Task.completed == False, Task.date < date.today())\n    elif status_filter == 'today':\n        query = query.filter(Task.completed == False, Task.date == date.today())\n    elif status_filter == 'done':\n        query = query.filter(Task.completed == True)\n    elif status_filter == 'pending':\n        query = query.filter(Task.completed == False, Task.date >= date.today())\n    if search:\n        query = query.filter(Task.description.ilike(f'%{search}%') | Task.responsible.ilike(f'%{search}%'))\n    if date_filter:\n        try:\n            filter_date = datetime.strptime(date_filter, '%Y-%m-%d').date()\n            query = query.filter(Task.date == filter_date)\n        except:\n            pass\n    # Admin pode ver todas as tarefas, usu√°rio comum s√≥ as pr√≥prias\n    if not session.get('is_admin'):\n        query = query.filter_by(user_id=session.get('user_id'))\n    pagination = query.order_by(Task.date.desc()).paginate(page=page, per_page=per_page, error_out=False)\n    tasks = pagination.items\n    # Aplica status visual\n    for t in tasks:\n        if t.completed:\n            t.status = 'done'\n        elif t.date < date.today():\n            t.status = 'expired'\n        elif t.date == date.today():\n            t.status = 'today'\n        else:\n            t.status = 'pending'\n    if form.validate_on_submit():\n        # L√≥gica do setor: se novo setor preenchido, criar e usar\n        sector_id = form.sector_id.data\n        new_sector_name = form.new_sector.data.strip() if form.new_sector.data else ''\n        if new_sector_name:\n            existing = Sector.query.filter_by(name=new_sector_name).first()\n            if existing:\n                sector = existing\n            else:\n                sector = Sector(name=new_sector_name)\n                db.session.add(sector)\n                db.session.commit()\n            sector_id = sector.id\n        elif sector_id == 0:\n            sector_id = None\n        task = Task(\n            description=form.description.data,\n            date=form.date.data,\n            responsible=form.responsible.data,\n            completed=form.completed.data,\n            sector_id=sector_id,\n            user_id=session.get('user_id')\n        )\n        db.session.add(task)\n        db.session.commit()\n        flash('Tarefa adicionada!', 'success')\n        return redirect(url_for('main.tasks'))\n    return render_template('tasks.html', tasks=tasks, form=form, edit_id=None, pagination=pagination, status_filter=status_filter, search=search, date_filter=date_filter, current_date=date.today())\n\n\n@bp.route('/tasks/edit/<int:id>', methods=['GET', 'POST'])\n@login_required\ndef edit_task(id):\n    if session.get('is_admin'):\n        task = Task.query.get_or_404(id)\n    else:\n        task = Task.query.filter_by(id=id, user_id=session.get('user_id')).first_or_404()\n    form = TaskForm(obj=task)\n    # Popular o select de setores\n    sectors = Sector.query.order_by(Sector.name).all()\n    form.sector_id.choices = [(0, 'Selecione')] + [(s.id, s.name) for s in sectors]\n    if form.validate_on_submit():\n        # L√≥gica do setor: se novo setor preenchido, criar e usar\n        sector_id = form.sector_id.data\n        new_sector_name = form.new_sector.data.strip() if form.new_sector.data else ''\n        if new_sector_name:\n            existing = Sector.query.filter_by(name=new_sector_name).first()\n            if existing:\n                sector = existing\n            else:\n                sector = Sector(name=new_sector_name)\n                db.session.add(sector)\n                db.session.commit()\n            sector_id = sector.id\n        elif sector_id == 0:\n            sector_id = None\n        form.populate_obj(task)\n        task.sector_id = sector_id\n        db.session.commit()\n        flash('Tarefa atualizada!', 'success')\n        return redirect(url_for('main.tasks'))\n    # L√≥gica de pagina√ß√£o e filtros igual √† fun√ß√£o tasks\n    page = request.args.get('page', 1, type=int)\n    per_page = 10\n    status_filter = request.args.get('status', '')\n    search = request.args.get('search', '').strip()\n    date_filter = request.args.get('date', '')\n    query = Task.query\n    if status_filter == 'expired':\n        query = query.filter(Task.completed == False, Task.date < date.today())\n    elif status_filter == 'today':\n        query = query.filter(Task.completed == False, Task.date == date.today())\n    elif status_filter == 'done':\n        query = query.filter(Task.completed == True)\n    elif status_filter == 'pending':\n        query = query.filter(Task.completed == False, Task.date >= date.today())\n    if search:\n        query = query.filter(Task.description.ilike(f'%{search}%') | Task.responsible.ilike(f'%{search}%'))\n    if date_filter:\n        query = query.filter(Task.date == date_filter)\n    pagination = query.order_by(Task.date.desc()).paginate(page=page, per_page=per_page, error_out=False)\n    tasks = pagination.items\n    # Aplica status visual\n    for t in tasks:\n        if t.completed:\n            t.status = 'done'\n        elif t.date < date.today():\n            t.status = 'expired'\n        elif t.date == date.today():\n            t.status = 'today'\n        else:\n            t.status = 'pending'\n    return render_template('tasks.html', tasks=tasks, form=form, edit_id=id, pagination=pagination, status_filter=status_filter, search=search, date_filter=date_filter)\n\n\n\n\n@bp.route('/tasks/complete/<int:id>', methods=['POST'])\ndef complete_task(id):\n    task = Task.query.get_or_404(id)\n    task.completed = True\n    db.session.commit()\n    flash('Tarefa marcada como conclu√≠da!', 'success')\n    return redirect(url_for('main.tasks'))\n\n@bp.route('/tasks/delete/<int:id>', methods=['POST'])\ndef delete_task(id):\n    if session.get('is_admin'):\n        task = Task.query.get_or_404(id)\n    else:\n        task = Task.query.filter_by(id=id, user_id=session.get('user_id')).first_or_404()\n    db.session.delete(task)\n    db.session.commit()\n    flash('Tarefa exclu√≠da!', 'success')\n    return redirect(url_for('main.tasks'))\n\n\nfrom .models import Chamado, User\nfrom .forms import ChamadoForm\nfrom .email_utils import send_chamado_aberto_email\n\n# --- Rotas para Chamados ---\n\n@bp.route('/chamados/abrir', methods=['GET', 'POST'])\n@login_required\ndef abrir_chamado():\n    form = ChamadoForm()\n    user_id = session.get('user_id')\n    user = User.query.get(user_id)\n\n    # Tenta obter o setor do usu√°rio de diferentes fontes\n    setor_usuario = None\n\n    # 1. Verifica se o usu√°rio tem um setor atribu√≠do diretamente\n    if user.sector:\n        setor_usuario = user.sector\n    # 2. Verifica em lembretes do usu√°rio\n    elif user.reminders:\n        for lembrete in user.reminders:\n            if lembrete.sector:\n                setor_usuario = lembrete.sector\n                break\n    # 3. Verifica em tarefas do usu√°rio\n    elif user.tasks:\n        for tarefa in user.tasks:\n            if tarefa.sector:\n                setor_usuario = tarefa.sector\n                break\n\n    if request.method == 'POST' and form.validate_on_submit():\n        try:\n            # Verificar se o usu√°rio est√° criando um novo setor\n            if form.new_sector.data and form.new_sector.data.strip():\n                # Verificar se o setor j√° existe\n                setor_existente = Sector.query.filter_by(name=form.new_sector.data.strip()).first()\n                if setor_existente:\n                    setor_id = setor_existente.id\n                else:\n                    # Criar novo setor\n                    novo_setor = Sector(name=form.new_sector.data.strip())\n                    db.session.add(novo_setor)\n                    db.session.commit()\n                    setor_id = novo_setor.id\n                    flash(f\"Novo setor '{novo_setor.name}' criado com sucesso!\", \"success\")\n            else:\n                # Usar o setor selecionado pelo usu√°rio no formul√°rio\n                setor_id = form.setor_id.data\n                \n                # Se o usu√°rio n√£o selecionou um setor (valor 0), usar o setor do usu√°rio ou criar um gen√©rico\n                if setor_id == 0:\n                    setor_id = setor_usuario.id if setor_usuario else 1\n                    \n                    # Verificar se o setor existe, se n√£o, criar um setor gen√©rico\n                    if not Sector.query.get(setor_id):\n                        setor_generico = Sector(id=1, name=\"Geral\")\n                        db.session.add(setor_generico)\n                        db.session.commit()\n                        setor_id = 1\n            \n            novo_chamado = Chamado(\n                titulo=form.titulo.data,\n                descricao=form.descricao.data,\n                prioridade=form.prioridade.data,\n                solicitante_id=user_id,\n                setor_id=setor_id,\n                status='Aberto'  # Status inicial\n            )\n            \n            # Calcular e definir o prazo de SLA automaticamente\n            novo_chamado.calcular_sla()\n\n            db.session.add(novo_chamado)\n            db.session.commit()\n\n            # Enviar email de notifica√ß√£o\n            try:\n                send_chamado_aberto_email(novo_chamado)\n                flash(\"Notifica√ß√µes enviadas com sucesso!\", \"info\")\n            except Exception as e:\n                db.session.rollback()\n                flash(f\"Chamado criado, mas houve um erro ao enviar notifica√ß√µes: {str(e)}\", \"warning\")\n                print(f\"Error sending notification email for Chamado {novo_chamado.id}: {e}\")\n\n            flash(\"Chamado aberto com sucesso!\", \"success\")\n            return redirect(url_for('main.detalhe_chamado', id=novo_chamado.id))\n\n        except Exception as e:\n            db.session.rollback()\n            flash(f\"Erro ao abrir o chamado: {str(e)}\", \"danger\")\n            print(f\"Error creating Chamado: {e}\")\n\n    # Pr√©-selecionar o setor do usu√°rio no formul√°rio, se existir\n    if setor_usuario and hasattr(form, 'setor_id'):\n        form.setor_id.data = setor_usuario.id\n        \n    return render_template('abrir_chamado.html',\n                         form=form,\n                         title='Abrir Novo Chamado',\n                         setor_usuario=setor_usuario)\n\n@bp.route('/chamados', methods=['GET'])\n@login_required\ndef listar_chamados():\n    page = request.args.get('page', 1, type=int)\n    per_page = 10\n    status_filter = request.args.get('status', '')\n    prioridade_filter = request.args.get('prioridade', '')\n    setor_filter = request.args.get('sector_id', type=int)\n\n    query = Chamado.query\n\n    # Filtrar por permiss√£o: Admin/TI v√™ tudo, usu√°rio comum v√™ os seus e/ou do seu setor\n    if not session.get('is_admin'): # Assumindo que 'is_admin' tamb√©m cobre a equipe de TI por enquanto\n        user_id = session.get('user_id')\n        # Obter setor do usu√°rio (mesma l√≥gica/problema de 'abrir_chamado')\n        user = User.query.get(user_id)\n        primeiro_lembrete = Reminder.query.filter_by(user_id=user_id).first()\n        setor_id_usuario = primeiro_lembrete.sector_id if primeiro_lembrete and primeiro_lembrete.sector_id else None\n        # Mostrar chamados do usu√°rio ou do setor do usu√°rio (ajustar conforme regra)\n        query = query.filter((Chamado.solicitante_id == user_id) | (Chamado.setor_id == setor_id_usuario))\n\n    # Aplicar filtros adicionais\n    if status_filter:\n        query = query.filter(Chamado.status == status_filter)\n    if prioridade_filter:\n        query = query.filter(Chamado.prioridade == prioridade_filter)\n    if setor_filter:\n        query = query.filter(Chamado.setor_id == setor_filter)\n\n    chamados_paginated = query.order_by(Chamado.data_abertura.desc()).paginate(page=page, per_page=per_page)\n\n    # Para os filtros no template\n    setores = Sector.query.order_by(Sector.name).all()\n    status_list = db.session.query(Chamado.status).distinct().all()\n    prioridade_list = db.session.query(Chamado.prioridade).distinct().all()\n\n    return render_template('listar_chamados.html',\n                           chamados=chamados_paginated.items,\n                           pagination=chamados_paginated,\n                           setores=setores,\n                           status_list=[s[0] for s in status_list],\n                           prioridade_list=[p[0] for p in prioridade_list],\n                           title='Meus Chamados')\n\n@bp.route('/chamados/<int:id>')\n@login_required\ndef detalhe_chamado(id):\n    from .forms import ChamadoAdminForm\n\n    query = Chamado.query\n    is_admin = session.get('is_admin')\n    user_id = session.get('user_id')\n\n    # Aplicar restri√ß√£o de acesso\n    if not is_admin:\n        user = User.query.get(user_id)\n        primeiro_lembrete = Reminder.query.filter_by(user_id=user_id).first()\n        setor_id_usuario = primeiro_lembrete.sector_id if primeiro_lembrete and primeiro_lembrete.sector_id else None\n        # Permitir ver se for o solicitante ou do mesmo setor\n        query = query.filter((Chamado.solicitante_id == user_id) | (Chamado.setor_id == setor_id_usuario))\n\n    chamado = query.filter(Chamado.id == id).first_or_404()\n\n    # Se for administrador, preparar o formul√°rio administrativo\n    form = None\n    usuarios_ti = []\n    if is_admin:\n        form = ChamadoAdminForm()\n        form.status.choices = [\n            ('Aberto', 'Aberto'),\n            ('Em Andamento', 'Em Andamento'),\n            ('Resolvido', 'Resolvido'),\n            ('Fechado', 'Fechado')\n        ]\n        form.status.data = chamado.status\n\n        # Buscar apenas usu√°rios ativos com perfil de TI\n        usuarios_ti = User.query.filter_by(is_ti=True, ativo=True).order_by(User.username).all()\n\n        # Definir o valor atual do respons√°vel TI, se existir\n        if chamado.responsavel_ti_id:\n            form.responsavel_ti_id.data = str(chamado.responsavel_ti_id)\n\n    return render_template(\n        'detalhe_chamado.html',\n        chamado=chamado,\n        form=form,\n        usuarios_ti=usuarios_ti,\n        title=f'Chamado #{chamado.id}'\n    )\n\n@bp.route('/chamados/<int:id>/admin', methods=['POST'])\n@login_required\ndef gerenciar_chamado(id):\n    from .models import Chamado, ComentarioChamado, ComentarioTutorial, db\n    from .forms import ChamadoAdminForm\n    from .email_utils import send_chamado_atualizado_email\n\n    # Verifica se o usu√°rio √© administrador\n    if not session.get('is_admin'):\n        flash('Acesso restrito a administradores.', 'danger')\n        return redirect(url_for('main.detalhe_chamado', id=id))\n\n    chamado = Chamado.query.get_or_404(id)\n    form = ChamadoAdminForm()\n\n    # Preenche as op√ß√µes de respons√°vel TI (apenas usu√°rios ativos e marcados como TI)\n    usuarios_ti = User.query.filter_by(ativo=True, is_ti=True).order_by(User.username).all()\n    form.responsavel_ti_id.choices = [('', 'Nenhum (sem respons√°vel)')] + [(str(u.id), u.username) for u in usuarios_ti]\n\n    if form.validate_on_submit():\n        alteracoes = []\n\n        # Atualiza o status se foi alterado\n        if form.status.data != chamado.status:\n            alteracoes.append(f'Status alterado de \"{chamado.status}\" para \"{form.status.data}\"')\n            \n            # Marcar primeira resposta se mudou de \"Aberto\" para qualquer outro status\n            if chamado.status == 'Aberto' and form.status.data in ['Em Andamento', 'Resolvido', 'Fechado']:\n                chamado.marcar_primeira_resposta()\n                alteracoes.append('Primeira resposta registrada para c√°lculo de SLA')\n            \n            chamado.status = form.status.data\n\n            # Atualiza a data de fechamento se o status for Fechado\n            if form.status.data == 'Fechado' and not chamado.data_fechamento:\n                chamado.data_fechamento = datetime.utcnow()\n                alteracoes.append('Chamado fechado')\n            elif form.status.data != 'Fechado' and chamado.data_fechamento:\n                chamado.data_fechamento = None\n                alteracoes.append('Chamado reaberto')\n\n        # Atualiza o respons√°vel TI se foi alterado\n        if form.responsavel_ti_id.data != str(chamado.responsavel_ti_id if chamado.responsavel_ti_id else ''):\n            if form.responsavel_ti_id.data:  # Novo respons√°vel selecionado\n                novo_responsavel = User.query.get(form.responsavel_ti_id.data)\n                if novo_responsavel:\n                    alteracoes.append(f'Respons√°vel TI alterado para {novo_responsavel.username}')\n                    chamado.responsavel_ti_id = novo_responsavel.id\n            else:  # Nenhum respons√°vel selecionado\n                if chamado.responsavel_ti:\n                    alteracoes.append('Respons√°vel TI removido')\n                    chamado.responsavel_ti_id = None\n\n        # Adiciona um coment√°rio se foi preenchido\n        if form.comentario.data.strip():\n            comentario = ComentarioChamado(\n                chamado_id=chamado.id,\n                usuario_id=session['user_id'],\n                texto=form.comentario.data,\n                tipo='comentario'\n            )\n            db.session.add(comentario)\n            alteracoes.append('Coment√°rio adicionado')\n\n        # Se houve altera√ß√µes, registra como atualiza√ß√£o\n        if alteracoes:\n            # Atualiza a data da √∫ltima atualiza√ß√£o\n            chamado.data_ultima_atualizacao = datetime.utcnow()\n\n            # Cria um registro de atualiza√ß√£o\n            atualizacao = ComentarioChamado(\n                chamado_id=chamado.id,\n                usuario_id=session['user_id'],\n                texto=' | '.join(alteracoes),\n                tipo='atualizacao'\n            )\n            db.session.add(atualizacao)\n\n            db.session.commit()\n\n            # Envia notifica√ß√£o por e-mail se solicitado\n            if form.notificar_solicitante.data and chamado.solicitante.email:\n                try:\n                    send_chamado_atualizado_email(chamado, atualizacao)\n                except Exception as e:\n                    print(f\"Erro ao enviar e-mail: {str(e)}\")\n                    flash('Chamado atualizado, mas ocorreu um erro ao enviar a notifica√ß√£o por e-mail.', 'warning')\n\n            flash('Chamado atualizado com sucesso!', 'success')\n        else:\n            flash('Nenhuma altera√ß√£o foi realizada.', 'info')\n\n        return redirect(url_for('main.detalhe_chamado', id=chamado.id))\n\n    # Se o formul√°rio n√£o for v√°lido, mostra os erros\n    for field, errors in form.errors.items():\n        for error in errors:\n            flash(f'Erro no campo {getattr(form, field).label.text}: {error}', 'danger')\n\n    return redirect(url_for('main.detalhe_chamado', id=chamado.id))\n\n# --- Tutoriais ---\n# Apenas usu√°rios com is_ti=True (Equipe de TI) podem cadastrar, editar e excluir tutoriais.\n\n@bp.route('/tutoriais')\n@login_required\ndef listar_tutoriais():\n    busca = request.args.get('busca', '').strip()\n    page = request.args.get('page', 1, type=int)\n    per_page = 6\n    query = Tutorial.query\n    if busca:\n        query = query.filter((Tutorial.titulo.ilike(f'%{busca}%')) | (Tutorial.conteudo.ilike(f'%{busca}%')) | (Tutorial.categoria.ilike(f'%{busca}%')))\n    pagination = query.order_by(Tutorial.data_criacao.desc()).paginate(page=page, per_page=per_page, error_out=False)\n    tutoriais = pagination.items\n    return render_template('tutoriais.html', tutoriais=tutoriais, busca=busca, pagination=pagination)\n\n@bp.route('/tutoriais/novo', methods=['GET', 'POST'])\n@login_required\ndef novo_tutorial():\n    # Apenas membros da equipe de TI ou administradores podem cadastrar tutoriais\n    if not (session.get('is_ti') or session.get('is_admin')):\n        flash('Apenas membros da equipe de TI ou administradores podem cadastrar tutoriais.', 'danger')\n        return redirect(url_for('main.listar_tutoriais'))\n    form = TutorialForm()\n    if form.validate_on_submit():\n        tutorial = Tutorial(\n            titulo=form.titulo.data,\n            conteudo=form.conteudo.data,\n            categoria=form.categoria.data,\n            autor_id=session.get('user_id')\n        )\n        db.session.add(tutorial)\n        db.session.commit()\n        # Upload de imagens\n        if form.imagem.data:\n            upload_folder = os.path.join(current_app.root_path, 'static', 'uploads')\n            os.makedirs(upload_folder, exist_ok=True)\n            file = form.imagem.data\n            if file:\n                filename = secure_filename(file.filename)\n                file.save(os.path.join(upload_folder, filename))\n                img = TutorialImage(tutorial_id=tutorial.id, filename=filename)\n                db.session.add(img)\n            db.session.commit()\n        flash('Tutorial cadastrado com sucesso!', 'success')\n        return redirect(url_for('main.listar_tutoriais'))\n    return render_template('tutorial_form.html', form=form, title='Novo Tutorial')\n\n@bp.route('/tutoriais/<int:tutorial_id>')\n@login_required\ndef detalhe_tutorial(tutorial_id):\n    tutorial = Tutorial.query.get_or_404(tutorial_id)\n    comentario_form = ComentarioTutorialForm()\n    feedback_form = FeedbackTutorialForm()\n    # Registrar visualiza√ß√£o (mant√©m se j√° estiver)\n    visualizacao = VisualizacaoTutorial(tutorial_id=tutorial.id, usuario_id=session.get('user_id'))\n    db.session.add(visualizacao)\n    db.session.commit()\n    # Preparar dados para gr√°ficos (mant√©m se j√° estiver)\n    visualizacoes = VisualizacaoTutorial.query.filter_by(tutorial_id=tutorial.id).all()\n    datas = [v.data.strftime('%d/%m') for v in visualizacoes]\n    from collections import Counter\n    contagem_datas = Counter(datas)\n    datas_ordenadas = sorted(contagem_datas.keys(), key=lambda x: tuple(map(int, x.split('/')[::-1])))\n    visualizacoes_labels = datas_ordenadas[-15:]\n    visualizacoes_values = [contagem_datas[d] for d in visualizacoes_labels]\n    feedbacks = tutorial.feedbacks\n    total_util = sum(1 for f in feedbacks if f.util)\n    total_nao_util = sum(1 for f in feedbacks if not f.util)\n    feedback_data = {\n        'labels': ['√ötil', 'N√£o √∫til'],\n        'values': [total_util, total_nao_util]\n    }\n    import json\n    conteudo_markdown = markdown.markdown(tutorial.conteudo, extensions=['extra', 'nl2br'])\n    return render_template(\n        'tutorial_detalhe.html',\n        tutorial=tutorial,\n        comentario_form=comentario_form,\n        feedback_form=feedback_form,\n        visualizacoes_labels=json.dumps(visualizacoes_labels),\n        visualizacoes_values=json.dumps(visualizacoes_values),\n        feedback_data=json.dumps(feedback_data),\n        conteudo_markdown=conteudo_markdown\n    )\n\n@bp.route('/tutoriais/<int:tutorial_id>/editar', methods=['GET', 'POST'])\n@login_required\ndef editar_tutorial(tutorial_id):\n    tutorial = Tutorial.query.get_or_404(tutorial_id)\n    # Apenas membros da equipe de TI ou administradores podem editar tutoriais\n    if not (session.get('is_ti') or session.get('is_admin')) or (not session.get('is_admin') and tutorial.autor_id != session.get('user_id')):\n        flash('Apenas o autor TI ou administradores podem editar este tutorial.', 'danger')\n        return redirect(url_for('main.detalhe_tutorial', tutorial_id=tutorial.id))\n    form = TutorialForm(obj=tutorial)\n    if form.validate_on_submit():\n        tutorial.titulo = form.titulo.data\n        tutorial.conteudo = form.conteudo.data\n        tutorial.categoria = form.categoria.data\n        # Upload de novas imagens\n        if form.imagem.data:\n            upload_folder = os.path.join(current_app.root_path, 'static', 'uploads')\n            os.makedirs(upload_folder, exist_ok=True)\n            file = form.imagem.data\n            if file:\n                filename = secure_filename(file.filename)\n                file.save(os.path.join(upload_folder, filename))\n                img = TutorialImage(tutorial_id=tutorial.id, filename=filename)\n                db.session.add(img)\n        db.session.commit()\n        flash('Tutorial atualizado com sucesso!', 'success')\n        return redirect(url_for('main.detalhe_tutorial', tutorial_id=tutorial.id))\n    return render_template('tutorial_form.html', form=form, title='Editar Tutorial')\n\n@bp.route('/tutoriais/<int:tutorial_id>/excluir', methods=['POST'])\n@login_required\ndef excluir_tutorial(tutorial_id):\n    tutorial = Tutorial.query.get_or_404(tutorial_id)\n    # Apenas membros da equipe de TI ou administradores podem excluir tutoriais\n    if not (session.get('is_ti') or session.get('is_admin')) or (not session.get('is_admin') and tutorial.autor_id != session.get('user_id')):\n        flash('Apenas o autor TI ou administradores podem excluir este tutorial.', 'danger')\n        return redirect(url_for('main.detalhe_tutorial', tutorial_id=tutorial.id))\n    # Excluir imagens do disco\n    upload_folder = os.path.join(current_app.root_path, 'static', 'uploads')\n    for img in tutorial.imagens:\n        img_path = os.path.join(upload_folder, img.filename)\n        if os.path.exists(img_path):\n            os.remove(img_path)\n        db.session.delete(img)\n    db.session.delete(tutorial)\n    db.session.commit()\n    flash('Tutorial exclu√≠do com sucesso!', 'success')\n    return redirect(url_for('main.listar_tutoriais'))\n\n@bp.route('/tutoriais/<int:tutorial_id>/comentar', methods=['POST'])\n@login_required\ndef comentar_tutorial(tutorial_id):\n    tutorial = Tutorial.query.get_or_404(tutorial_id)\n    comentario_form = ComentarioTutorialForm()\n    feedback_form = FeedbackTutorialForm()\n    if comentario_form.validate_on_submit():\n        comentario = ComentarioTutorial(\n            tutorial_id=tutorial.id,\n            usuario_id=session.get('user_id'),\n            texto=comentario_form.texto.data\n        )\n        db.session.add(comentario)\n        db.session.commit()\n        flash('Coment√°rio enviado com sucesso!', 'success')\n        return redirect(url_for('main.detalhe_tutorial', tutorial_id=tutorial.id))\n    else:\n        flash('Erro ao enviar coment√°rio.', 'danger')\n        # Renderiza o template com os formul√°rios em caso de erro\n        return render_template('tutorial_detalhe.html', tutorial=tutorial, comentario_form=comentario_form, feedback_form=feedback_form)\n\n@bp.route('/tutoriais/<int:tutorial_id>/feedback', methods=['POST'])\n@login_required\ndef feedback_tutorial(tutorial_id):\n    tutorial = Tutorial.query.get_or_404(tutorial_id)\n    comentario_form = ComentarioTutorialForm()\n    form = FeedbackTutorialForm()\n    if form.validate_on_submit():\n        feedback_existente = FeedbackTutorial.query.filter_by(tutorial_id=tutorial.id, usuario_id=session.get('user_id')).first()\n        if not feedback_existente:\n            feedback = FeedbackTutorial(\n                tutorial_id=tutorial.id,\n                usuario_id=session.get('user_id'),\n                util=form.util.data\n            )\n            db.session.add(feedback)\n            db.session.commit()\n            flash('Feedback registrado!', 'success')\n        else:\n            flash('Voc√™ j√° enviou feedback para este tutorial.', 'info')\n        return redirect(url_for('main.detalhe_tutorial', tutorial_id=tutorial.id))\n    else:\n        flash('Erro ao enviar feedback.', 'danger')\n        # Renderiza o template com os formul√°rios em caso de erro\n        return render_template('tutorial_detalhe.html', tutorial=tutorial, comentario_form=comentario_form, feedback_form=form)\n\n@bp.route('/tutoriais/<int:tutorial_id>/pdf')\n@login_required\ndef exportar_tutorial_pdf(tutorial_id):\n    tutorial = Tutorial.query.get_or_404(tutorial_id)\n    buffer = BytesIO()\n    p = canvas.Canvas(buffer, pagesize=letter)\n    width, height = letter\n    y = height - 40\n    p.setFont('Helvetica-Bold', 16)\n    p.drawString(40, y, tutorial.titulo)\n    y -= 30\n    p.setFont('Helvetica', 12)\n    p.drawString(40, y, f'Categoria: {tutorial.categoria or \"Sem categoria\"}')\n    y -= 20\n    p.drawString(40, y, f'Autor: {tutorial.autor.username}')\n    y -= 20\n    p.drawString(40, y, f'Data: {tutorial.data_criacao.strftime(\"%d/%m/%Y %H:%M\")}')\n    y -= 30\n    p.setFont('Helvetica', 12)\n    conteudo = tutorial.conteudo.replace('\\r', '').split('\\n')\n    for linha in conteudo:\n        if y < 60:\n            p.showPage()\n            y = height - 40\n            p.setFont('Helvetica', 12)\n        p.drawString(40, y, linha[:110])\n        y -= 18\n    p.showPage()\n    p.save()\n    buffer.seek(0)\n    return send_file(buffer, as_attachment=True, download_name=f'tutorial_{tutorial.id}.pdf', mimetype='application/pdf')\n\n\n# ========================================\n# ROTAS PARA CONTROLE DE EQUIPAMENTOS\n# ========================================\n\n@bp.route('/equipment/list')\n@login_required\ndef list_equipment():\n    \"\"\"Lista todas as solicita√ß√µes de equipamentos\"\"\"\n    # Filtros\n    status_filter = request.args.get('status', '')\n    search = request.args.get('search', '').strip()\n\n    # Query base\n    if session.get('is_admin') or session.get('is_ti'):\n        # TI/Admin v√™ todas as solicita√ß√µes\n        query = EquipmentRequest.query\n    else:\n        # Usu√°rio comum v√™ apenas suas solicita√ß√µes\n        query = EquipmentRequest.query.filter_by(requester_id=session.get('user_id'))\n\n    # Aplicar filtros\n    if status_filter:\n        query = query.filter(EquipmentRequest.status == status_filter)\n\n    if search:\n        query = query.filter(\n            db.or_(\n                EquipmentRequest.description.contains(search),\n                EquipmentRequest.patrimony.contains(search),\n                EquipmentRequest.equipment_type.contains(search)\n            )\n        )\n\n    # Ordenar por data de solicita√ß√£o (mais recente primeiro)\n    equipment_requests = query.order_by(EquipmentRequest.request_date.desc()).all()\n\n    return render_template('equipment_list.html',\n                         equipment_requests=equipment_requests,\n                         status_filter=status_filter,\n                         search=search)\n\n\n@bp.route('/equipment/new', methods=['GET', 'POST'])\n@login_required\ndef new_equipment_request():\n    \"\"\"Nova solicita√ß√£o de equipamento\"\"\"\n    if request.method == 'POST':\n        # Validar dados\n        description = request.form.get('description', '').strip()\n        patrimony = request.form.get('patrimony', '').strip()\n        equipment_type = request.form.get('equipment_type', '').strip()\n        destination_sector = request.form.get('destination_sector', '').strip()\n        request_reason = request.form.get('request_reason', '').strip()\n        delivery_date_str = request.form.get('delivery_date', '').strip()\n        observations = request.form.get('observations', '').strip()\n\n        if not description:\n            flash('Descri√ß√£o √© obrigat√≥ria.', 'danger')\n            return render_template('equipment_form.html')\n\n        if not request_reason:\n            flash('Motivo da solicita√ß√£o √© obrigat√≥rio.', 'danger')\n            return render_template('equipment_form.html')\n\n        if not destination_sector:\n            flash('Setor/Destino √© obrigat√≥rio.', 'danger')\n            return render_template('equipment_form.html')\n\n        # Converter data se fornecida\n        delivery_date = None\n        if delivery_date_str:\n            try:\n                delivery_date = datetime.strptime(delivery_date_str, '%Y-%m-%d').date()\n            except ValueError:\n                flash('Data de entrega inv√°lida.', 'danger')\n                return render_template('equipment_form.html')\n\n        # Criar solicita√ß√£o\n        equipment_request = EquipmentRequest(\n            description=description,\n            patrimony=patrimony if patrimony else None,\n            equipment_type=equipment_type if equipment_type else None,\n            destination_sector=destination_sector if destination_sector else None,\n            request_reason=request_reason if request_reason else None,\n            delivery_date=delivery_date,\n            observations=observations if observations else None,\n            requester_id=session.get('user_id'),\n            status='Solicitado'\n        )\n\n        db.session.add(equipment_request)\n        db.session.commit()\n\n        flash('Solicita√ß√£o de equipamento criada com sucesso!', 'success')\n        return redirect(url_for('main.list_equipment'))\n\n    return render_template('equipment_form.html')\n\n\n@bp.route('/equipment/<int:id>')\n@login_required\ndef equipment_detail(id):\n    \"\"\"Detalhes de uma solicita√ß√£o de equipamento\"\"\"\n    equipment_request = EquipmentRequest.query.get_or_404(id)\n\n    # Verificar permiss√£o\n    if not (session.get('is_admin') or session.get('is_ti') or\n            equipment_request.requester_id == session.get('user_id')):\n        flash('Voc√™ n√£o tem permiss√£o para ver esta solicita√ß√£o.', 'danger')\n        return redirect(url_for('main.list_equipment'))\n\n    return render_template('equipment_detail.html', equipment_request=equipment_request)\n\n\n@bp.route('/equipment/<int:id>/edit', methods=['GET', 'POST'])\n@login_required\ndef edit_equipment_request(id):\n    \"\"\"Editar solicita√ß√£o de equipamento\"\"\"\n    equipment_request = EquipmentRequest.query.get_or_404(id)\n\n    # Verificar permiss√£o\n    if not equipment_request.can_be_edited_by(User.query.get(session.get('user_id'))):\n        flash('Voc√™ n√£o tem permiss√£o para editar esta solicita√ß√£o.', 'danger')\n        return redirect(url_for('main.equipment_detail', id=id))\n\n    if request.method == 'POST':\n        # Validar dados\n        description = request.form.get('description', '').strip()\n        patrimony = request.form.get('patrimony', '').strip()\n        equipment_type = request.form.get('equipment_type', '').strip()\n        destination_sector = request.form.get('destination_sector', '').strip()\n        request_reason = request.form.get('request_reason', '').strip()\n        delivery_date_str = request.form.get('delivery_date', '').strip()\n        observations = request.form.get('observations', '').strip()\n\n        if not description:\n            flash('Descri√ß√£o √© obrigat√≥ria.', 'danger')\n            return render_template('equipment_form.html', equipment_request=equipment_request)\n\n        if not request_reason:\n            flash('Motivo da solicita√ß√£o √© obrigat√≥rio.', 'danger')\n            return render_template('equipment_form.html', equipment_request=equipment_request)\n\n        if not destination_sector:\n            flash('Setor/Destino √© obrigat√≥rio.', 'danger')\n            return render_template('equipment_form.html', equipment_request=equipment_request)\n\n        # Converter data se fornecida\n        delivery_date = None\n        if delivery_date_str:\n            try:\n                delivery_date = datetime.strptime(delivery_date_str, '%Y-%m-%d').date()\n            except ValueError:\n                flash('Data de entrega inv√°lida.', 'danger')\n                return render_template('equipment_form.html', equipment_request=equipment_request)\n\n        # Atualizar dados\n        equipment_request.description = description\n        equipment_request.patrimony = patrimony if patrimony else None\n        equipment_request.equipment_type = equipment_type if equipment_type else None\n        equipment_request.destination_sector = destination_sector if destination_sector else None\n        equipment_request.request_reason = request_reason if request_reason else None\n        equipment_request.delivery_date = delivery_date\n        equipment_request.observations = observations if observations else None\n\n        db.session.commit()\n\n        flash('Solicita√ß√£o atualizada com sucesso!', 'success')\n        return redirect(url_for('main.equipment_detail', id=id))\n\n    return render_template('equipment_form.html', equipment_request=equipment_request)\n\n\n@bp.route('/equipment/<int:id>/approve', methods=['POST'])\n@login_required\ndef approve_equipment_request(id):\n    \"\"\"Aprovar solicita√ß√£o de equipamento (TI/Admin)\"\"\"\n    equipment_request = EquipmentRequest.query.get_or_404(id)\n\n    # Verificar permiss√£o\n    if not equipment_request.can_be_approved_by(User.query.get(session.get('user_id'))):\n        flash('Voc√™ n√£o tem permiss√£o para aprovar solicita√ß√µes.', 'danger')\n        return redirect(url_for('main.equipment_detail', id=id))\n\n    if equipment_request.status != 'Solicitado':\n        flash('Apenas solicita√ß√µes pendentes podem ser aprovadas.', 'danger')\n        return redirect(url_for('main.equipment_detail', id=id))\n\n    # Aprovar solicita√ß√£o\n    equipment_request.status = 'Aprovado'\n    equipment_request.approved_by_id = session.get('user_id')\n    equipment_request.approval_date = datetime.utcnow()\n\n    db.session.commit()\n\n    flash('Solicita√ß√£o aprovada com sucesso!', 'success')\n    return redirect(url_for('main.equipment_detail', id=id))\n\n\n@bp.route('/equipment/<int:id>/reject', methods=['POST'])\n@login_required\ndef reject_equipment_request(id):\n    \"\"\"Recusar solicita√ß√£o de equipamento (TI/Admin)\"\"\"\n    equipment_request = EquipmentRequest.query.get_or_404(id)\n\n    # Verificar permiss√£o\n    if not equipment_request.can_be_approved_by(User.query.get(session.get('user_id'))):\n        flash('Voc√™ n√£o tem permiss√£o para recusar solicita√ß√µes.', 'danger')\n        return redirect(url_for('main.equipment_detail', id=id))\n\n    if equipment_request.status != 'Solicitado':\n        flash('Apenas solicita√ß√µes pendentes podem ser recusadas.', 'danger')\n        return redirect(url_for('main.equipment_detail', id=id))\n\n    # Recusar solicita√ß√£o\n    equipment_request.status = 'Negado'\n    equipment_request.approved_by_id = session.get('user_id')\n    equipment_request.approval_date = datetime.utcnow()\n\n    db.session.commit()\n\n    flash('Solicita√ß√£o recusada.', 'warning')\n    return redirect(url_for('main.equipment_detail', id=id))\n\n\n@bp.route('/equipment/<int:id>/deliver', methods=['POST'])\n@login_required\ndef deliver_equipment_request(id):\n    \"\"\"Marcar equipamento como entregue (TI/Admin)\"\"\"\n    equipment_request = EquipmentRequest.query.get_or_404(id)\n\n    # Verificar permiss√£o\n    if not equipment_request.can_be_approved_by(User.query.get(session.get('user_id'))):\n        flash('Voc√™ n√£o tem permiss√£o para marcar como entregue.', 'danger')\n        return redirect(url_for('main.equipment_detail', id=id))\n\n    if equipment_request.status != 'Aprovado':\n        flash('Apenas solicita√ß√µes aprovadas podem ser marcadas como entregues.', 'danger')\n        return redirect(url_for('main.equipment_detail', id=id))\n\n    # Marcar como entregue\n    equipment_request.status = 'Entregue'\n    equipment_request.received_by_id = session.get('user_id')\n    equipment_request.delivery_date = datetime.utcnow().date()\n\n    db.session.commit()\n\n    flash('Equipamento marcado como entregue!', 'success')\n    return redirect(url_for('main.equipment_detail', id=id))\n\n\n@bp.route('/equipment/<int:id>/return', methods=['POST'])\n@login_required\ndef return_equipment_request(id):\n    \"\"\"Marcar equipamento como devolvido (TI/Admin)\"\"\"\n    equipment_request = EquipmentRequest.query.get_or_404(id)\n\n    # Verificar permiss√£o\n    if not equipment_request.can_be_approved_by(User.query.get(session.get('user_id'))):\n        flash('Voc√™ n√£o tem permiss√£o para marcar como devolvido.', 'danger')\n        return redirect(url_for('main.equipment_detail', id=id))\n\n    if equipment_request.status != 'Entregue':\n        flash('Apenas equipamentos entregues podem ser marcados como devolvidos.', 'danger')\n        return redirect(url_for('main.equipment_detail', id=id))\n\n    # Marcar como devolvido\n    equipment_request.status = 'Devolvido'\n    equipment_request.return_date = datetime.utcnow().date()\n\n    db.session.commit()\n\n    flash('Equipamento marcado como devolvido!', 'success')\n    return redirect(url_for('main.equipment_detail', id=id))\n\n\n@bp.route('/equipment/<int:id>/fill_technical', methods=['GET', 'POST'])\n@login_required\ndef fill_technical_data(id):\n    \"\"\"Preencher dados t√©cnicos do equipamento (TI/Admin)\"\"\"\n    equipment_request = EquipmentRequest.query.get_or_404(id)\n\n    # Verificar permiss√£o\n    if not equipment_request.can_be_approved_by(User.query.get(session.get('user_id'))):\n        flash('Voc√™ n√£o tem permiss√£o para preencher dados t√©cnicos.', 'danger')\n        return redirect(url_for('main.equipment_detail', id=id))\n\n    if request.method == 'POST':\n        # Validar dados\n        patrimony = request.form.get('patrimony', '').strip()\n        equipment_type = request.form.get('equipment_type', '').strip()\n        delivery_date_str = request.form.get('delivery_date', '').strip()\n        conference_status = request.form.get('conference_status', '').strip()\n\n        # Atualizar dados t√©cnicos\n        equipment_request.patrimony = patrimony if patrimony else None\n        equipment_request.equipment_type = equipment_type if equipment_type else None\n        equipment_request.conference_status = conference_status if conference_status else None\n\n        # Converter data se fornecida\n        if delivery_date_str:\n            try:\n                equipment_request.delivery_date = datetime.strptime(delivery_date_str, '%Y-%m-%d').date()\n            except ValueError:\n                flash('Data de entrega inv√°lida.', 'danger')\n                return render_template('equipment_technical_form.html', equipment_request=equipment_request)\n\n        db.session.commit()\n\n        flash('Dados t√©cnicos atualizados com sucesso!', 'success')\n        return redirect(url_for('main.equipment_detail', id=id))\n\n    return render_template('equipment_technical_form.html', equipment_request=equipment_request)\n\n\n\n\n@bp.route('/install-pwa')\ndef install_pwa():\n    \"\"\"P√°gina de instru√ß√µes para instala√ß√£o PWA\"\"\"\n    return render_template('install_pwa.html')\n\n@bp.route('/offline')\ndef offline():\n    \"\"\"P√°gina offline\"\"\"\n    return render_template('offline.html')\n\n@bp.route('/test-notification')\n@login_required\ndef test_notification():\n    \"\"\"Endpoint para testar notifica√ß√µes\"\"\"\n    return jsonify({\n        'reminders_expiring': [{\n            'id': 999,\n            'name': 'Teste de Notifica√ß√£o',\n            'responsible': 'Sistema',\n            'days_left': 1\n        }],\n        'chamados_updated': [],\n        'tasks_overdue': []\n    })\n\n@bp.route('/api/notifications')\ndef api_notifications():\n    \"\"\"Endpoint para API de notifica√ß√µes usado pelo notifications.js\"\"\"\n    # Verificar se o usu√°rio est√° autenticado\n    if 'user_id' not in session:\n        return jsonify({\n            'error': 'N√£o autenticado',\n            'reminders_expiring': [],\n            'chamados_updated': [],\n            'tasks_overdue': []\n        }), 200  # Retornar c√≥digo 200 em vez de redirecionar\n        \n    # Verificar lembretes pr√≥ximos do vencimento (7 dias)\n    user_id = session.get('user_id')\n    today = date.today()\n    \n    # Lembretes vencendo em at√© 7 dias\n    if session.get('is_admin'):\n        reminders_expiring = Reminder.query.filter(\n            Reminder.due_date >= today,\n            Reminder.due_date <= today + timedelta(days=7),\n            Reminder.completed == False,\n            Reminder.status == 'ativo'\n        ).all()\n    else:\n        reminders_expiring = Reminder.query.filter(\n            Reminder.due_date >= today,\n            Reminder.due_date <= today + timedelta(days=7),\n            Reminder.completed == False,\n            Reminder.status == 'ativo',\n            Reminder.user_id == user_id\n        ).all()\n    \n    # Tarefas vencidas\n    if session.get('is_admin'):\n        tasks_overdue = Task.query.filter(\n            Task.date < today,\n            Task.completed == False\n        ).all()\n    else:\n        tasks_overdue = Task.query.filter(\n            Task.date < today,\n            Task.completed == False,\n            Task.user_id == user_id\n        ).all()\n    \n    # Chamados atualizados recentemente (√∫ltimas 24h)\n    yesterday = datetime.now() - timedelta(days=1)\n    \n    if session.get('is_admin') or session.get('is_ti'):\n        # Administradores e equipe de TI veem todos os chamados atualizados\n        chamados_updated = Chamado.query.filter(\n            Chamado.data_ultima_atualizacao >= yesterday,\n            Chamado.status != 'Fechado'\n        ).all()\n    else:\n        # Usu√°rios normais veem apenas seus pr√≥prios chamados atualizados\n        chamados_updated = Chamado.query.filter(\n            Chamado.data_ultima_atualizacao >= yesterday,\n            Chamado.solicitante_id == user_id,\n            Chamado.status != 'Fechado'\n        ).all()\n    \n    return jsonify({\n        'reminders_expiring': [{\n            'id': r.id,\n            'name': r.name,\n            'responsible': r.responsible,\n            'days_left': (r.due_date - today).days\n        } for r in reminders_expiring],\n        'chamados_updated': [{\n            'id': c.id,\n            'titulo': c.titulo,\n            'status': c.status,\n            'prioridade': c.prioridade,\n            'solicitante': c.solicitante.username if c.solicitante else 'Desconhecido'\n        } for c in chamados_updated],\n        'tasks_overdue': [{\n            'id': t.id,\n            'name': t.description,\n            'days_overdue': (today - t.date).days\n        } for t in tasks_overdue]\n    })\n","size_bytes":113189},"markdown/__init__.py":{"content":"# Python Markdown\n\n# A Python implementation of John Gruber's Markdown.\n\n# - Documentation: https://python-markdown.github.io/\n# - GitHub: https://github.com/Python-Markdown/markdown/\n# - PyPI: https://pypi.org/project/Markdown/\n\n# Started by Manfred Stienstra (http://www.dwerg.net/).\n# Maintained for a few years by Yuri Takhteyev (http://www.freewisdom.org).\n# Currently maintained by Waylan Limberg (https://github.com/waylan),\n# Dmitry Shachnev (https://github.com/mitya57) and Isaac Muse (https://github.com/facelessuser).\n\n# - Copyright 2007-2023 The Python Markdown Project (v. 1.7 and later)\n# - Copyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b)\n# - Copyright 2004 Manfred Stienstra (the original version)\n\n# License: BSD (see LICENSE.md for details).\n\n\"\"\"\nPython-Markdown provides two public functions ([`markdown.markdown`][] and [`markdown.markdownFromFile`][])\nboth of which wrap the public class [`markdown.Markdown`][]. All submodules support these public functions\nand class and/or provide extension support.\n\nModules:\n    core: Core functionality.\n    preprocessors: Pre-processors.\n    blockparser: Core Markdown block parser.\n    blockprocessors: Block processors.\n    treeprocessors: Tree processors.\n    inlinepatterns: Inline patterns.\n    postprocessors: Post-processors.\n    serializers: Serializers.\n    util: Utility functions.\n    htmlparser: HTML parser.\n    test_tools: Testing utilities.\n    extensions: Markdown extensions.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom .core import Markdown, markdown, markdownFromFile\nfrom .__meta__ import __version__, __version_info__  # noqa\n\n# For backward compatibility as some extensions expect it...\nfrom .extensions import Extension  # noqa\n\n__all__ = ['Markdown', 'markdown', 'markdownFromFile']\n","size_bytes":1777},"markdown/__main__.py":{"content":"# Python Markdown\n\n# A Python implementation of John Gruber's Markdown.\n\n# Documentation: https://python-markdown.github.io/\n# GitHub: https://github.com/Python-Markdown/markdown/\n# PyPI: https://pypi.org/project/Markdown/\n\n# Started by Manfred Stienstra (http://www.dwerg.net/).\n# Maintained for a few years by Yuri Takhteyev (http://www.freewisdom.org).\n# Currently maintained by Waylan Limberg (https://github.com/waylan),\n# Dmitry Shachnev (https://github.com/mitya57) and Isaac Muse (https://github.com/facelessuser).\n\n# Copyright 2007-2023 The Python Markdown Project (v. 1.7 and later)\n# Copyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b)\n# Copyright 2004 Manfred Stienstra (the original version)\n\n# License: BSD (see LICENSE.md for details).\n\nfrom __future__ import annotations\n\nimport sys\nimport optparse\nimport warnings\nimport markdown\ntry:\n    # We use `unsafe_load` because users may need to pass in actual Python\n    # objects. As this is only available from the CLI, the user has much\n    # worse problems if an attacker can use this as an attach vector.\n    from yaml import unsafe_load as yaml_load\nexcept ImportError:  # pragma: no cover\n    try:\n        # Fall back to PyYAML <5.1\n        from yaml import load as yaml_load\n    except ImportError:\n        # Fall back to JSON\n        from json import load as yaml_load\n\nimport logging\nfrom logging import DEBUG, WARNING, CRITICAL\n\nlogger = logging.getLogger('MARKDOWN')\n\n\ndef parse_options(args=None, values=None):\n    \"\"\"\n    Define and parse `optparse` options for command-line usage.\n    \"\"\"\n    usage = \"\"\"%prog [options] [INPUTFILE]\n       (STDIN is assumed if no INPUTFILE is given)\"\"\"\n    desc = \"A Python implementation of John Gruber's Markdown. \" \\\n           \"https://Python-Markdown.github.io/\"\n    ver = \"%%prog %s\" % markdown.__version__\n\n    parser = optparse.OptionParser(usage=usage, description=desc, version=ver)\n    parser.add_option(\"-f\", \"--file\", dest=\"filename\", default=None,\n                      help=\"Write output to OUTPUT_FILE. Defaults to STDOUT.\",\n                      metavar=\"OUTPUT_FILE\")\n    parser.add_option(\"-e\", \"--encoding\", dest=\"encoding\",\n                      help=\"Encoding for input and output files.\",)\n    parser.add_option(\"-o\", \"--output_format\", dest=\"output_format\",\n                      default='xhtml', metavar=\"OUTPUT_FORMAT\",\n                      help=\"Use output format 'xhtml' (default) or 'html'.\")\n    parser.add_option(\"-n\", \"--no_lazy_ol\", dest=\"lazy_ol\",\n                      action='store_false', default=True,\n                      help=\"Observe number of first item of ordered lists.\")\n    parser.add_option(\"-x\", \"--extension\", action=\"append\", dest=\"extensions\",\n                      help=\"Load extension EXTENSION.\", metavar=\"EXTENSION\")\n    parser.add_option(\"-c\", \"--extension_configs\",\n                      dest=\"configfile\", default=None,\n                      help=\"Read extension configurations from CONFIG_FILE. \"\n                      \"CONFIG_FILE must be of JSON or YAML format. YAML \"\n                      \"format requires that a python YAML library be \"\n                      \"installed. The parsed JSON or YAML must result in a \"\n                      \"python dictionary which would be accepted by the \"\n                      \"'extension_configs' keyword on the markdown.Markdown \"\n                      \"class. The extensions must also be loaded with the \"\n                      \"`--extension` option.\",\n                      metavar=\"CONFIG_FILE\")\n    parser.add_option(\"-q\", \"--quiet\", default=CRITICAL,\n                      action=\"store_const\", const=CRITICAL+10, dest=\"verbose\",\n                      help=\"Suppress all warnings.\")\n    parser.add_option(\"-v\", \"--verbose\",\n                      action=\"store_const\", const=WARNING, dest=\"verbose\",\n                      help=\"Print all warnings.\")\n    parser.add_option(\"--noisy\",\n                      action=\"store_const\", const=DEBUG, dest=\"verbose\",\n                      help=\"Print debug messages.\")\n\n    (options, args) = parser.parse_args(args, values)\n\n    if len(args) == 0:\n        input_file = None\n    else:\n        input_file = args[0]\n\n    if not options.extensions:\n        options.extensions = []\n\n    extension_configs = {}\n    if options.configfile:\n        with open(\n            options.configfile, mode=\"r\", encoding=options.encoding\n        ) as fp:\n            try:\n                extension_configs = yaml_load(fp)\n            except Exception as e:\n                message = \"Failed parsing extension config file: %s\" % \\\n                          options.configfile\n                e.args = (message,) + e.args[1:]\n                raise\n\n    opts = {\n        'input': input_file,\n        'output': options.filename,\n        'extensions': options.extensions,\n        'extension_configs': extension_configs,\n        'encoding': options.encoding,\n        'output_format': options.output_format,\n        'lazy_ol': options.lazy_ol\n    }\n\n    return opts, options.verbose\n\n\ndef run():  # pragma: no cover\n    \"\"\"Run Markdown from the command line.\"\"\"\n\n    # Parse options and adjust logging level if necessary\n    options, logging_level = parse_options()\n    if not options:\n        sys.exit(2)\n    logger.setLevel(logging_level)\n    console_handler = logging.StreamHandler()\n    logger.addHandler(console_handler)\n    if logging_level <= WARNING:\n        # Ensure deprecation warnings get displayed\n        warnings.filterwarnings('default')\n        logging.captureWarnings(True)\n        warn_logger = logging.getLogger('py.warnings')\n        warn_logger.addHandler(console_handler)\n\n    # Run\n    markdown.markdownFromFile(**options)\n\n\nif __name__ == '__main__':  # pragma: no cover\n    # Support running module as a command line command.\n    #     python -m markdown [options] [args]\n    run()\n","size_bytes":5838},"markdown/__meta__.py":{"content":"# Python Markdown\n\n# A Python implementation of John Gruber's Markdown.\n\n# Documentation: https://python-markdown.github.io/\n# GitHub: https://github.com/Python-Markdown/markdown/\n# PyPI: https://pypi.org/project/Markdown/\n\n# Started by Manfred Stienstra (http://www.dwerg.net/).\n# Maintained for a few years by Yuri Takhteyev (http://www.freewisdom.org).\n# Currently maintained by Waylan Limberg (https://github.com/waylan),\n# Dmitry Shachnev (https://github.com/mitya57) and Isaac Muse (https://github.com/facelessuser).\n\n# Copyright 2007-2023 The Python Markdown Project (v. 1.7 and later)\n# Copyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b)\n# Copyright 2004 Manfred Stienstra (the original version)\n\n# License: BSD (see LICENSE.md for details).\n\n# __version_info__ format:\n#     (major, minor, patch, dev/alpha/beta/rc/final, #)\n#     (1, 1, 2, 'dev', 0) => \"1.1.2.dev0\"\n#     (1, 1, 2, 'alpha', 1) => \"1.1.2a1\"\n#     (1, 2, 0, 'beta', 2) => \"1.2b2\"\n#     (1, 2, 0, 'rc', 4) => \"1.2rc4\"\n#     (1, 2, 0, 'final', 0) => \"1.2\"\n\nfrom __future__ import annotations\n\n\n__version_info__ = (3, 8, 2, 'final', 0)\n\n\ndef _get_version(version_info):\n    \" Returns a PEP 440-compliant version number from `version_info`. \"\n    assert len(version_info) == 5\n    assert version_info[3] in ('dev', 'alpha', 'beta', 'rc', 'final')\n\n    parts = 2 if version_info[2] == 0 else 3\n    v = '.'.join(map(str, version_info[:parts]))\n\n    if version_info[3] == 'dev':\n        v += '.dev' + str(version_info[4])\n    elif version_info[3] != 'final':\n        mapping = {'alpha': 'a', 'beta': 'b', 'rc': 'rc'}\n        v += mapping[version_info[3]] + str(version_info[4])\n\n    return v\n\n\n__version__ = _get_version(__version_info__)\n","size_bytes":1712},"markdown/blockparser.py":{"content":"# Python Markdown\n\n# A Python implementation of John Gruber's Markdown.\n\n# Documentation: https://python-markdown.github.io/\n# GitHub: https://github.com/Python-Markdown/markdown/\n# PyPI: https://pypi.org/project/Markdown/\n\n# Started by Manfred Stienstra (http://www.dwerg.net/).\n# Maintained for a few years by Yuri Takhteyev (http://www.freewisdom.org).\n# Currently maintained by Waylan Limberg (https://github.com/waylan),\n# Dmitry Shachnev (https://github.com/mitya57) and Isaac Muse (https://github.com/facelessuser).\n\n# Copyright 2007-2023 The Python Markdown Project (v. 1.7 and later)\n# Copyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b)\n# Copyright 2004 Manfred Stienstra (the original version)\n\n# License: BSD (see LICENSE.md for details).\n\n\"\"\"\nThe block parser handles basic parsing of Markdown blocks.  It doesn't concern\nitself with inline elements such as `**bold**` or `*italics*`, but rather just\ncatches blocks, lists, quotes, etc.\n\nThe `BlockParser` is made up of a bunch of `BlockProcessors`, each handling a\ndifferent type of block. Extensions may add/replace/remove `BlockProcessors`\nas they need to alter how Markdown blocks are parsed.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport xml.etree.ElementTree as etree\nfrom typing import TYPE_CHECKING, Iterable, Any\nfrom . import util\n\nif TYPE_CHECKING:  # pragma: no cover\n    from markdown import Markdown\n    from .blockprocessors import BlockProcessor\n\n\nclass State(list):\n    \"\"\" Track the current and nested state of the parser.\n\n    This utility class is used to track the state of the `BlockParser` and\n    support multiple levels if nesting. It's just a simple API wrapped around\n    a list. Each time a state is set, that state is appended to the end of the\n    list. Each time a state is reset, that state is removed from the end of\n    the list.\n\n    Therefore, each time a state is set for a nested block, that state must be\n    reset when we back out of that level of nesting or the state could be\n    corrupted.\n\n    While all the methods of a list object are available, only the three\n    defined below need be used.\n\n    \"\"\"\n\n    def set(self, state: Any):\n        \"\"\" Set a new state. \"\"\"\n        self.append(state)\n\n    def reset(self) -> None:\n        \"\"\" Step back one step in nested state. \"\"\"\n        self.pop()\n\n    def isstate(self, state: Any) -> bool:\n        \"\"\" Test that top (current) level is of given state. \"\"\"\n        if len(self):\n            return self[-1] == state\n        else:\n            return False\n\n\nclass BlockParser:\n    \"\"\" Parse Markdown blocks into an `ElementTree` object.\n\n    A wrapper class that stitches the various `BlockProcessors` together,\n    looping through them and creating an `ElementTree` object.\n\n    \"\"\"\n\n    def __init__(self, md: Markdown):\n        \"\"\" Initialize the block parser.\n\n        Arguments:\n            md: A Markdown instance.\n\n        Attributes:\n            BlockParser.md (Markdown): A Markdown instance.\n            BlockParser.state (State): Tracks the nesting level of current location in document being parsed.\n            BlockParser.blockprocessors (util.Registry): A collection of\n                [`blockprocessors`][markdown.blockprocessors].\n\n        \"\"\"\n        self.blockprocessors: util.Registry[BlockProcessor] = util.Registry()\n        self.state = State()\n        self.md = md\n\n    def parseDocument(self, lines: Iterable[str]) -> etree.ElementTree:\n        \"\"\" Parse a Markdown document into an `ElementTree`.\n\n        Given a list of lines, an `ElementTree` object (not just a parent\n        `Element`) is created and the root element is passed to the parser\n        as the parent. The `ElementTree` object is returned.\n\n        This should only be called on an entire document, not pieces.\n\n        Arguments:\n            lines: A list of lines (strings).\n\n        Returns:\n            An element tree.\n        \"\"\"\n        # Create an `ElementTree` from the lines\n        self.root = etree.Element(self.md.doc_tag)\n        self.parseChunk(self.root, '\\n'.join(lines))\n        return etree.ElementTree(self.root)\n\n    def parseChunk(self, parent: etree.Element, text: str) -> None:\n        \"\"\" Parse a chunk of Markdown text and attach to given `etree` node.\n\n        While the `text` argument is generally assumed to contain multiple\n        blocks which will be split on blank lines, it could contain only one\n        block. Generally, this method would be called by extensions when\n        block parsing is required.\n\n        The `parent` `etree` Element passed in is altered in place.\n        Nothing is returned.\n\n        Arguments:\n            parent: The parent element.\n            text: The text to parse.\n\n        \"\"\"\n        self.parseBlocks(parent, text.split('\\n\\n'))\n\n    def parseBlocks(self, parent: etree.Element, blocks: list[str]) -> None:\n        \"\"\" Process blocks of Markdown text and attach to given `etree` node.\n\n        Given a list of `blocks`, each `blockprocessor` is stepped through\n        until there are no blocks left. While an extension could potentially\n        call this method directly, it's generally expected to be used\n        internally.\n\n        This is a public method as an extension may need to add/alter\n        additional `BlockProcessors` which call this method to recursively\n        parse a nested block.\n\n        Arguments:\n            parent: The parent element.\n            blocks: The blocks of text to parse.\n\n        \"\"\"\n        while blocks:\n            for processor in self.blockprocessors:\n                if processor.test(parent, blocks[0]):\n                    if processor.run(parent, blocks) is not False:\n                        # run returns True or None\n                        break\n","size_bytes":5728},"markdown/blockprocessors.py":{"content":"# Python Markdown\n\n# A Python implementation of John Gruber's Markdown.\n\n# Documentation: https://python-markdown.github.io/\n# GitHub: https://github.com/Python-Markdown/markdown/\n# PyPI: https://pypi.org/project/Markdown/\n\n# Started by Manfred Stienstra (http://www.dwerg.net/).\n# Maintained for a few years by Yuri Takhteyev (http://www.freewisdom.org).\n# Currently maintained by Waylan Limberg (https://github.com/waylan),\n# Dmitry Shachnev (https://github.com/mitya57) and Isaac Muse (https://github.com/facelessuser).\n\n# Copyright 2007-2023 The Python Markdown Project (v. 1.7 and later)\n# Copyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b)\n# Copyright 2004 Manfred Stienstra (the original version)\n\n# License: BSD (see LICENSE.md for details).\n\n\"\"\"\nA block processor parses blocks of text and adds new elements to the ElementTree. Blocks of text,\nseparated from other text by blank lines, may have a different syntax and produce a differently\nstructured tree than other Markdown. Block processors excel at handling code formatting, equation\nlayouts, tables, etc.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport logging\nimport re\nimport xml.etree.ElementTree as etree\nfrom typing import TYPE_CHECKING, Any\nfrom . import util\nfrom .blockparser import BlockParser\n\nif TYPE_CHECKING:  # pragma: no cover\n    from markdown import Markdown\n\nlogger = logging.getLogger('MARKDOWN')\n\n\ndef build_block_parser(md: Markdown, **kwargs: Any) -> BlockParser:\n    \"\"\" Build the default block parser used by Markdown. \"\"\"\n    parser = BlockParser(md)\n    parser.blockprocessors.register(EmptyBlockProcessor(parser), 'empty', 100)\n    parser.blockprocessors.register(ListIndentProcessor(parser), 'indent', 90)\n    parser.blockprocessors.register(CodeBlockProcessor(parser), 'code', 80)\n    parser.blockprocessors.register(HashHeaderProcessor(parser), 'hashheader', 70)\n    parser.blockprocessors.register(SetextHeaderProcessor(parser), 'setextheader', 60)\n    parser.blockprocessors.register(HRProcessor(parser), 'hr', 50)\n    parser.blockprocessors.register(OListProcessor(parser), 'olist', 40)\n    parser.blockprocessors.register(UListProcessor(parser), 'ulist', 30)\n    parser.blockprocessors.register(BlockQuoteProcessor(parser), 'quote', 20)\n    parser.blockprocessors.register(ReferenceProcessor(parser), 'reference', 15)\n    parser.blockprocessors.register(ParagraphProcessor(parser), 'paragraph', 10)\n    return parser\n\n\nclass BlockProcessor:\n    \"\"\" Base class for block processors.\n\n    Each subclass will provide the methods below to work with the source and\n    tree. Each processor will need to define it's own `test` and `run`\n    methods. The `test` method should return True or False, to indicate\n    whether the current block should be processed by this processor. If the\n    test passes, the parser will call the processors `run` method.\n\n    Attributes:\n        BlockProcessor.parser (BlockParser): The `BlockParser` instance this is attached to.\n        BlockProcessor.tab_length (int): The tab length set on the `Markdown` instance.\n\n    \"\"\"\n\n    def __init__(self, parser: BlockParser):\n        self.parser = parser\n        self.tab_length = parser.md.tab_length\n\n    def lastChild(self, parent: etree.Element) -> etree.Element | None:\n        \"\"\" Return the last child of an `etree` element. \"\"\"\n        if len(parent):\n            return parent[-1]\n        else:\n            return None\n\n    def detab(self, text: str, length: int | None = None) -> tuple[str, str]:\n        \"\"\" Remove a tab from the front of each line of the given text. \"\"\"\n        if length is None:\n            length = self.tab_length\n        newtext = []\n        lines = text.split('\\n')\n        for line in lines:\n            if line.startswith(' ' * length):\n                newtext.append(line[length:])\n            elif not line.strip():\n                newtext.append('')\n            else:\n                break\n        return '\\n'.join(newtext), '\\n'.join(lines[len(newtext):])\n\n    def looseDetab(self, text: str, level: int = 1) -> str:\n        \"\"\" Remove a tab from front of lines but allowing dedented lines. \"\"\"\n        lines = text.split('\\n')\n        for i in range(len(lines)):\n            if lines[i].startswith(' '*self.tab_length*level):\n                lines[i] = lines[i][self.tab_length*level:]\n        return '\\n'.join(lines)\n\n    def test(self, parent: etree.Element, block: str) -> bool:\n        \"\"\" Test for block type. Must be overridden by subclasses.\n\n        As the parser loops through processors, it will call the `test`\n        method on each to determine if the given block of text is of that\n        type. This method must return a boolean `True` or `False`. The\n        actual method of testing is left to the needs of that particular\n        block type. It could be as simple as `block.startswith(some_string)`\n        or a complex regular expression. As the block type may be different\n        depending on the parent of the block (i.e. inside a list), the parent\n        `etree` element is also provided and may be used as part of the test.\n\n        Keyword arguments:\n            parent: An `etree` element which will be the parent of the block.\n            block: A block of text from the source which has been split at blank lines.\n        \"\"\"\n        pass  # pragma: no cover\n\n    def run(self, parent: etree.Element, blocks: list[str]) -> bool | None:\n        \"\"\" Run processor. Must be overridden by subclasses.\n\n        When the parser determines the appropriate type of a block, the parser\n        will call the corresponding processor's `run` method. This method\n        should parse the individual lines of the block and append them to\n        the `etree`.\n\n        Note that both the `parent` and `etree` keywords are pointers\n        to instances of the objects which should be edited in place. Each\n        processor must make changes to the existing objects as there is no\n        mechanism to return new/different objects to replace them.\n\n        This means that this method should be adding `SubElements` or adding text\n        to the parent, and should remove (`pop`) or add (`insert`) items to\n        the list of blocks.\n\n        If `False` is returned, this will have the same effect as returning `False`\n        from the `test` method.\n\n        Keyword arguments:\n            parent: An `etree` element which is the parent of the current block.\n            blocks: A list of all remaining blocks of the document.\n        \"\"\"\n        pass  # pragma: no cover\n\n\nclass ListIndentProcessor(BlockProcessor):\n    \"\"\" Process children of list items.\n\n    Example\n\n        * a list item\n            process this part\n\n            or this part\n\n    \"\"\"\n\n    ITEM_TYPES = ['li']\n    \"\"\" List of tags used for list items. \"\"\"\n    LIST_TYPES = ['ul', 'ol']\n    \"\"\" Types of lists this processor can operate on. \"\"\"\n\n    def __init__(self, *args):\n        super().__init__(*args)\n        self.INDENT_RE = re.compile(r'^(([ ]{%s})+)' % self.tab_length)\n\n    def test(self, parent: etree.Element, block: str) -> bool:\n        return block.startswith(' '*self.tab_length) and \\\n            not self.parser.state.isstate('detabbed') and \\\n            (parent.tag in self.ITEM_TYPES or\n                (len(parent) and parent[-1] is not None and\n                    (parent[-1].tag in self.LIST_TYPES)))\n\n    def run(self, parent: etree.Element, blocks: list[str]) -> None:\n        block = blocks.pop(0)\n        level, sibling = self.get_level(parent, block)\n        block = self.looseDetab(block, level)\n\n        self.parser.state.set('detabbed')\n        if parent.tag in self.ITEM_TYPES:\n            # It's possible that this parent has a `ul` or `ol` child list\n            # with a member.  If that is the case, then that should be the\n            # parent.  This is intended to catch the edge case of an indented\n            # list whose first member was parsed previous to this point\n            # see `OListProcessor`\n            if len(parent) and parent[-1].tag in self.LIST_TYPES:\n                self.parser.parseBlocks(parent[-1], [block])\n            else:\n                # The parent is already a `li`. Just parse the child block.\n                self.parser.parseBlocks(parent, [block])\n        elif sibling.tag in self.ITEM_TYPES:\n            # The sibling is a `li`. Use it as parent.\n            self.parser.parseBlocks(sibling, [block])\n        elif len(sibling) and sibling[-1].tag in self.ITEM_TYPES:\n            # The parent is a list (`ol` or `ul`) which has children.\n            # Assume the last child `li` is the parent of this block.\n            if sibling[-1].text:\n                # If the parent `li` has text, that text needs to be moved to a `p`\n                # The `p` must be 'inserted' at beginning of list in the event\n                # that other children already exist i.e.; a nested sub-list.\n                p = etree.Element('p')\n                p.text = sibling[-1].text\n                sibling[-1].text = ''\n                sibling[-1].insert(0, p)\n            self.parser.parseChunk(sibling[-1], block)\n        else:\n            self.create_item(sibling, block)\n        self.parser.state.reset()\n\n    def create_item(self, parent: etree.Element, block: str) -> None:\n        \"\"\" Create a new `li` and parse the block with it as the parent. \"\"\"\n        li = etree.SubElement(parent, 'li')\n        self.parser.parseBlocks(li, [block])\n\n    def get_level(self, parent: etree.Element, block: str) -> tuple[int, etree.Element]:\n        \"\"\" Get level of indentation based on list level. \"\"\"\n        # Get indent level\n        m = self.INDENT_RE.match(block)\n        if m:\n            indent_level = len(m.group(1))/self.tab_length\n        else:\n            indent_level = 0\n        if self.parser.state.isstate('list'):\n            # We're in a tight-list - so we already are at correct parent.\n            level = 1\n        else:\n            # We're in a loose-list - so we need to find parent.\n            level = 0\n        # Step through children of tree to find matching indent level.\n        while indent_level > level:\n            child = self.lastChild(parent)\n            if (child is not None and\n               (child.tag in self.LIST_TYPES or child.tag in self.ITEM_TYPES)):\n                if child.tag in self.LIST_TYPES:\n                    level += 1\n                parent = child\n            else:\n                # No more child levels. If we're short of `indent_level`,\n                # we have a code block. So we stop here.\n                break\n        return level, parent\n\n\nclass CodeBlockProcessor(BlockProcessor):\n    \"\"\" Process code blocks. \"\"\"\n\n    def test(self, parent: etree.Element, block: str) -> bool:\n        return block.startswith(' '*self.tab_length)\n\n    def run(self, parent: etree.Element, blocks: list[str]) -> None:\n        sibling = self.lastChild(parent)\n        block = blocks.pop(0)\n        theRest = ''\n        if (sibling is not None and sibling.tag == \"pre\" and\n           len(sibling) and sibling[0].tag == \"code\"):\n            # The previous block was a code block. As blank lines do not start\n            # new code blocks, append this block to the previous, adding back\n            # line breaks removed from the split into a list.\n            code = sibling[0]\n            block, theRest = self.detab(block)\n            code.text = util.AtomicString(\n                '{}\\n{}\\n'.format(code.text, util.code_escape(block.rstrip()))\n            )\n        else:\n            # This is a new code block. Create the elements and insert text.\n            pre = etree.SubElement(parent, 'pre')\n            code = etree.SubElement(pre, 'code')\n            block, theRest = self.detab(block)\n            code.text = util.AtomicString('%s\\n' % util.code_escape(block.rstrip()))\n        if theRest:\n            # This block contained unindented line(s) after the first indented\n            # line. Insert these lines as the first block of the master blocks\n            # list for future processing.\n            blocks.insert(0, theRest)\n\n\nclass BlockQuoteProcessor(BlockProcessor):\n    \"\"\" Process blockquotes. \"\"\"\n\n    RE = re.compile(r'(^|\\n)[ ]{0,3}>[ ]?(.*)')\n\n    def test(self, parent: etree.Element, block: str) -> bool:\n        return bool(self.RE.search(block)) and not util.nearing_recursion_limit()\n\n    def run(self, parent: etree.Element, blocks: list[str]) -> None:\n        block = blocks.pop(0)\n        m = self.RE.search(block)\n        if m:\n            before = block[:m.start()]  # Lines before blockquote\n            # Pass lines before blockquote in recursively for parsing first.\n            self.parser.parseBlocks(parent, [before])\n            # Remove `> ` from beginning of each line.\n            block = '\\n'.join(\n                [self.clean(line) for line in block[m.start():].split('\\n')]\n            )\n        sibling = self.lastChild(parent)\n        if sibling is not None and sibling.tag == \"blockquote\":\n            # Previous block was a blockquote so set that as this blocks parent\n            quote = sibling\n        else:\n            # This is a new blockquote. Create a new parent element.\n            quote = etree.SubElement(parent, 'blockquote')\n        # Recursively parse block with blockquote as parent.\n        # change parser state so blockquotes embedded in lists use `p` tags\n        self.parser.state.set('blockquote')\n        self.parser.parseChunk(quote, block)\n        self.parser.state.reset()\n\n    def clean(self, line: str) -> str:\n        \"\"\" Remove `>` from beginning of a line. \"\"\"\n        m = self.RE.match(line)\n        if line.strip() == \">\":\n            return \"\"\n        elif m:\n            return m.group(2)\n        else:\n            return line\n\n\nclass OListProcessor(BlockProcessor):\n    \"\"\" Process ordered list blocks. \"\"\"\n\n    TAG: str = 'ol'\n    \"\"\" The tag used for the the wrapping element. \"\"\"\n    STARTSWITH: str = '1'\n    \"\"\"\n    The integer (as a string ) with which the list starts. For example, if a list is initialized as\n    `3. Item`, then the `ol` tag will be assigned an HTML attribute of `starts=\"3\"`. Default: `\"1\"`.\n    \"\"\"\n    LAZY_OL: bool = True\n    \"\"\" Ignore `STARTSWITH` if `True`. \"\"\"\n    SIBLING_TAGS: list[str] = ['ol', 'ul']\n    \"\"\"\n    Markdown does not require the type of a new list item match the previous list item type.\n    This is the list of types which can be mixed.\n    \"\"\"\n\n    def __init__(self, parser: BlockParser):\n        super().__init__(parser)\n        # Detect an item (`1. item`). `group(1)` contains contents of item.\n        self.RE = re.compile(r'^[ ]{0,%d}\\d+\\.[ ]+(.*)' % (self.tab_length - 1))\n        # Detect items on secondary lines. they can be of either list type.\n        self.CHILD_RE = re.compile(r'^[ ]{0,%d}((\\d+\\.)|[*+-])[ ]+(.*)' %\n                                   (self.tab_length - 1))\n        # Detect indented (nested) items of either type\n        self.INDENT_RE = re.compile(r'^[ ]{%d,%d}((\\d+\\.)|[*+-])[ ]+.*' %\n                                    (self.tab_length, self.tab_length * 2 - 1))\n\n    def test(self, parent: etree.Element, block: str) -> bool:\n        return bool(self.RE.match(block))\n\n    def run(self, parent: etree.Element, blocks: list[str]) -> None:\n        # Check for multiple items in one block.\n        items = self.get_items(blocks.pop(0))\n        sibling = self.lastChild(parent)\n\n        if sibling is not None and sibling.tag in self.SIBLING_TAGS:\n            # Previous block was a list item, so set that as parent\n            lst = sibling\n            # make sure previous item is in a `p` - if the item has text,\n            # then it isn't in a `p`\n            if lst[-1].text:\n                # since it's possible there are other children for this\n                # sibling, we can't just `SubElement` the `p`, we need to\n                # insert it as the first item.\n                p = etree.Element('p')\n                p.text = lst[-1].text\n                lst[-1].text = ''\n                lst[-1].insert(0, p)\n            # if the last item has a tail, then the tail needs to be put in a `p`\n            # likely only when a header is not followed by a blank line\n            lch = self.lastChild(lst[-1])\n            if lch is not None and lch.tail:\n                p = etree.SubElement(lst[-1], 'p')\n                p.text = lch.tail.lstrip()\n                lch.tail = ''\n\n            # parse first block differently as it gets wrapped in a `p`.\n            li = etree.SubElement(lst, 'li')\n            self.parser.state.set('looselist')\n            firstitem = items.pop(0)\n            self.parser.parseBlocks(li, [firstitem])\n            self.parser.state.reset()\n        elif parent.tag in ['ol', 'ul']:\n            # this catches the edge case of a multi-item indented list whose\n            # first item is in a blank parent-list item:\n            #     * * subitem1\n            #         * subitem2\n            # see also `ListIndentProcessor`\n            lst = parent\n        else:\n            # This is a new list so create parent with appropriate tag.\n            lst = etree.SubElement(parent, self.TAG)\n            # Check if a custom start integer is set\n            if not self.LAZY_OL and self.STARTSWITH != '1':\n                lst.attrib['start'] = self.STARTSWITH\n\n        self.parser.state.set('list')\n        # Loop through items in block, recursively parsing each with the\n        # appropriate parent.\n        for item in items:\n            if item.startswith(' '*self.tab_length):\n                # Item is indented. Parse with last item as parent\n                self.parser.parseBlocks(lst[-1], [item])\n            else:\n                # New item. Create `li` and parse with it as parent\n                li = etree.SubElement(lst, 'li')\n                self.parser.parseBlocks(li, [item])\n        self.parser.state.reset()\n\n    def get_items(self, block: str) -> list[str]:\n        \"\"\" Break a block into list items. \"\"\"\n        items = []\n        for line in block.split('\\n'):\n            m = self.CHILD_RE.match(line)\n            if m:\n                # This is a new list item\n                # Check first item for the start index\n                if not items and self.TAG == 'ol':\n                    # Detect the integer value of first list item\n                    INTEGER_RE = re.compile(r'(\\d+)')\n                    self.STARTSWITH = INTEGER_RE.match(m.group(1)).group()\n                # Append to the list\n                items.append(m.group(3))\n            elif self.INDENT_RE.match(line):\n                # This is an indented (possibly nested) item.\n                if items[-1].startswith(' '*self.tab_length):\n                    # Previous item was indented. Append to that item.\n                    items[-1] = '{}\\n{}'.format(items[-1], line)\n                else:\n                    items.append(line)\n            else:\n                # This is another line of previous item. Append to that item.\n                items[-1] = '{}\\n{}'.format(items[-1], line)\n        return items\n\n\nclass UListProcessor(OListProcessor):\n    \"\"\" Process unordered list blocks. \"\"\"\n\n    TAG: str = 'ul'\n    \"\"\" The tag used for the the wrapping element. \"\"\"\n\n    def __init__(self, parser: BlockParser):\n        super().__init__(parser)\n        # Detect an item (`1. item`). `group(1)` contains contents of item.\n        self.RE = re.compile(r'^[ ]{0,%d}[*+-][ ]+(.*)' % (self.tab_length - 1))\n\n\nclass HashHeaderProcessor(BlockProcessor):\n    \"\"\" Process Hash Headers. \"\"\"\n\n    # Detect a header at start of any line in block\n    RE = re.compile(r'(?:^|\\n)(?P<level>#{1,6})(?P<header>(?:\\\\.|[^\\\\])*?)#*(?:\\n|$)')\n\n    def test(self, parent: etree.Element, block: str) -> bool:\n        return bool(self.RE.search(block))\n\n    def run(self, parent: etree.Element, blocks: list[str]) -> None:\n        block = blocks.pop(0)\n        m = self.RE.search(block)\n        if m:\n            before = block[:m.start()]  # All lines before header\n            after = block[m.end():]     # All lines after header\n            if before:\n                # As the header was not the first line of the block and the\n                # lines before the header must be parsed first,\n                # recursively parse this lines as a block.\n                self.parser.parseBlocks(parent, [before])\n            # Create header using named groups from RE\n            h = etree.SubElement(parent, 'h%d' % len(m.group('level')))\n            h.text = m.group('header').strip()\n            if after:\n                # Insert remaining lines as first block for future parsing.\n                if self.parser.state.isstate('looselist'):\n                    # This is a weird edge case where a header is a child of a loose list\n                    # and there is no blank line after the header. To ensure proper\n                    # parsing, the line(s) after need to be detabbed. See #1443.\n                    after = self.looseDetab(after)\n                blocks.insert(0, after)\n        else:  # pragma: no cover\n            # This should never happen, but just in case...\n            logger.warn(\"We've got a problem header: %r\" % block)\n\n\nclass SetextHeaderProcessor(BlockProcessor):\n    \"\"\" Process Setext-style Headers. \"\"\"\n\n    # Detect Setext-style header. Must be first 2 lines of block.\n    RE = re.compile(r'^.*?\\n[=-]+[ ]*(\\n|$)', re.MULTILINE)\n\n    def test(self, parent: etree.Element, block: str) -> bool:\n        return bool(self.RE.match(block))\n\n    def run(self, parent: etree.Element, blocks: list[str]) -> None:\n        lines = blocks.pop(0).split('\\n')\n        # Determine level. `=` is 1 and `-` is 2.\n        if lines[1].startswith('='):\n            level = 1\n        else:\n            level = 2\n        h = etree.SubElement(parent, 'h%d' % level)\n        h.text = lines[0].strip()\n        if len(lines) > 2:\n            # Block contains additional lines. Add to  master blocks for later.\n            blocks.insert(0, '\\n'.join(lines[2:]))\n\n\nclass HRProcessor(BlockProcessor):\n    \"\"\" Process Horizontal Rules. \"\"\"\n\n    # Python's `re` module doesn't officially support atomic grouping. However you can fake it.\n    # See https://stackoverflow.com/a/13577411/866026\n    RE = r'^[ ]{0,3}(?=(?P<atomicgroup>(-+[ ]{0,2}){3,}|(_+[ ]{0,2}){3,}|(\\*+[ ]{0,2}){3,}))(?P=atomicgroup)[ ]*$'\n    # Detect hr on any line of a block.\n    SEARCH_RE = re.compile(RE, re.MULTILINE)\n\n    def test(self, parent: etree.Element, block: str) -> bool:\n        m = self.SEARCH_RE.search(block)\n        if m:\n            # Save match object on class instance so we can use it later.\n            self.match = m\n            return True\n        return False\n\n    def run(self, parent: etree.Element, blocks: list[str]) -> None:\n        block = blocks.pop(0)\n        match = self.match\n        # Check for lines in block before `hr`.\n        prelines = block[:match.start()].rstrip('\\n')\n        if prelines:\n            # Recursively parse lines before `hr` so they get parsed first.\n            self.parser.parseBlocks(parent, [prelines])\n        # create hr\n        etree.SubElement(parent, 'hr')\n        # check for lines in block after `hr`.\n        postlines = block[match.end():].lstrip('\\n')\n        if postlines:\n            # Add lines after `hr` to master blocks for later parsing.\n            blocks.insert(0, postlines)\n\n\nclass EmptyBlockProcessor(BlockProcessor):\n    \"\"\" Process blocks that are empty or start with an empty line. \"\"\"\n\n    def test(self, parent: etree.Element, block: str) -> bool:\n        return not block or block.startswith('\\n')\n\n    def run(self, parent: etree.Element, blocks: list[str]) -> None:\n        block = blocks.pop(0)\n        filler = '\\n\\n'\n        if block:\n            # Starts with empty line\n            # Only replace a single line.\n            filler = '\\n'\n            # Save the rest for later.\n            theRest = block[1:]\n            if theRest:\n                # Add remaining lines to master blocks for later.\n                blocks.insert(0, theRest)\n        sibling = self.lastChild(parent)\n        if (sibling is not None and sibling.tag == 'pre' and\n           len(sibling) and sibling[0].tag == 'code'):\n            # Last block is a code block. Append to preserve whitespace.\n            sibling[0].text = util.AtomicString(\n                '{}{}'.format(sibling[0].text, filler)\n            )\n\n\nclass ReferenceProcessor(BlockProcessor):\n    \"\"\" Process link references. \"\"\"\n    RE = re.compile(\n        r'^[ ]{0,3}\\[([^\\[\\]]*)\\]:[ ]*\\n?[ ]*([^\\s]+)[ ]*(?:\\n[ ]*)?(([\"\\'])(.*)\\4[ ]*|\\((.*)\\)[ ]*)?$', re.MULTILINE\n    )\n\n    def test(self, parent: etree.Element, block: str) -> bool:\n        return True\n\n    def run(self, parent: etree.Element, blocks: list[str]) -> bool:\n        block = blocks.pop(0)\n        m = self.RE.search(block)\n        if m:\n            id = m.group(1).strip().lower()\n            link = m.group(2).lstrip('<').rstrip('>')\n            title = m.group(5) or m.group(6)\n            self.parser.md.references[id] = (link, title)\n            if block[m.end():].strip():\n                # Add any content after match back to blocks as separate block\n                blocks.insert(0, block[m.end():].lstrip('\\n'))\n            if block[:m.start()].strip():\n                # Add any content before match back to blocks as separate block\n                blocks.insert(0, block[:m.start()].rstrip('\\n'))\n            return True\n        # No match. Restore block.\n        blocks.insert(0, block)\n        return False\n\n\nclass ParagraphProcessor(BlockProcessor):\n    \"\"\" Process Paragraph blocks. \"\"\"\n\n    def test(self, parent: etree.Element, block: str) -> bool:\n        return True\n\n    def run(self, parent: etree.Element, blocks: list[str]) -> None:\n        block = blocks.pop(0)\n        if block.strip():\n            # Not a blank block. Add to parent, otherwise throw it away.\n            if self.parser.state.isstate('list'):\n                # The parent is a tight-list.\n                #\n                # Check for any children. This will likely only happen in a\n                # tight-list when a header isn't followed by a blank line.\n                # For example:\n                #\n                #     * # Header\n                #     Line 2 of list item - not part of header.\n                sibling = self.lastChild(parent)\n                if sibling is not None:\n                    # Insert after sibling.\n                    if sibling.tail:\n                        sibling.tail = '{}\\n{}'.format(sibling.tail, block)\n                    else:\n                        sibling.tail = '\\n%s' % block\n                else:\n                    # Append to parent.text\n                    if parent.text:\n                        parent.text = '{}\\n{}'.format(parent.text, block)\n                    else:\n                        parent.text = block.lstrip()\n            else:\n                # Create a regular paragraph\n                p = etree.SubElement(parent, 'p')\n                p.text = block.lstrip()\n","size_bytes":27013},"markdown/core.py":{"content":"# Python Markdown\n\n# A Python implementation of John Gruber's Markdown.\n\n# Documentation: https://python-markdown.github.io/\n# GitHub: https://github.com/Python-Markdown/markdown/\n# PyPI: https://pypi.org/project/Markdown/\n\n# Started by Manfred Stienstra (http://www.dwerg.net/).\n# Maintained for a few years by Yuri Takhteyev (http://www.freewisdom.org).\n# Currently maintained by Waylan Limberg (https://github.com/waylan),\n# Dmitry Shachnev (https://github.com/mitya57) and Isaac Muse (https://github.com/facelessuser).\n\n# Copyright 2007-2023 The Python Markdown Project (v. 1.7 and later)\n# Copyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b)\n# Copyright 2004 Manfred Stienstra (the original version)\n\n# License: BSD (see LICENSE.md for details).\n\nfrom __future__ import annotations\n\nimport codecs\nimport sys\nimport logging\nimport importlib\nfrom typing import TYPE_CHECKING, Any, BinaryIO, Callable, ClassVar, Mapping, Sequence\nfrom . import util\nfrom .preprocessors import build_preprocessors\nfrom .blockprocessors import build_block_parser\nfrom .treeprocessors import build_treeprocessors\nfrom .inlinepatterns import build_inlinepatterns\nfrom .postprocessors import build_postprocessors\nfrom .extensions import Extension\nfrom .serializers import to_html_string, to_xhtml_string\nfrom .util import BLOCK_LEVEL_ELEMENTS\n\nif TYPE_CHECKING:  # pragma: no cover\n    from xml.etree.ElementTree import Element\n\n__all__ = ['Markdown', 'markdown', 'markdownFromFile']\n\n\nlogger = logging.getLogger('MARKDOWN')\n\n\nclass Markdown:\n    \"\"\"\n    A parser which converts Markdown to HTML.\n\n    Attributes:\n        Markdown.tab_length (int): The number of spaces which correspond to a single tab. Default: `4`.\n        Markdown.ESCAPED_CHARS (list[str]): List of characters which get the backslash escape treatment.\n        Markdown.block_level_elements (list[str]): List of HTML tags which get treated as block-level elements.\n            See [`markdown.util.BLOCK_LEVEL_ELEMENTS`][] for the full list of elements.\n        Markdown.registeredExtensions (list[Extension]): List of extensions which have called\n            [`registerExtension`][markdown.Markdown.registerExtension] during setup.\n        Markdown.doc_tag (str): Element used to wrap document. Default: `div`.\n        Markdown.stripTopLevelTags (bool): Indicates whether the `doc_tag` should be removed. Default: 'True'.\n        Markdown.references (dict[str, tuple[str, str]]): A mapping of link references found in a parsed document\n             where the key is the reference name and the value is a tuple of the URL and title.\n        Markdown.htmlStash (util.HtmlStash): The instance of the `HtmlStash` used by an instance of this class.\n        Markdown.output_formats (dict[str, Callable[xml.etree.ElementTree.Element]]): A mapping of known output\n             formats by name and their respective serializers. Each serializer must be a callable which accepts an\n            [`Element`][xml.etree.ElementTree.Element] and returns a `str`.\n        Markdown.output_format (str): The output format set by\n            [`set_output_format`][markdown.Markdown.set_output_format].\n        Markdown.serializer (Callable[xml.etree.ElementTree.Element]): The serializer set by\n            [`set_output_format`][markdown.Markdown.set_output_format].\n        Markdown.preprocessors (util.Registry): A collection of [`preprocessors`][markdown.preprocessors].\n        Markdown.parser (blockparser.BlockParser): A collection of [`blockprocessors`][markdown.blockprocessors].\n        Markdown.inlinePatterns (util.Registry): A collection of [`inlinepatterns`][markdown.inlinepatterns].\n        Markdown.treeprocessors (util.Registry): A collection of [`treeprocessors`][markdown.treeprocessors].\n        Markdown.postprocessors (util.Registry): A collection of [`postprocessors`][markdown.postprocessors].\n\n    \"\"\"\n\n    doc_tag = \"div\"     # Element used to wrap document - later removed\n\n    output_formats: ClassVar[dict[str, Callable[[Element], str]]] = {\n        'html':   to_html_string,\n        'xhtml':  to_xhtml_string,\n    }\n    \"\"\"\n    A mapping of known output formats by name and their respective serializers. Each serializer must be a\n    callable which accepts an [`Element`][xml.etree.ElementTree.Element] and returns a `str`.\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        \"\"\"\n        Creates a new Markdown instance.\n\n        Keyword Arguments:\n            extensions (list[Extension | str]): A list of extensions.\n\n                If an item is an instance of a subclass of [`markdown.extensions.Extension`][],\n                the instance will be used as-is. If an item is of type `str`, it is passed\n                to [`build_extension`][markdown.Markdown.build_extension] with its corresponding\n                `extension_configs` and the returned instance  of [`markdown.extensions.Extension`][]\n                is used.\n            extension_configs (dict[str, dict[str, Any]]): Configuration settings for extensions.\n            output_format (str): Format of output. Supported formats are:\n\n                * `xhtml`: Outputs XHTML style tags. Default.\n                * `html`: Outputs HTML style tags.\n            tab_length (int): Length of tabs in the source. Default: `4`\n\n        \"\"\"\n\n        self.tab_length: int = kwargs.get('tab_length', 4)\n\n        self.ESCAPED_CHARS: list[str] = [\n            '\\\\', '`', '*', '_', '{', '}', '[', ']', '(', ')', '>', '#', '+', '-', '.', '!'\n        ]\n        \"\"\" List of characters which get the backslash escape treatment. \"\"\"\n\n        self.block_level_elements: list[str] = BLOCK_LEVEL_ELEMENTS.copy()\n\n        self.registeredExtensions: list[Extension] = []\n        self.docType = \"\"  # TODO: Maybe delete this. It does not appear to be used anymore.\n        self.stripTopLevelTags: bool = True\n\n        self.build_parser()\n\n        self.references: dict[str, tuple[str, str]] = {}\n        self.htmlStash: util.HtmlStash = util.HtmlStash()\n        self.registerExtensions(extensions=kwargs.get('extensions', []),\n                                configs=kwargs.get('extension_configs', {}))\n        self.set_output_format(kwargs.get('output_format', 'xhtml'))\n        self.reset()\n\n    def build_parser(self) -> Markdown:\n        \"\"\"\n        Build the parser from the various parts.\n\n        Assigns a value to each of the following attributes on the class instance:\n\n        * **`Markdown.preprocessors`** ([`Registry`][markdown.util.Registry]) -- A collection of\n          [`preprocessors`][markdown.preprocessors].\n        * **`Markdown.parser`** ([`BlockParser`][markdown.blockparser.BlockParser]) -- A collection of\n          [`blockprocessors`][markdown.blockprocessors].\n        * **`Markdown.inlinePatterns`** ([`Registry`][markdown.util.Registry]) -- A collection of\n          [`inlinepatterns`][markdown.inlinepatterns].\n        * **`Markdown.treeprocessors`** ([`Registry`][markdown.util.Registry]) -- A collection of\n          [`treeprocessors`][markdown.treeprocessors].\n        * **`Markdown.postprocessors`** ([`Registry`][markdown.util.Registry]) -- A collection of\n          [`postprocessors`][markdown.postprocessors].\n\n        This method could be redefined in a subclass to build a custom parser which is made up of a different\n        combination of processors and patterns.\n\n        \"\"\"\n        self.preprocessors = build_preprocessors(self)\n        self.parser = build_block_parser(self)\n        self.inlinePatterns = build_inlinepatterns(self)\n        self.treeprocessors = build_treeprocessors(self)\n        self.postprocessors = build_postprocessors(self)\n        return self\n\n    def registerExtensions(\n        self,\n        extensions: Sequence[Extension | str],\n        configs: Mapping[str, dict[str, Any]]\n    ) -> Markdown:\n        \"\"\"\n        Load a list of extensions into an instance of the `Markdown` class.\n\n        Arguments:\n            extensions (list[Extension | str]): A list of extensions.\n\n                If an item is an instance of a subclass of [`markdown.extensions.Extension`][],\n                the instance will be used as-is. If an item is of type `str`, it is passed\n                to [`build_extension`][markdown.Markdown.build_extension] with its corresponding `configs` and the\n                returned instance  of [`markdown.extensions.Extension`][] is used.\n            configs (dict[str, dict[str, Any]]): Configuration settings for extensions.\n\n        \"\"\"\n        for ext in extensions:\n            if isinstance(ext, str):\n                ext = self.build_extension(ext, configs.get(ext, {}))\n            if isinstance(ext, Extension):\n                ext.extendMarkdown(self)\n                logger.debug(\n                    'Successfully loaded extension \"%s.%s\".'\n                    % (ext.__class__.__module__, ext.__class__.__name__)\n                )\n            elif ext is not None:\n                raise TypeError(\n                    'Extension \"{}.{}\" must be of type: \"{}.{}\"'.format(\n                        ext.__class__.__module__, ext.__class__.__name__,\n                        Extension.__module__, Extension.__name__\n                    )\n                )\n        return self\n\n    def build_extension(self, ext_name: str, configs: Mapping[str, Any]) -> Extension:\n        \"\"\"\n        Build extension from a string name, then return an instance using the given `configs`.\n\n        Arguments:\n            ext_name: Name of extension as a string.\n            configs: Configuration settings for extension.\n\n        Returns:\n            An instance of the extension with the given configuration settings.\n\n        First attempt to load an entry point. The string name must be registered as an entry point in the\n        `markdown.extensions` group which points to a subclass of the [`markdown.extensions.Extension`][] class.\n        If multiple distributions have registered the same name, the first one found is returned.\n\n        If no entry point is found, assume dot notation (`path.to.module:ClassName`). Load the specified class and\n        return an instance. If no class is specified, import the module and call a `makeExtension` function and return\n        the [`markdown.extensions.Extension`][] instance returned by that function.\n        \"\"\"\n        configs = dict(configs)\n\n        entry_points = [ep for ep in util.get_installed_extensions() if ep.name == ext_name]\n        if entry_points:\n            ext = entry_points[0].load()\n            return ext(**configs)\n\n        # Get class name (if provided): `path.to.module:ClassName`\n        ext_name, class_name = ext_name.split(':', 1) if ':' in ext_name else (ext_name, '')\n\n        try:\n            module = importlib.import_module(ext_name)\n            logger.debug(\n                'Successfully imported extension module \"%s\".' % ext_name\n            )\n        except ImportError as e:\n            message = 'Failed loading extension \"%s\".' % ext_name\n            e.args = (message,) + e.args[1:]\n            raise\n\n        if class_name:\n            # Load given class name from module.\n            return getattr(module, class_name)(**configs)\n        else:\n            # Expect  `makeExtension()` function to return a class.\n            try:\n                return module.makeExtension(**configs)\n            except AttributeError as e:\n                message = e.args[0]\n                message = \"Failed to initiate extension \" \\\n                          \"'%s': %s\" % (ext_name, message)\n                e.args = (message,) + e.args[1:]\n                raise\n\n    def registerExtension(self, extension: Extension) -> Markdown:\n        \"\"\"\n        Register an extension as having a resettable state.\n\n        Arguments:\n            extension: An instance of the extension to register.\n\n        This should get called once by an extension during setup. A \"registered\" extension's\n        `reset` method is called by [`Markdown.reset()`][markdown.Markdown.reset]. Not all extensions have or need a\n        resettable state, and so it should not be assumed that all extensions are \"registered.\"\n\n        \"\"\"\n        self.registeredExtensions.append(extension)\n        return self\n\n    def reset(self) -> Markdown:\n        \"\"\"\n        Resets all state variables to prepare the parser instance for new input.\n\n        Called once upon creation of a class instance. Should be called manually between calls\n        to [`Markdown.convert`][markdown.Markdown.convert].\n        \"\"\"\n        self.htmlStash.reset()\n        self.references.clear()\n\n        for extension in self.registeredExtensions:\n            if hasattr(extension, 'reset'):\n                extension.reset()\n\n        return self\n\n    def set_output_format(self, format: str) -> Markdown:\n        \"\"\"\n        Set the output format for the class instance.\n\n        Arguments:\n            format: Must be a known value in `Markdown.output_formats`.\n\n        \"\"\"\n        self.output_format = format.lower().rstrip('145')  # ignore number\n        try:\n            self.serializer = self.output_formats[self.output_format]\n        except KeyError as e:\n            valid_formats = list(self.output_formats.keys())\n            valid_formats.sort()\n            message = 'Invalid Output Format: \"%s\". Use one of %s.' \\\n                % (self.output_format,\n                   '\"' + '\", \"'.join(valid_formats) + '\"')\n            e.args = (message,) + e.args[1:]\n            raise\n        return self\n\n    # Note: the `tag` argument is type annotated `Any` as ElementTree uses many various objects as tags.\n    # As there is no standardization in ElementTree, the type of a given tag is unpredictable.\n    def is_block_level(self, tag: Any) -> bool:\n        \"\"\"\n        Check if the given `tag` is a block level HTML tag.\n\n        Returns `True` for any string listed in `Markdown.block_level_elements`. A `tag` which is\n        not a string always returns `False`.\n\n        \"\"\"\n        if isinstance(tag, str):\n            return tag.lower().rstrip('/') in self.block_level_elements\n        # Some ElementTree tags are not strings, so return False.\n        return False\n\n    def convert(self, source: str) -> str:\n        \"\"\"\n        Convert a Markdown string to a string in the specified output format.\n\n        Arguments:\n            source: Markdown formatted text as Unicode or ASCII string.\n\n        Returns:\n            A string in the specified output format.\n\n        Markdown parsing takes place in five steps:\n\n        1. A bunch of [`preprocessors`][markdown.preprocessors] munge the input text.\n        2. A [`BlockParser`][markdown.blockparser.BlockParser] parses the high-level structural elements of the\n           pre-processed text into an [`ElementTree`][xml.etree.ElementTree.ElementTree] object.\n        3. A bunch of [`treeprocessors`][markdown.treeprocessors] are run against the\n           [`ElementTree`][xml.etree.ElementTree.ElementTree] object. One such `treeprocessor`\n           ([`markdown.treeprocessors.InlineProcessor`][]) runs [`inlinepatterns`][markdown.inlinepatterns]\n           against the [`ElementTree`][xml.etree.ElementTree.ElementTree] object, parsing inline markup.\n        4. Some [`postprocessors`][markdown.postprocessors] are run against the text after the\n           [`ElementTree`][xml.etree.ElementTree.ElementTree] object has been serialized into text.\n        5. The output is returned as a string.\n\n        \"\"\"\n\n        # Fix up the source text\n        if not source.strip():\n            return ''  # a blank Unicode string\n\n        try:\n            source = str(source)\n        except UnicodeDecodeError as e:  # pragma: no cover\n            # Customize error message while maintaining original traceback\n            e.reason += '. -- Note: Markdown only accepts Unicode input!'\n            raise\n\n        # Split into lines and run the line preprocessors.\n        self.lines = source.split(\"\\n\")\n        for prep in self.preprocessors:\n            self.lines = prep.run(self.lines)\n\n        # Parse the high-level elements.\n        root = self.parser.parseDocument(self.lines).getroot()\n\n        # Run the tree-processors\n        for treeprocessor in self.treeprocessors:\n            newRoot = treeprocessor.run(root)\n            if newRoot is not None:\n                root = newRoot\n\n        # Serialize _properly_.  Strip top-level tags.\n        output = self.serializer(root)\n        if self.stripTopLevelTags:\n            try:\n                start = output.index(\n                    '<%s>' % self.doc_tag) + len(self.doc_tag) + 2\n                end = output.rindex('</%s>' % self.doc_tag)\n                output = output[start:end].strip()\n            except ValueError as e:  # pragma: no cover\n                if output.strip().endswith('<%s />' % self.doc_tag):\n                    # We have an empty document\n                    output = ''\n                else:\n                    # We have a serious problem\n                    raise ValueError('Markdown failed to strip top-level '\n                                     'tags. Document=%r' % output.strip()) from e\n\n        # Run the text post-processors\n        for pp in self.postprocessors:\n            output = pp.run(output)\n\n        return output.strip()\n\n    def convertFile(\n        self,\n        input: str | BinaryIO | None = None,\n        output: str | BinaryIO | None = None,\n        encoding: str | None = None,\n    ) -> Markdown:\n        \"\"\"\n        Converts a Markdown file and returns the HTML as a Unicode string.\n\n        Decodes the file using the provided encoding (defaults to `utf-8`),\n        passes the file content to markdown, and outputs the HTML to either\n        the provided stream or the file with provided name, using the same\n        encoding as the source file. The\n        [`xmlcharrefreplace`](https://docs.python.org/3/library/codecs.html#error-handlers)\n        error handler is used when encoding the output.\n\n        **Note:** This is the only place that decoding and encoding of Unicode\n        takes place in Python-Markdown.  (All other code is Unicode-in /\n        Unicode-out.)\n\n        Arguments:\n            input: File object or path. Reads from `stdin` if `None`.\n            output: File object or path. Writes to `stdout` if `None`.\n            encoding: Encoding of input and output files. Defaults to `utf-8`.\n\n        \"\"\"\n\n        encoding = encoding or \"utf-8\"\n\n        # Read the source\n        if input:\n            if isinstance(input, str):\n                input_file = open(input, mode=\"r\", encoding=encoding)\n            else:\n                input_file = codecs.getreader(encoding)(input)\n            text = input_file.read()\n            input_file.close()\n        else:\n            text = sys.stdin.read()\n\n        text = text.lstrip('\\ufeff')  # remove the byte-order mark\n\n        # Convert\n        html = self.convert(text)\n\n        # Write to file or stdout\n        if output:\n            if isinstance(output, str):\n                output_file = codecs.open(output, \"w\",\n                                          encoding=encoding,\n                                          errors=\"xmlcharrefreplace\")\n                output_file.write(html)\n                output_file.close()\n            else:\n                writer = codecs.getwriter(encoding)\n                output_file = writer(output, errors=\"xmlcharrefreplace\")\n                output_file.write(html)\n                # Don't close here. User may want to write more.\n        else:\n            # Encode manually and write bytes to stdout.\n            html = html.encode(encoding, \"xmlcharrefreplace\")\n            sys.stdout.buffer.write(html)\n\n        return self\n\n\n\"\"\"\nEXPORTED FUNCTIONS\n=============================================================================\n\nThose are the two functions we really mean to export: `markdown()` and\n`markdownFromFile()`.\n\"\"\"\n\n\ndef markdown(text: str, **kwargs: Any) -> str:\n    \"\"\"\n    Convert a markdown string to HTML and return HTML as a Unicode string.\n\n    This is a shortcut function for [`Markdown`][markdown.Markdown] class to cover the most\n    basic use case.  It initializes an instance of [`Markdown`][markdown.Markdown], loads the\n    necessary extensions and runs the parser on the given text.\n\n    Arguments:\n        text: Markdown formatted text as Unicode or ASCII string.\n\n    Keyword arguments:\n        **kwargs: Any arguments accepted by the Markdown class.\n\n    Returns:\n        A string in the specified output format.\n\n    \"\"\"\n    md = Markdown(**kwargs)\n    return md.convert(text)\n\n\ndef markdownFromFile(**kwargs: Any):\n    \"\"\"\n    Read Markdown text from a file and write output to a file or a stream.\n\n    This is a shortcut function which initializes an instance of [`Markdown`][markdown.Markdown],\n    and calls the [`convertFile`][markdown.Markdown.convertFile] method rather than\n    [`convert`][markdown.Markdown.convert].\n\n    Keyword arguments:\n        input (str | BinaryIO): A file name or readable object.\n        output (str | BinaryIO): A file name or writable object.\n        encoding (str): Encoding of input and output.\n        **kwargs: Any arguments accepted by the `Markdown` class.\n\n    \"\"\"\n    md = Markdown(**kwargs)\n    md.convertFile(kwargs.get('input', None),\n                   kwargs.get('output', None),\n                   kwargs.get('encoding', None))\n","size_bytes":21328},"markdown/htmlparser.py":{"content":"# Python Markdown\n\n# A Python implementation of John Gruber's Markdown.\n\n# Documentation: https://python-markdown.github.io/\n# GitHub: https://github.com/Python-Markdown/markdown/\n# PyPI: https://pypi.org/project/Markdown/\n\n# Started by Manfred Stienstra (http://www.dwerg.net/).\n# Maintained for a few years by Yuri Takhteyev (http://www.freewisdom.org).\n# Currently maintained by Waylan Limberg (https://github.com/waylan),\n# Dmitry Shachnev (https://github.com/mitya57) and Isaac Muse (https://github.com/facelessuser).\n\n# Copyright 2007-2023 The Python Markdown Project (v. 1.7 and later)\n# Copyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b)\n# Copyright 2004 Manfred Stienstra (the original version)\n\n# License: BSD (see LICENSE.md for details).\n\n\"\"\"\nThis module imports a copy of [`html.parser.HTMLParser`][] and modifies it heavily through monkey-patches.\nA copy is imported rather than the module being directly imported as this ensures that the user can import\nand  use the unmodified library for their own needs.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport re\nimport importlib.util\nimport sys\nfrom typing import TYPE_CHECKING, Sequence\n\nif TYPE_CHECKING:  # pragma: no cover\n    from markdown import Markdown\n\n\n# Import a copy of the html.parser lib as `htmlparser` so we can monkeypatch it.\n# Users can still do `from html import parser` and get the default behavior.\nspec = importlib.util.find_spec('html.parser')\nhtmlparser = importlib.util.module_from_spec(spec)\nspec.loader.exec_module(htmlparser)\nsys.modules['htmlparser'] = htmlparser\n\n# This is a hack. We are sneaking in `</>` so we can capture it without the HTML parser\n# throwing it away. When we see it, we will process it as data.\nhtmlparser.starttagopen = re.compile('<[a-zA-Z]|</>')\n\n# Monkeypatch `HTMLParser` to only accept `?>` to close Processing Instructions.\nhtmlparser.piclose = re.compile(r'\\?>')\n# Monkeypatch `HTMLParser` to only recognize entity references with a closing semicolon.\nhtmlparser.entityref = re.compile(r'&([a-zA-Z][-.a-zA-Z0-9]*);')\n# Monkeypatch `HTMLParser` to no longer support partial entities. We are always feeding a complete block,\n# so the 'incomplete' functionality is unnecessary. As the `entityref` regex is run right before incomplete,\n# and the two regex are the same, then incomplete will simply never match and we avoid the logic within.\nhtmlparser.incomplete = htmlparser.entityref\n# Monkeypatch `HTMLParser` to not accept a backtick in a tag name, attribute name, or bare value.\nhtmlparser.locatestarttagend_tolerant = re.compile(r\"\"\"\n  <[a-zA-Z][^`\\t\\n\\r\\f />\\x00]*       # tag name <= added backtick here\n  (?:[\\s/]*                           # optional whitespace before attribute name\n    (?:(?<=['\"\\s/])[^`\\s/>][^\\s/=>]*  # attribute name <= added backtick here\n      (?:\\s*=+\\s*                     # value indicator\n        (?:'[^']*'                    # LITA-enclosed value\n          |\"[^\"]*\"                    # LIT-enclosed value\n          |(?!['\"])[^`>\\s]*           # bare value <= added backtick here\n         )\n         (?:\\s*,)*                    # possibly followed by a comma\n       )?(?:\\s|/(?!>))*\n     )*\n   )?\n  \\s*                                 # trailing whitespace\n\"\"\", re.VERBOSE)\n\n# Match a blank line at the start of a block of text (two newlines).\n# The newlines may be preceded by additional whitespace.\nblank_line_re = re.compile(r'^([ ]*\\n){2}')\n\n\nclass HTMLExtractor(htmlparser.HTMLParser):\n    \"\"\"\n    Extract raw HTML from text.\n\n    The raw HTML is stored in the [`htmlStash`][markdown.util.HtmlStash] of the\n    [`Markdown`][markdown.Markdown] instance passed to `md` and the remaining text\n    is stored in `cleandoc` as a list of strings.\n    \"\"\"\n\n    def __init__(self, md: Markdown, *args, **kwargs):\n        if 'convert_charrefs' not in kwargs:\n            kwargs['convert_charrefs'] = False\n\n        # Block tags that should contain no content (self closing)\n        self.empty_tags = set(['hr'])\n\n        self.lineno_start_cache = [0]\n\n        self.override_comment_update = False\n\n        # This calls self.reset\n        super().__init__(*args, **kwargs)\n        self.md = md\n\n    def reset(self):\n        \"\"\"Reset this instance.  Loses all unprocessed data.\"\"\"\n        self.inraw = False\n        self.intail = False\n        self.stack: list[str] = []  # When `inraw==True`, stack contains a list of tags\n        self._cache: list[str] = []\n        self.cleandoc: list[str] = []\n        self.lineno_start_cache = [0]\n\n        super().reset()\n\n    def close(self):\n        \"\"\"Handle any buffered data.\"\"\"\n        super().close()\n        if len(self.rawdata):\n            # Temp fix for https://bugs.python.org/issue41989\n            # TODO: remove this when the bug is fixed in all supported Python versions.\n            if self.convert_charrefs and not self.cdata_elem:  # pragma: no cover\n                self.handle_data(htmlparser.unescape(self.rawdata))\n            else:\n                self.handle_data(self.rawdata)\n        # Handle any unclosed tags.\n        if len(self._cache):\n            self.cleandoc.append(self.md.htmlStash.store(''.join(self._cache)))\n            self._cache = []\n\n    @property\n    def line_offset(self) -> int:\n        \"\"\"Returns char index in `self.rawdata` for the start of the current line. \"\"\"\n        for ii in range(len(self.lineno_start_cache)-1, self.lineno-1):\n            last_line_start_pos = self.lineno_start_cache[ii]\n            lf_pos = self.rawdata.find('\\n', last_line_start_pos)\n            if lf_pos == -1:\n                # No more newlines found. Use end of raw data as start of line beyond end.\n                lf_pos = len(self.rawdata)\n            self.lineno_start_cache.append(lf_pos+1)\n\n        return self.lineno_start_cache[self.lineno-1]\n\n    def at_line_start(self) -> bool:\n        \"\"\"\n        Returns True if current position is at start of line.\n\n        Allows for up to three blank spaces at start of line.\n        \"\"\"\n        if self.offset == 0:\n            return True\n        if self.offset > 3:\n            return False\n        # Confirm up to first 3 chars are whitespace\n        return self.rawdata[self.line_offset:self.line_offset + self.offset].strip() == ''\n\n    def get_endtag_text(self, tag: str) -> str:\n        \"\"\"\n        Returns the text of the end tag.\n\n        If it fails to extract the actual text from the raw data, it builds a closing tag with `tag`.\n        \"\"\"\n        # Attempt to extract actual tag from raw source text\n        start = self.line_offset + self.offset\n        m = htmlparser.endendtag.search(self.rawdata, start)\n        if m:\n            return self.rawdata[start:m.end()]\n        else:  # pragma: no cover\n            # Failed to extract from raw data. Assume well formed and lowercase.\n            return '</{}>'.format(tag)\n\n    def handle_starttag(self, tag: str, attrs: Sequence[tuple[str, str]]):\n        # Handle tags that should always be empty and do not specify a closing tag\n        if tag in self.empty_tags:\n            self.handle_startendtag(tag, attrs)\n            return\n\n        if self.md.is_block_level(tag) and (self.intail or (self.at_line_start() and not self.inraw)):\n            # Started a new raw block. Prepare stack.\n            self.inraw = True\n            self.cleandoc.append('\\n')\n\n        text = self.get_starttag_text()\n        if self.inraw:\n            self.stack.append(tag)\n            self._cache.append(text)\n        else:\n            self.cleandoc.append(text)\n            if tag in self.CDATA_CONTENT_ELEMENTS:\n                # This is presumably a standalone tag in a code span (see #1036).\n                self.clear_cdata_mode()\n\n    def handle_endtag(self, tag: str):\n        text = self.get_endtag_text(tag)\n\n        if self.inraw:\n            self._cache.append(text)\n            if tag in self.stack:\n                # Remove tag from stack\n                while self.stack:\n                    if self.stack.pop() == tag:\n                        break\n            if len(self.stack) == 0:\n                # End of raw block.\n                if blank_line_re.match(self.rawdata[self.line_offset + self.offset + len(text):]):\n                    # Preserve blank line and end of raw block.\n                    self._cache.append('\\n')\n                else:\n                    # More content exists after `endtag`.\n                    self.intail = True\n                # Reset stack.\n                self.inraw = False\n                self.cleandoc.append(self.md.htmlStash.store(''.join(self._cache)))\n                # Insert blank line between this and next line.\n                self.cleandoc.append('\\n\\n')\n                self._cache = []\n        else:\n            self.cleandoc.append(text)\n\n    def handle_data(self, data: str):\n        if self.intail and '\\n' in data:\n            self.intail = False\n        if self.inraw:\n            self._cache.append(data)\n        else:\n            self.cleandoc.append(data)\n\n    def handle_empty_tag(self, data: str, is_block: bool):\n        \"\"\" Handle empty tags (`<data>`). \"\"\"\n        if self.inraw or self.intail:\n            # Append this to the existing raw block\n            self._cache.append(data)\n        elif self.at_line_start() and is_block:\n            # Handle this as a standalone raw block\n            if blank_line_re.match(self.rawdata[self.line_offset + self.offset + len(data):]):\n                # Preserve blank line after tag in raw block.\n                data += '\\n'\n            else:\n                # More content exists after tag.\n                self.intail = True\n            item = self.cleandoc[-1] if self.cleandoc else ''\n            # If we only have one newline before block element, add another\n            if not item.endswith('\\n\\n') and item.endswith('\\n'):\n                self.cleandoc.append('\\n')\n            self.cleandoc.append(self.md.htmlStash.store(data))\n            # Insert blank line between this and next line.\n            self.cleandoc.append('\\n\\n')\n        else:\n            self.cleandoc.append(data)\n\n    def handle_startendtag(self, tag: str, attrs):\n        self.handle_empty_tag(self.get_starttag_text(), is_block=self.md.is_block_level(tag))\n\n    def handle_charref(self, name: str):\n        self.handle_empty_tag('&#{};'.format(name), is_block=False)\n\n    def handle_entityref(self, name: str):\n        self.handle_empty_tag('&{};'.format(name), is_block=False)\n\n    def handle_comment(self, data: str):\n        # Check if the comment is unclosed, if so, we need to override position\n        i = self.line_offset + self.offset + len(data) + 4\n        if self.rawdata[i:i + 3] != '-->':\n            self.handle_data('<')\n            self.override_comment_update = True\n            return\n        self.handle_empty_tag('<!--{}-->'.format(data), is_block=True)\n\n    def updatepos(self, i: int, j: int) -> int:\n        if self.override_comment_update:\n            self.override_comment_update = False\n            i = 0\n            j = 1\n        return super().updatepos(i, j)\n\n    def handle_decl(self, data: str):\n        self.handle_empty_tag('<!{}>'.format(data), is_block=True)\n\n    def handle_pi(self, data: str):\n        self.handle_empty_tag('<?{}?>'.format(data), is_block=True)\n\n    def unknown_decl(self, data: str):\n        end = ']]>' if data.startswith('CDATA[') else ']>'\n        self.handle_empty_tag('<![{}{}'.format(data, end), is_block=True)\n\n    def parse_pi(self, i: int) -> int:\n        if self.at_line_start() or self.intail:\n            return super().parse_pi(i)\n        # This is not the beginning of a raw block so treat as plain data\n        # and avoid consuming any tags which may follow (see #1066).\n        self.handle_data('<?')\n        return i + 2\n\n    def parse_html_declaration(self, i: int) -> int:\n        if self.at_line_start() or self.intail:\n            if self.rawdata[i:i+3] == '<![' and not self.rawdata[i:i+9] == '<![CDATA[':\n                # We have encountered the bug in #1534 (Python bug `gh-77057`).\n                # Provide an override until we drop support for Python < 3.13.\n                result = self.parse_bogus_comment(i)\n                if result == -1:\n                    self.handle_data(self.rawdata[i:i + 1])\n                    return i + 1\n                return result\n            return super().parse_html_declaration(i)\n        # This is not the beginning of a raw block so treat as plain data\n        # and avoid consuming any tags which may follow (see #1066).\n        self.handle_data('<!')\n        return i + 2\n\n    def parse_bogus_comment(self, i: int, report: int = 0) -> int:\n        # Override the default behavior so that bogus comments get passed\n        # through unaltered by setting `report` to `0` (see #1425).\n        pos = super().parse_bogus_comment(i, report)\n        if pos == -1:  # pragma: no cover\n            return -1\n        self.handle_empty_tag(self.rawdata[i:pos], is_block=False)\n        return pos\n\n    # The rest has been copied from base class in standard lib to address #1036.\n    # As `__startag_text` is private, all references to it must be in this subclass.\n    # The last few lines of `parse_starttag` are reversed so that `handle_starttag`\n    # can override `cdata_mode` in certain situations (in a code span).\n    __starttag_text: str | None = None\n\n    def get_starttag_text(self) -> str:\n        \"\"\"Return full source of start tag: `<...>`.\"\"\"\n        return self.__starttag_text\n\n    def parse_starttag(self, i: int) -> int:  # pragma: no cover\n        # Treat `</>` as normal data as it is not a real tag.\n        if self.rawdata[i:i + 3] == '</>':\n            self.handle_data(self.rawdata[i:i + 3])\n            return i + 3\n\n        self.__starttag_text = None\n        endpos = self.check_for_whole_start_tag(i)\n        if endpos < 0:\n            self.handle_data(self.rawdata[i:i + 1])\n            return i + 1\n        rawdata = self.rawdata\n        self.__starttag_text = rawdata[i:endpos]\n\n        # Now parse the data between `i+1` and `j` into a tag and `attrs`\n        attrs = []\n        match = htmlparser.tagfind_tolerant.match(rawdata, i+1)\n        assert match, 'unexpected call to parse_starttag()'\n        k = match.end()\n        self.lasttag = tag = match.group(1).lower()\n        while k < endpos:\n            m = htmlparser.attrfind_tolerant.match(rawdata, k)\n            if not m:\n                break\n            attrname, rest, attrvalue = m.group(1, 2, 3)\n            if not rest:\n                attrvalue = None\n            elif attrvalue[:1] == '\\'' == attrvalue[-1:] or \\\n                 attrvalue[:1] == '\"' == attrvalue[-1:]:  # noqa: E127\n                attrvalue = attrvalue[1:-1]\n            if attrvalue:\n                attrvalue = htmlparser.unescape(attrvalue)\n            attrs.append((attrname.lower(), attrvalue))\n            k = m.end()\n\n        end = rawdata[k:endpos].strip()\n        if end not in (\">\", \"/>\"):\n            lineno, offset = self.getpos()\n            if \"\\n\" in self.__starttag_text:\n                lineno = lineno + self.__starttag_text.count(\"\\n\")\n                offset = len(self.__starttag_text) \\\n                         - self.__starttag_text.rfind(\"\\n\")  # noqa: E127\n            else:\n                offset = offset + len(self.__starttag_text)\n            self.handle_data(rawdata[i:endpos])\n            return endpos\n        if end.endswith('/>'):\n            # XHTML-style empty tag: `<span attr=\"value\" />`\n            self.handle_startendtag(tag, attrs)\n        else:\n            # *** set `cdata_mode` first so we can override it in `handle_starttag` (see #1036) ***\n            if tag in self.CDATA_CONTENT_ELEMENTS:\n                self.set_cdata_mode(tag)\n            self.handle_starttag(tag, attrs)\n        return endpos\n","size_bytes":15772},"markdown/inlinepatterns.py":{"content":"# Python Markdown\n\n# A Python implementation of John Gruber's Markdown.\n\n# Documentation: https://python-markdown.github.io/\n# GitHub: https://github.com/Python-Markdown/markdown/\n# PyPI: https://pypi.org/project/Markdown/\n\n# Started by Manfred Stienstra (http://www.dwerg.net/).\n# Maintained for a few years by Yuri Takhteyev (http://www.freewisdom.org).\n# Currently maintained by Waylan Limberg (https://github.com/waylan),\n# Dmitry Shachnev (https://github.com/mitya57) and Isaac Muse (https://github.com/facelessuser).\n\n# Copyright 2007-2023 The Python Markdown Project (v. 1.7 and later)\n# Copyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b)\n# Copyright 2004 Manfred Stienstra (the original version)\n\n# License: BSD (see LICENSE.md for details).\n\n\"\"\"\nIn version 3.0, a new, more flexible inline processor was added, [`markdown.inlinepatterns.InlineProcessor`][].   The\noriginal inline patterns, which inherit from [`markdown.inlinepatterns.Pattern`][] or one of its children are still\nsupported, though users are encouraged to migrate.\n\nThe new `InlineProcessor` provides two major enhancements to `Patterns`:\n\n1. Inline Processors no longer need to match the entire block, so regular expressions no longer need to start with\n  `r'^(.*?)'` and end with `r'(.*?)%'`. This runs faster. The returned [`Match`][re.Match] object will only contain\n   what is explicitly matched in the pattern, and extension pattern groups now start with `m.group(1)`.\n\n2.  The `handleMatch` method now takes an additional input called `data`, which is the entire block under analysis,\n    not just what is matched with the specified pattern. The method now returns the element *and* the indexes relative\n    to `data` that the return element is replacing (usually `m.start(0)` and `m.end(0)`).  If the boundaries are\n    returned as `None`, it is assumed that the match did not take place, and nothing will be altered in `data`.\n\n    This allows handling of more complex constructs than regular expressions can handle, e.g., matching nested\n    brackets, and explicit control of the span \"consumed\" by the processor.\n\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom . import util\nfrom typing import TYPE_CHECKING, Any, Collection, NamedTuple\nimport re\nimport xml.etree.ElementTree as etree\nfrom html import entities\n\nif TYPE_CHECKING:  # pragma: no cover\n    from markdown import Markdown\n\n\ndef build_inlinepatterns(md: Markdown, **kwargs: Any) -> util.Registry[InlineProcessor]:\n    \"\"\"\n    Build the default set of inline patterns for Markdown.\n\n    The order in which processors and/or patterns are applied is very important - e.g. if we first replace\n    `http://.../` links with `<a>` tags and _then_ try to replace inline HTML, we would end up with a mess. So, we\n    apply the expressions in the following order:\n\n    * backticks and escaped characters have to be handled before everything else so that we can preempt any markdown\n      patterns by escaping them;\n\n    * then we handle the various types of links (auto-links must be handled before inline HTML);\n\n    * then we handle inline HTML.  At this point we will simply replace all inline HTML strings with a placeholder\n      and add the actual HTML to a stash;\n\n    * finally we apply strong, emphasis, etc.\n\n    \"\"\"\n    inlinePatterns = util.Registry()\n    inlinePatterns.register(BacktickInlineProcessor(BACKTICK_RE), 'backtick', 190)\n    inlinePatterns.register(EscapeInlineProcessor(ESCAPE_RE, md), 'escape', 180)\n    inlinePatterns.register(ReferenceInlineProcessor(REFERENCE_RE, md), 'reference', 170)\n    inlinePatterns.register(LinkInlineProcessor(LINK_RE, md), 'link', 160)\n    inlinePatterns.register(ImageInlineProcessor(IMAGE_LINK_RE, md), 'image_link', 150)\n    inlinePatterns.register(\n        ImageReferenceInlineProcessor(IMAGE_REFERENCE_RE, md), 'image_reference', 140\n    )\n    inlinePatterns.register(\n        ShortReferenceInlineProcessor(REFERENCE_RE, md), 'short_reference', 130\n    )\n    inlinePatterns.register(\n        ShortImageReferenceInlineProcessor(IMAGE_REFERENCE_RE, md), 'short_image_ref', 125\n    )\n    inlinePatterns.register(AutolinkInlineProcessor(AUTOLINK_RE, md), 'autolink', 120)\n    inlinePatterns.register(AutomailInlineProcessor(AUTOMAIL_RE, md), 'automail', 110)\n    inlinePatterns.register(SubstituteTagInlineProcessor(LINE_BREAK_RE, 'br'), 'linebreak', 100)\n    inlinePatterns.register(HtmlInlineProcessor(HTML_RE, md), 'html', 90)\n    inlinePatterns.register(HtmlInlineProcessor(ENTITY_RE, md), 'entity', 80)\n    inlinePatterns.register(SimpleTextInlineProcessor(NOT_STRONG_RE), 'not_strong', 70)\n    inlinePatterns.register(AsteriskProcessor(r'\\*'), 'em_strong', 60)\n    inlinePatterns.register(UnderscoreProcessor(r'_'), 'em_strong2', 50)\n    return inlinePatterns\n\n\n# The actual regular expressions for patterns\n# -----------------------------------------------------------------------------\n\nNOIMG = r'(?<!\\!)'\n\"\"\" Match not an image. Partial regular expression which matches if not preceded by `!`. \"\"\"\n\nBACKTICK_RE = r'(?:(?<!\\\\)((?:\\\\{2})+)(?=`+)|(?<!\\\\)(`+)(.+?)(?<!`)\\2(?!`))'\n\"\"\" Match backtick quoted string (`` `e=f()` `` or ``` ``e=f(\"`\")`` ```). \"\"\"\n\nESCAPE_RE = r'\\\\(.)'\n\"\"\" Match a backslash escaped character (`\\\\<` or `\\\\*`). \"\"\"\n\nEMPHASIS_RE = r'(\\*)([^\\*]+)\\1'\n\"\"\" Match emphasis with an asterisk (`*emphasis*`). \"\"\"\n\nSTRONG_RE = r'(\\*{2})(.+?)\\1'\n\"\"\" Match strong with an asterisk (`**strong**`). \"\"\"\n\nSMART_STRONG_RE = r'(?<!\\w)(_{2})(?!_)(.+?)(?<!_)\\1(?!\\w)'\n\"\"\" Match strong with underscore while ignoring middle word underscores (`__smart__strong__`). \"\"\"\n\nSMART_EMPHASIS_RE = r'(?<!\\w)(_)(?!_)(.+?)(?<!_)\\1(?!\\w)'\n\"\"\" Match emphasis with underscore while ignoring middle word underscores (`_smart_emphasis_`). \"\"\"\n\nSMART_STRONG_EM_RE = r'(?<!\\w)(\\_)\\1(?!\\1)(.+?)(?<!\\w)\\1(?!\\1)(.+?)\\1{3}(?!\\w)'\n\"\"\" Match strong emphasis with underscores (`__strong _em__`). \"\"\"\n\nEM_STRONG_RE = r'(\\*)\\1{2}(.+?)\\1(.*?)\\1{2}'\n\"\"\" Match emphasis strong with asterisk (`***strongem***` or `***em*strong**`). \"\"\"\n\nEM_STRONG2_RE = r'(_)\\1{2}(.+?)\\1(.*?)\\1{2}'\n\"\"\" Match emphasis strong with underscores (`___emstrong___` or `___em_strong__`). \"\"\"\n\nSTRONG_EM_RE = r'(\\*)\\1{2}(.+?)\\1{2}(.*?)\\1'\n\"\"\" Match strong emphasis with asterisk (`***strong**em*`). \"\"\"\n\nSTRONG_EM2_RE = r'(_)\\1{2}(.+?)\\1{2}(.*?)\\1'\n\"\"\" Match strong emphasis with underscores (`___strong__em_`). \"\"\"\n\nSTRONG_EM3_RE = r'(\\*)\\1(?!\\1)([^*]+?)\\1(?!\\1)(.+?)\\1{3}'\n\"\"\" Match strong emphasis with asterisk (`**strong*em***`). \"\"\"\n\nLINK_RE = NOIMG + r'\\['\n\"\"\" Match start of in-line link (`[text](url)` or `[text](<url>)` or `[text](url \"title\")`). \"\"\"\n\nIMAGE_LINK_RE = r'\\!\\['\n\"\"\" Match start of in-line image link (`![alttxt](url)` or `![alttxt](<url>)`). \"\"\"\n\nREFERENCE_RE = LINK_RE\n\"\"\" Match start of reference link (`[Label][3]`). \"\"\"\n\nIMAGE_REFERENCE_RE = IMAGE_LINK_RE\n\"\"\" Match start of image reference (`![alt text][2]`). \"\"\"\n\nNOT_STRONG_RE = r'((^|(?<=\\s))(\\*{1,3}|_{1,3})(?=\\s|$))'\n\"\"\" Match a stand-alone `*` or `_`. \"\"\"\n\nAUTOLINK_RE = r'<((?:[Ff]|[Hh][Tt])[Tt][Pp][Ss]?://[^<>]*)>'\n\"\"\" Match an automatic link (`<http://www.example.com>`). \"\"\"\n\nAUTOMAIL_RE = r'<([^<> !]+@[^@<> ]+)>'\n\"\"\" Match an automatic email link (`<me@example.com>`). \"\"\"\n\nHTML_RE = (\n    r'(<(\\/?[a-zA-Z][^<>@ ]*( [^<>]*)?|'          # Tag\n    r'!--(?:(?!<!--|-->).)*--|'                   # Comment\n    r'[?](?:(?!<[?]|[?]>).)*[?]|'                 # Processing instruction\n    r'!\\[CDATA\\[(?:(?!<!\\[CDATA\\[|\\]\\]>).)*\\]\\]'  # `CDATA`\n    ')>)'\n)\n\"\"\" Match an HTML tag (`<...>`). \"\"\"\n\nENTITY_RE = r'(&(?:\\#[0-9]+|\\#x[0-9a-fA-F]+|[a-zA-Z0-9]+);)'\n\"\"\" Match an HTML entity (`&#38;` (decimal) or `&#x26;` (hex) or `&amp;` (named)). \"\"\"\n\nLINE_BREAK_RE = r'  \\n'\n\"\"\" Match two spaces at end of line. \"\"\"\n\n\ndef dequote(string: str) -> str:\n    \"\"\"Remove quotes from around a string.\"\"\"\n    if ((string.startswith('\"') and string.endswith('\"')) or\n       (string.startswith(\"'\") and string.endswith(\"'\"))):\n        return string[1:-1]\n    else:\n        return string\n\n\nclass EmStrongItem(NamedTuple):\n    \"\"\"Emphasis/strong pattern item.\"\"\"\n    pattern: re.Pattern[str]\n    builder: str\n    tags: str\n\n\n# The pattern classes\n# -----------------------------------------------------------------------------\n\n\nclass Pattern:  # pragma: no cover\n    \"\"\"\n    Base class that inline patterns subclass.\n\n    Inline patterns are handled by means of `Pattern` subclasses, one per regular expression.\n    Each pattern object uses a single regular expression and must support the following methods:\n    [`getCompiledRegExp`][markdown.inlinepatterns.Pattern.getCompiledRegExp] and\n    [`handleMatch`][markdown.inlinepatterns.Pattern.handleMatch].\n\n    All the regular expressions used by `Pattern` subclasses must capture the whole block.  For this\n    reason, they all start with `^(.*)` and end with `(.*)!`.  When passing a regular expression on\n    class initialization, the `^(.*)` and `(.*)!` are added automatically and the regular expression\n    is pre-compiled.\n\n    It is strongly suggested that the newer style [`markdown.inlinepatterns.InlineProcessor`][] that\n    use a more efficient and flexible search approach be used instead. However, the older style\n    `Pattern` remains for backward compatibility with many existing third-party extensions.\n\n    \"\"\"\n\n    ANCESTOR_EXCLUDES: Collection[str] = tuple()\n    \"\"\"\n    A collection of elements which are undesirable ancestors. The processor will be skipped if it\n    would cause the content to be a descendant of one of the listed tag names.\n    \"\"\"\n\n    compiled_re: re.Pattern[str]\n    md: Markdown | None\n\n    def __init__(self, pattern: str, md: Markdown | None = None):\n        \"\"\"\n        Create an instant of an inline pattern.\n\n        Arguments:\n            pattern: A regular expression that matches a pattern.\n            md: An optional pointer to the instance of `markdown.Markdown` and is available as\n                `self.md` on the class instance.\n\n\n        \"\"\"\n        self.pattern = pattern\n        self.compiled_re = re.compile(r\"^(.*?)%s(.*)$\" % pattern,\n                                      re.DOTALL | re.UNICODE)\n\n        self.md = md\n\n    def getCompiledRegExp(self) -> re.Pattern:\n        \"\"\" Return a compiled regular expression. \"\"\"\n        return self.compiled_re\n\n    def handleMatch(self, m: re.Match[str]) -> etree.Element | str:\n        \"\"\"Return a ElementTree element from the given match.\n\n        Subclasses should override this method.\n\n        Arguments:\n            m: A match object containing a match of the pattern.\n\n        Returns: An ElementTree Element object.\n\n        \"\"\"\n        pass  # pragma: no cover\n\n    def type(self) -> str:\n        \"\"\" Return class name, to define pattern type \"\"\"\n        return self.__class__.__name__\n\n    def unescape(self, text: str) -> str:\n        \"\"\" Return unescaped text given text with an inline placeholder. \"\"\"\n        try:\n            stash = self.md.treeprocessors['inline'].stashed_nodes\n        except KeyError:  # pragma: no cover\n            return text\n\n        def get_stash(m):\n            id = m.group(1)\n            if id in stash:\n                value = stash.get(id)\n                if isinstance(value, str):\n                    return value\n                else:\n                    # An `etree` Element - return text content only\n                    return ''.join(value.itertext())\n        return util.INLINE_PLACEHOLDER_RE.sub(get_stash, text)\n\n\nclass InlineProcessor(Pattern):\n    \"\"\"\n    Base class that inline processors subclass.\n\n    This is the newer style inline processor that uses a more\n    efficient and flexible search approach.\n\n    \"\"\"\n\n    def __init__(self, pattern: str, md: Markdown | None = None):\n        \"\"\"\n        Create an instant of an inline processor.\n\n        Arguments:\n            pattern: A regular expression that matches a pattern.\n            md: An optional pointer to the instance of `markdown.Markdown` and is available as\n                `self.md` on the class instance.\n\n        \"\"\"\n        self.pattern = pattern\n        self.compiled_re = re.compile(pattern, re.DOTALL | re.UNICODE)\n\n        # API for Markdown to pass `safe_mode` into instance\n        self.safe_mode = False\n        self.md = md\n\n    def handleMatch(self, m: re.Match[str], data: str) -> tuple[etree.Element | str | None, int | None, int | None]:\n        \"\"\"Return a ElementTree element from the given match and the\n        start and end index of the matched text.\n\n        If `start` and/or `end` are returned as `None`, it will be\n        assumed that the processor did not find a valid region of text.\n\n        Subclasses should override this method.\n\n        Arguments:\n            m: A re match object containing a match of the pattern.\n            data: The buffer currently under analysis.\n\n        Returns:\n            el: The ElementTree element, text or None.\n            start: The start of the region that has been matched or None.\n            end: The end of the region that has been matched or None.\n\n        \"\"\"\n        pass  # pragma: no cover\n\n\nclass SimpleTextPattern(Pattern):  # pragma: no cover\n    \"\"\" Return a simple text of `group(2)` of a Pattern. \"\"\"\n    def handleMatch(self, m: re.Match[str]) -> str:\n        \"\"\" Return string content of `group(2)` of a matching pattern. \"\"\"\n        return m.group(2)\n\n\nclass SimpleTextInlineProcessor(InlineProcessor):\n    \"\"\" Return a simple text of `group(1)` of a Pattern. \"\"\"\n    def handleMatch(self, m: re.Match[str], data: str) -> tuple[str, int, int]:\n        \"\"\" Return string content of `group(1)` of a matching pattern. \"\"\"\n        return m.group(1), m.start(0), m.end(0)\n\n\nclass EscapeInlineProcessor(InlineProcessor):\n    \"\"\" Return an escaped character. \"\"\"\n\n    def handleMatch(self, m: re.Match[str], data: str) -> tuple[str | None, int, int]:\n        \"\"\"\n        If the character matched by `group(1)` of a pattern is in [`ESCAPED_CHARS`][markdown.Markdown.ESCAPED_CHARS]\n        then return the integer representing the character's Unicode code point (as returned by [`ord`][]) wrapped\n        in [`util.STX`][markdown.util.STX] and [`util.ETX`][markdown.util.ETX].\n\n        If the matched character is not in [`ESCAPED_CHARS`][markdown.Markdown.ESCAPED_CHARS], then return `None`.\n        \"\"\"\n\n        char = m.group(1)\n        if char in self.md.ESCAPED_CHARS:\n            return '{}{}{}'.format(util.STX, ord(char), util.ETX), m.start(0), m.end(0)\n        else:\n            return None, m.start(0), m.end(0)\n\n\nclass SimpleTagPattern(Pattern):  # pragma: no cover\n    \"\"\"\n    Return element of type `tag` with a text attribute of `group(3)`\n    of a Pattern.\n\n    \"\"\"\n    def __init__(self, pattern: str, tag: str):\n        \"\"\"\n        Create an instant of an simple tag pattern.\n\n        Arguments:\n            pattern: A regular expression that matches a pattern.\n            tag: Tag of element.\n\n        \"\"\"\n        Pattern.__init__(self, pattern)\n        self.tag = tag\n        \"\"\" The tag of the rendered element. \"\"\"\n\n    def handleMatch(self, m: re.Match[str]) -> etree.Element:\n        \"\"\"\n        Return [`Element`][xml.etree.ElementTree.Element] of type `tag` with the string in `group(3)` of a\n        matching pattern as the Element's text.\n        \"\"\"\n        el = etree.Element(self.tag)\n        el.text = m.group(3)\n        return el\n\n\nclass SimpleTagInlineProcessor(InlineProcessor):\n    \"\"\"\n    Return element of type `tag` with a text attribute of `group(2)`\n    of a Pattern.\n\n    \"\"\"\n    def __init__(self, pattern: str, tag: str):\n        \"\"\"\n        Create an instant of an simple tag processor.\n\n        Arguments:\n            pattern: A regular expression that matches a pattern.\n            tag: Tag of element.\n\n        \"\"\"\n        InlineProcessor.__init__(self, pattern)\n        self.tag = tag\n        \"\"\" The tag of the rendered element. \"\"\"\n\n    def handleMatch(self, m: re.Match[str], data: str) -> tuple[etree.Element, int, int]:  # pragma: no cover\n        \"\"\"\n        Return [`Element`][xml.etree.ElementTree.Element] of type `tag` with the string in `group(2)` of a\n        matching pattern as the Element's text.\n        \"\"\"\n        el = etree.Element(self.tag)\n        el.text = m.group(2)\n        return el, m.start(0), m.end(0)\n\n\nclass SubstituteTagPattern(SimpleTagPattern):  # pragma: no cover\n    \"\"\" Return an element of type `tag` with no children. \"\"\"\n    def handleMatch(self, m: re.Match[str]) -> etree.Element:\n        \"\"\" Return empty [`Element`][xml.etree.ElementTree.Element] of type `tag`. \"\"\"\n        return etree.Element(self.tag)\n\n\nclass SubstituteTagInlineProcessor(SimpleTagInlineProcessor):\n    \"\"\" Return an element of type `tag` with no children. \"\"\"\n    def handleMatch(self, m: re.Match[str], data: str) -> tuple[etree.Element, int, int]:\n        \"\"\" Return empty [`Element`][xml.etree.ElementTree.Element] of type `tag`. \"\"\"\n        return etree.Element(self.tag), m.start(0), m.end(0)\n\n\nclass BacktickInlineProcessor(InlineProcessor):\n    \"\"\" Return a `<code>` element containing the escaped matching text. \"\"\"\n    def __init__(self, pattern: str):\n        InlineProcessor.__init__(self, pattern)\n        self.ESCAPED_BSLASH = '{}{}{}'.format(util.STX, ord('\\\\'), util.ETX)\n        self.tag = 'code'\n        \"\"\" The tag of the rendered element. \"\"\"\n\n    def handleMatch(self, m: re.Match[str], data: str) -> tuple[etree.Element | str, int, int]:\n        \"\"\"\n        If the match contains `group(3)` of a pattern, then return a `code`\n        [`Element`][xml.etree.ElementTree.Element] which contains HTML escaped text (with\n        [`code_escape`][markdown.util.code_escape]) as an [`AtomicString`][markdown.util.AtomicString].\n\n        If the match does not contain `group(3)` then return the text of `group(1)` backslash escaped.\n\n        \"\"\"\n        if m.group(3):\n            el = etree.Element(self.tag)\n            el.text = util.AtomicString(util.code_escape(m.group(3).strip()))\n            return el, m.start(0), m.end(0)\n        else:\n            return m.group(1).replace('\\\\\\\\', self.ESCAPED_BSLASH), m.start(0), m.end(0)\n\n\nclass DoubleTagPattern(SimpleTagPattern):  # pragma: no cover\n    \"\"\"Return a ElementTree element nested in tag2 nested in tag1.\n\n    Useful for strong emphasis etc.\n\n    \"\"\"\n    def handleMatch(self, m: re.Match[str]) -> etree.Element:\n        \"\"\"\n        Return [`Element`][xml.etree.ElementTree.Element] in following format:\n        `<tag1><tag2>group(3)</tag2>group(4)</tag2>` where `group(4)` is optional.\n\n        \"\"\"\n        tag1, tag2 = self.tag.split(\",\")\n        el1 = etree.Element(tag1)\n        el2 = etree.SubElement(el1, tag2)\n        el2.text = m.group(3)\n        if len(m.groups()) == 5:\n            el2.tail = m.group(4)\n        return el1\n\n\nclass DoubleTagInlineProcessor(SimpleTagInlineProcessor):\n    \"\"\"Return a ElementTree element nested in tag2 nested in tag1.\n\n    Useful for strong emphasis etc.\n\n    \"\"\"\n    def handleMatch(self, m: re.Match[str], data: str) -> tuple[etree.Element, int, int]:  # pragma: no cover\n        \"\"\"\n        Return [`Element`][xml.etree.ElementTree.Element] in following format:\n        `<tag1><tag2>group(2)</tag2>group(3)</tag2>` where `group(3)` is optional.\n\n        \"\"\"\n        tag1, tag2 = self.tag.split(\",\")\n        el1 = etree.Element(tag1)\n        el2 = etree.SubElement(el1, tag2)\n        el2.text = m.group(2)\n        if len(m.groups()) == 3:\n            el2.tail = m.group(3)\n        return el1, m.start(0), m.end(0)\n\n\nclass HtmlInlineProcessor(InlineProcessor):\n    \"\"\" Store raw inline html and return a placeholder. \"\"\"\n    def handleMatch(self, m: re.Match[str], data: str) -> tuple[str, int, int]:\n        \"\"\" Store the text of `group(1)` of a pattern and return a placeholder string. \"\"\"\n        rawhtml = self.backslash_unescape(self.unescape(m.group(1)))\n        place_holder = self.md.htmlStash.store(rawhtml)\n        return place_holder, m.start(0), m.end(0)\n\n    def unescape(self, text: str) -> str:\n        \"\"\" Return unescaped text given text with an inline placeholder. \"\"\"\n        try:\n            stash = self.md.treeprocessors['inline'].stashed_nodes\n        except KeyError:  # pragma: no cover\n            return text\n\n        def get_stash(m: re.Match[str]) -> str:\n            id = m.group(1)\n            value = stash.get(id)\n            if value is not None:\n                try:\n                    return self.md.serializer(value)\n                except Exception:\n                    return r'\\%s' % value\n\n        return util.INLINE_PLACEHOLDER_RE.sub(get_stash, text)\n\n    def backslash_unescape(self, text: str) -> str:\n        \"\"\" Return text with backslash escapes undone (backslashes are restored). \"\"\"\n        try:\n            RE = self.md.treeprocessors['unescape'].RE\n        except KeyError:  # pragma: no cover\n            return text\n\n        def _unescape(m: re.Match[str]) -> str:\n            return chr(int(m.group(1)))\n\n        return RE.sub(_unescape, text)\n\n\nclass AsteriskProcessor(InlineProcessor):\n    \"\"\"Emphasis processor for handling strong and em matches inside asterisks.\"\"\"\n\n    PATTERNS = [\n        EmStrongItem(re.compile(EM_STRONG_RE, re.DOTALL | re.UNICODE), 'double', 'strong,em'),\n        EmStrongItem(re.compile(STRONG_EM_RE, re.DOTALL | re.UNICODE), 'double', 'em,strong'),\n        EmStrongItem(re.compile(STRONG_EM3_RE, re.DOTALL | re.UNICODE), 'double2', 'strong,em'),\n        EmStrongItem(re.compile(STRONG_RE, re.DOTALL | re.UNICODE), 'single', 'strong'),\n        EmStrongItem(re.compile(EMPHASIS_RE, re.DOTALL | re.UNICODE), 'single', 'em')\n    ]\n    \"\"\" The various strong and emphasis patterns handled by this processor. \"\"\"\n\n    def build_single(self, m: re.Match[str], tag: str, idx: int) -> etree.Element:\n        \"\"\"Return single tag.\"\"\"\n        el1 = etree.Element(tag)\n        text = m.group(2)\n        self.parse_sub_patterns(text, el1, None, idx)\n        return el1\n\n    def build_double(self, m: re.Match[str], tags: str, idx: int) -> etree.Element:\n        \"\"\"Return double tag.\"\"\"\n\n        tag1, tag2 = tags.split(\",\")\n        el1 = etree.Element(tag1)\n        el2 = etree.Element(tag2)\n        text = m.group(2)\n        self.parse_sub_patterns(text, el2, None, idx)\n        el1.append(el2)\n        if len(m.groups()) == 3:\n            text = m.group(3)\n            self.parse_sub_patterns(text, el1, el2, idx)\n        return el1\n\n    def build_double2(self, m: re.Match[str], tags: str, idx: int) -> etree.Element:\n        \"\"\"Return double tags (variant 2): `<strong>text <em>text</em></strong>`.\"\"\"\n\n        tag1, tag2 = tags.split(\",\")\n        el1 = etree.Element(tag1)\n        el2 = etree.Element(tag2)\n        text = m.group(2)\n        self.parse_sub_patterns(text, el1, None, idx)\n        text = m.group(3)\n        el1.append(el2)\n        self.parse_sub_patterns(text, el2, None, idx)\n        return el1\n\n    def parse_sub_patterns(\n        self, data: str, parent: etree.Element, last: etree.Element | None, idx: int\n    ) -> None:\n        \"\"\"\n        Parses sub patterns.\n\n        `data`: text to evaluate.\n\n        `parent`: Parent to attach text and sub elements to.\n\n        `last`: Last appended child to parent. Can also be None if parent has no children.\n\n        `idx`: Current pattern index that was used to evaluate the parent.\n        \"\"\"\n\n        offset = 0\n        pos = 0\n\n        length = len(data)\n        while pos < length:\n            # Find the start of potential emphasis or strong tokens\n            if self.compiled_re.match(data, pos):\n                matched = False\n                # See if the we can match an emphasis/strong pattern\n                for index, item in enumerate(self.PATTERNS):\n                    # Only evaluate patterns that are after what was used on the parent\n                    if index <= idx:\n                        continue\n                    m = item.pattern.match(data, pos)\n                    if m:\n                        # Append child nodes to parent\n                        # Text nodes should be appended to the last\n                        # child if present, and if not, it should\n                        # be added as the parent's text node.\n                        text = data[offset:m.start(0)]\n                        if text:\n                            if last is not None:\n                                last.tail = text\n                            else:\n                                parent.text = text\n                        el = self.build_element(m, item.builder, item.tags, index)\n                        parent.append(el)\n                        last = el\n                        # Move our position past the matched hunk\n                        offset = pos = m.end(0)\n                        matched = True\n                if not matched:\n                    # We matched nothing, move on to the next character\n                    pos += 1\n            else:\n                # Increment position as no potential emphasis start was found.\n                pos += 1\n\n        # Append any leftover text as a text node.\n        text = data[offset:]\n        if text:\n            if last is not None:\n                last.tail = text\n            else:\n                parent.text = text\n\n    def build_element(self, m: re.Match[str], builder: str, tags: str, index: int) -> etree.Element:\n        \"\"\"Element builder.\"\"\"\n\n        if builder == 'double2':\n            return self.build_double2(m, tags, index)\n        elif builder == 'double':\n            return self.build_double(m, tags, index)\n        else:\n            return self.build_single(m, tags, index)\n\n    def handleMatch(self, m: re.Match[str], data: str) -> tuple[etree.Element | None, int | None, int | None]:\n        \"\"\"Parse patterns.\"\"\"\n\n        el = None\n        start = None\n        end = None\n\n        for index, item in enumerate(self.PATTERNS):\n            m1 = item.pattern.match(data, m.start(0))\n            if m1:\n                start = m1.start(0)\n                end = m1.end(0)\n                el = self.build_element(m1, item.builder, item.tags, index)\n                break\n        return el, start, end\n\n\nclass UnderscoreProcessor(AsteriskProcessor):\n    \"\"\"Emphasis processor for handling strong and em matches inside underscores.\"\"\"\n\n    PATTERNS = [\n        EmStrongItem(re.compile(EM_STRONG2_RE, re.DOTALL | re.UNICODE), 'double', 'strong,em'),\n        EmStrongItem(re.compile(STRONG_EM2_RE, re.DOTALL | re.UNICODE), 'double', 'em,strong'),\n        EmStrongItem(re.compile(SMART_STRONG_EM_RE, re.DOTALL | re.UNICODE), 'double2', 'strong,em'),\n        EmStrongItem(re.compile(SMART_STRONG_RE, re.DOTALL | re.UNICODE), 'single', 'strong'),\n        EmStrongItem(re.compile(SMART_EMPHASIS_RE, re.DOTALL | re.UNICODE), 'single', 'em')\n    ]\n    \"\"\" The various strong and emphasis patterns handled by this processor. \"\"\"\n\n\nclass LinkInlineProcessor(InlineProcessor):\n    \"\"\" Return a link element from the given match. \"\"\"\n    RE_LINK = re.compile(r'''\\(\\s*(?:(<[^<>]*>)\\s*(?:('[^']*'|\"[^\"]*\")\\s*)?\\))?''', re.DOTALL | re.UNICODE)\n    RE_TITLE_CLEAN = re.compile(r'\\s')\n\n    def handleMatch(self, m: re.Match[str], data: str) -> tuple[etree.Element | None, int | None, int | None]:\n        \"\"\" Return an `a` [`Element`][xml.etree.ElementTree.Element] or `(None, None, None)`. \"\"\"\n        text, index, handled = self.getText(data, m.end(0))\n\n        if not handled:\n            return None, None, None\n\n        href, title, index, handled = self.getLink(data, index)\n        if not handled:\n            return None, None, None\n\n        el = etree.Element(\"a\")\n        el.text = text\n\n        el.set(\"href\", href)\n\n        if title is not None:\n            el.set(\"title\", title)\n\n        return el, m.start(0), index\n\n    def getLink(self, data: str, index: int) -> tuple[str, str | None, int, bool]:\n        \"\"\"Parse data between `()` of `[Text]()` allowing recursive `()`. \"\"\"\n\n        href = ''\n        title: str | None = None\n        handled = False\n\n        m = self.RE_LINK.match(data, pos=index)\n        if m and m.group(1):\n            # Matches [Text](<link> \"title\")\n            href = m.group(1)[1:-1].strip()\n            if m.group(2):\n                title = m.group(2)[1:-1]\n            index = m.end(0)\n            handled = True\n        elif m:\n            # Track bracket nesting and index in string\n            bracket_count = 1\n            backtrack_count = 1\n            start_index = m.end()\n            index = start_index\n            last_bracket = -1\n\n            # Primary (first found) quote tracking.\n            quote: str | None = None\n            start_quote = -1\n            exit_quote = -1\n            ignore_matches = False\n\n            # Secondary (second found) quote tracking.\n            alt_quote = None\n            start_alt_quote = -1\n            exit_alt_quote = -1\n\n            # Track last character\n            last = ''\n\n            for pos in range(index, len(data)):\n                c = data[pos]\n                if c == '(':\n                    # Count nested (\n                    # Don't increment the bracket count if we are sure we're in a title.\n                    if not ignore_matches:\n                        bracket_count += 1\n                    elif backtrack_count > 0:\n                        backtrack_count -= 1\n                elif c == ')':\n                    # Match nested ) to (\n                    # Don't decrement if we are sure we are in a title that is unclosed.\n                    if ((exit_quote != -1 and quote == last) or (exit_alt_quote != -1 and alt_quote == last)):\n                        bracket_count = 0\n                    elif not ignore_matches:\n                        bracket_count -= 1\n                    elif backtrack_count > 0:\n                        backtrack_count -= 1\n                        # We've found our backup end location if the title doesn't resolve.\n                        if backtrack_count == 0:\n                            last_bracket = index + 1\n\n                elif c in (\"'\", '\"'):\n                    # Quote has started\n                    if not quote:\n                        # We'll assume we are now in a title.\n                        # Brackets are quoted, so no need to match them (except for the final one).\n                        ignore_matches = True\n                        backtrack_count = bracket_count\n                        bracket_count = 1\n                        start_quote = index + 1\n                        quote = c\n                    # Secondary quote (in case the first doesn't resolve): [text](link'\"title\")\n                    elif c != quote and not alt_quote:\n                        start_alt_quote = index + 1\n                        alt_quote = c\n                    # Update primary quote match\n                    elif c == quote:\n                        exit_quote = index + 1\n                    # Update secondary quote match\n                    elif alt_quote and c == alt_quote:\n                        exit_alt_quote = index + 1\n\n                index += 1\n\n                # Link is closed, so let's break out of the loop\n                if bracket_count == 0:\n                    # Get the title if we closed a title string right before link closed\n                    if exit_quote >= 0 and quote == last:\n                        href = data[start_index:start_quote - 1]\n                        title = ''.join(data[start_quote:exit_quote - 1])\n                    elif exit_alt_quote >= 0 and alt_quote == last:\n                        href = data[start_index:start_alt_quote - 1]\n                        title = ''.join(data[start_alt_quote:exit_alt_quote - 1])\n                    else:\n                        href = data[start_index:index - 1]\n                    break\n\n                if c != ' ':\n                    last = c\n\n            # We have a scenario: `[test](link\"notitle)`\n            # When we enter a string, we stop tracking bracket resolution in the main counter,\n            # but we do keep a backup counter up until we discover where we might resolve all brackets\n            # if the title string fails to resolve.\n            if bracket_count != 0 and backtrack_count == 0:\n                href = data[start_index:last_bracket - 1]\n                index = last_bracket\n                bracket_count = 0\n\n            handled = bracket_count == 0\n\n        if title is not None:\n            title = self.RE_TITLE_CLEAN.sub(' ', dequote(self.unescape(title.strip())))\n\n        href = self.unescape(href).strip()\n\n        return href, title, index, handled\n\n    def getText(self, data: str, index: int) -> tuple[str, int, bool]:\n        \"\"\"Parse the content between `[]` of the start of an image or link\n        resolving nested square brackets.\n\n        \"\"\"\n        bracket_count = 1\n        text = []\n        for pos in range(index, len(data)):\n            c = data[pos]\n            if c == ']':\n                bracket_count -= 1\n            elif c == '[':\n                bracket_count += 1\n            index += 1\n            if bracket_count == 0:\n                break\n            text.append(c)\n        return ''.join(text), index, bracket_count == 0\n\n\nclass ImageInlineProcessor(LinkInlineProcessor):\n    \"\"\" Return a `img` element from the given match. \"\"\"\n\n    def handleMatch(self, m: re.Match[str], data: str) -> tuple[etree.Element | None, int | None, int | None]:\n        \"\"\" Return an `img` [`Element`][xml.etree.ElementTree.Element] or `(None, None, None)`. \"\"\"\n        text, index, handled = self.getText(data, m.end(0))\n        if not handled:\n            return None, None, None\n\n        src, title, index, handled = self.getLink(data, index)\n        if not handled:\n            return None, None, None\n\n        el = etree.Element(\"img\")\n\n        el.set(\"src\", src)\n\n        if title is not None:\n            el.set(\"title\", title)\n\n        el.set('alt', self.unescape(text))\n        return el, m.start(0), index\n\n\nclass ReferenceInlineProcessor(LinkInlineProcessor):\n    \"\"\" Match to a stored reference and return link element. \"\"\"\n    NEWLINE_CLEANUP_RE = re.compile(r'\\s+', re.MULTILINE)\n\n    RE_LINK = re.compile(r'\\s?\\[([^\\]]*)\\]', re.DOTALL | re.UNICODE)\n\n    def handleMatch(self, m: re.Match[str], data: str) -> tuple[etree.Element | None, int | None, int | None]:\n        \"\"\"\n        Return [`Element`][xml.etree.ElementTree.Element] returned by `makeTag` method or `(None, None, None)`.\n\n        \"\"\"\n        text, index, handled = self.getText(data, m.end(0))\n        if not handled:\n            return None, None, None\n\n        id, end, handled = self.evalId(data, index, text)\n        if not handled:\n            return None, None, None\n\n        # Clean up line breaks in id\n        id = self.NEWLINE_CLEANUP_RE.sub(' ', id)\n        if id not in self.md.references:  # ignore undefined refs\n            return None, m.start(0), end\n\n        href, title = self.md.references[id]\n\n        return self.makeTag(href, title, text), m.start(0), end\n\n    def evalId(self, data: str, index: int, text: str) -> tuple[str | None, int, bool]:\n        \"\"\"\n        Evaluate the id portion of `[ref][id]`.\n\n        If `[ref][]` use `[ref]`.\n        \"\"\"\n        m = self.RE_LINK.match(data, pos=index)\n        if not m:\n            return None, index, False\n        else:\n            id = m.group(1).lower()\n            end = m.end(0)\n            if not id:\n                id = text.lower()\n        return id, end, True\n\n    def makeTag(self, href: str, title: str, text: str) -> etree.Element:\n        \"\"\" Return an `a` [`Element`][xml.etree.ElementTree.Element]. \"\"\"\n        el = etree.Element('a')\n\n        el.set('href', href)\n        if title:\n            el.set('title', title)\n\n        el.text = text\n        return el\n\n\nclass ShortReferenceInlineProcessor(ReferenceInlineProcessor):\n    \"\"\"Short form of reference: `[google]`. \"\"\"\n    def evalId(self, data: str, index: int, text: str) -> tuple[str, int, bool]:\n        \"\"\"Evaluate the id of `[ref]`.  \"\"\"\n\n        return text.lower(), index, True\n\n\nclass ImageReferenceInlineProcessor(ReferenceInlineProcessor):\n    \"\"\" Match to a stored reference and return `img` element. \"\"\"\n    def makeTag(self, href: str, title: str, text: str) -> etree.Element:\n        \"\"\" Return an `img` [`Element`][xml.etree.ElementTree.Element]. \"\"\"\n        el = etree.Element(\"img\")\n        el.set(\"src\", href)\n        if title:\n            el.set(\"title\", title)\n        el.set(\"alt\", self.unescape(text))\n        return el\n\n\nclass ShortImageReferenceInlineProcessor(ImageReferenceInlineProcessor):\n    \"\"\" Short form of image reference: `![ref]`. \"\"\"\n    def evalId(self, data: str, index: int, text: str) -> tuple[str, int, bool]:\n        \"\"\"Evaluate the id of `[ref]`.  \"\"\"\n\n        return text.lower(), index, True\n\n\nclass AutolinkInlineProcessor(InlineProcessor):\n    \"\"\" Return a link Element given an auto-link (`<http://example/com>`). \"\"\"\n    def handleMatch(self, m: re.Match[str], data: str) -> tuple[etree.Element, int, int]:\n        \"\"\" Return an `a` [`Element`][xml.etree.ElementTree.Element] of `group(1)`. \"\"\"\n        el = etree.Element(\"a\")\n        el.set('href', self.unescape(m.group(1)))\n        el.text = util.AtomicString(m.group(1))\n        return el, m.start(0), m.end(0)\n\n\nclass AutomailInlineProcessor(InlineProcessor):\n    \"\"\"\n    Return a `mailto` link Element given an auto-mail link (`<foo@example.com>`).\n    \"\"\"\n    def handleMatch(self, m: re.Match[str], data: str) -> tuple[etree.Element, int, int]:\n        \"\"\" Return an [`Element`][xml.etree.ElementTree.Element] containing a `mailto` link  of `group(1)`. \"\"\"\n        el = etree.Element('a')\n        email = self.unescape(m.group(1))\n        if email.startswith(\"mailto:\"):\n            email = email[len(\"mailto:\"):]\n\n        def codepoint2name(code: int) -> str:\n            \"\"\"Return entity definition by code, or the code if not defined.\"\"\"\n            entity = entities.codepoint2name.get(code)\n            if entity:\n                return \"{}{};\".format(util.AMP_SUBSTITUTE, entity)\n            else:\n                return \"%s#%d;\" % (util.AMP_SUBSTITUTE, code)\n\n        letters = [codepoint2name(ord(letter)) for letter in email]\n        el.text = util.AtomicString(''.join(letters))\n\n        mailto = \"mailto:\" + email\n        mailto = \"\".join([util.AMP_SUBSTITUTE + '#%d;' %\n                          ord(letter) for letter in mailto])\n        el.set('href', mailto)\n        return el, m.start(0), m.end(0)\n","size_bytes":38458},"markdown/postprocessors.py":{"content":"# Python Markdown\n\n# A Python implementation of John Gruber's Markdown.\n\n# Documentation: https://python-markdown.github.io/\n# GitHub: https://github.com/Python-Markdown/markdown/\n# PyPI: https://pypi.org/project/Markdown/\n\n# Started by Manfred Stienstra (http://www.dwerg.net/).\n# Maintained for a few years by Yuri Takhteyev (http://www.freewisdom.org).\n# Currently maintained by Waylan Limberg (https://github.com/waylan),\n# Dmitry Shachnev (https://github.com/mitya57) and Isaac Muse (https://github.com/facelessuser).\n\n# Copyright 2007-2023 The Python Markdown Project (v. 1.7 and later)\n# Copyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b)\n# Copyright 2004 Manfred Stienstra (the original version)\n\n# License: BSD (see LICENSE.md for details).\n\n\"\"\"\n\nPost-processors run on the text of the entire document after is has been serialized into a string.\nPostprocessors should be used to work with the text just before output. Usually, they are used add\nback sections that were extracted in a preprocessor, fix up outgoing encodings, or wrap the whole\ndocument.\n\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING, Any\nfrom . import util\nimport re\n\nif TYPE_CHECKING:  # pragma: no cover\n    from markdown import Markdown\n\n\ndef build_postprocessors(md: Markdown, **kwargs: Any) -> util.Registry[Postprocessor]:\n    \"\"\" Build the default postprocessors for Markdown. \"\"\"\n    postprocessors = util.Registry()\n    postprocessors.register(RawHtmlPostprocessor(md), 'raw_html', 30)\n    postprocessors.register(AndSubstitutePostprocessor(), 'amp_substitute', 20)\n    return postprocessors\n\n\nclass Postprocessor(util.Processor):\n    \"\"\"\n    Postprocessors are run after the ElementTree it converted back into text.\n\n    Each Postprocessor implements a `run` method that takes a pointer to a\n    text string, modifies it as necessary and returns a text string.\n\n    Postprocessors must extend `Postprocessor`.\n\n    \"\"\"\n\n    def run(self, text: str) -> str:\n        \"\"\"\n        Subclasses of `Postprocessor` should implement a `run` method, which\n        takes the html document as a single text string and returns a\n        (possibly modified) string.\n\n        \"\"\"\n        pass  # pragma: no cover\n\n\nclass RawHtmlPostprocessor(Postprocessor):\n    \"\"\" Restore raw html to the document. \"\"\"\n\n    BLOCK_LEVEL_REGEX = re.compile(r'^\\<\\/?([^ >]+)')\n\n    def run(self, text: str) -> str:\n        \"\"\" Iterate over html stash and restore html. \"\"\"\n        def substitute_match(m: re.Match[str]) -> str:\n            if key := m.group(1):\n                wrapped = True\n            else:\n                key = m.group(2)\n                wrapped = False\n            if (key := int(key)) >= self.md.htmlStash.html_counter:\n                return m.group(0)\n            html = self.stash_to_string(self.md.htmlStash.rawHtmlBlocks[key])\n            if not wrapped or self.isblocklevel(html):\n                return pattern.sub(substitute_match, html)\n            return pattern.sub(substitute_match, f\"<p>{html}</p>\")\n\n        if self.md.htmlStash.html_counter:\n            base_placeholder = util.HTML_PLACEHOLDER % r'([0-9]+)'\n            pattern = re.compile(f'<p>{ base_placeholder }</p>|{ base_placeholder }')\n            return pattern.sub(substitute_match, text)\n        else:\n            return text\n\n    def isblocklevel(self, html: str) -> bool:\n        \"\"\" Check is block of HTML is block-level. \"\"\"\n        m = self.BLOCK_LEVEL_REGEX.match(html)\n        if m:\n            if m.group(1)[0] in ('!', '?', '@', '%'):\n                # Comment, PHP etc...\n                return True\n            return self.md.is_block_level(m.group(1))\n        return False\n\n    def stash_to_string(self, text: str) -> str:\n        \"\"\" Convert a stashed object to a string. \"\"\"\n        return str(text)\n\n\nclass AndSubstitutePostprocessor(Postprocessor):\n    \"\"\" Restore valid entities \"\"\"\n\n    def run(self, text: str) -> str:\n        text = text.replace(util.AMP_SUBSTITUTE, \"&\")\n        return text\n\n\n@util.deprecated(\n    \"This class is deprecated and will be removed in the future; \"\n    \"use [`UnescapeTreeprocessor`][markdown.treeprocessors.UnescapeTreeprocessor] instead.\"\n)\nclass UnescapePostprocessor(Postprocessor):\n    \"\"\" Restore escaped chars. \"\"\"\n\n    RE = re.compile(r'{}(\\d+){}'.format(util.STX, util.ETX))\n\n    def unescape(self, m: re.Match[str]) -> str:\n        return chr(int(m.group(1)))\n\n    def run(self, text: str) -> str:\n        return self.RE.sub(self.unescape, text)\n","size_bytes":4493},"markdown/preprocessors.py":{"content":"# Python Markdown\n\n# A Python implementation of John Gruber's Markdown.\n\n# Documentation: https://python-markdown.github.io/\n# GitHub: https://github.com/Python-Markdown/markdown/\n# PyPI: https://pypi.org/project/Markdown/\n\n# Started by Manfred Stienstra (http://www.dwerg.net/).\n# Maintained for a few years by Yuri Takhteyev (http://www.freewisdom.org).\n# Currently maintained by Waylan Limberg (https://github.com/waylan),\n# Dmitry Shachnev (https://github.com/mitya57) and Isaac Muse (https://github.com/facelessuser).\n\n# Copyright 2007-2023 The Python Markdown Project (v. 1.7 and later)\n# Copyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b)\n# Copyright 2004 Manfred Stienstra (the original version)\n\n# License: BSD (see LICENSE.md for details).\n\n\"\"\"\nPreprocessors work on source text before it is broken down into its individual parts.\nThis is an excellent place to clean up bad characters or to extract portions for later\nprocessing that the parser may otherwise choke on.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING, Any\nfrom . import util\nfrom .htmlparser import HTMLExtractor\nimport re\n\nif TYPE_CHECKING:  # pragma: no cover\n    from markdown import Markdown\n\n\ndef build_preprocessors(md: Markdown, **kwargs: Any) -> util.Registry[Preprocessor]:\n    \"\"\" Build and return the default set of preprocessors used by Markdown. \"\"\"\n    preprocessors = util.Registry()\n    preprocessors.register(NormalizeWhitespace(md), 'normalize_whitespace', 30)\n    preprocessors.register(HtmlBlockPreprocessor(md), 'html_block', 20)\n    return preprocessors\n\n\nclass Preprocessor(util.Processor):\n    \"\"\"\n    Preprocessors are run after the text is broken into lines.\n\n    Each preprocessor implements a `run` method that takes a pointer to a\n    list of lines of the document, modifies it as necessary and returns\n    either the same pointer or a pointer to a new list.\n\n    Preprocessors must extend `Preprocessor`.\n\n    \"\"\"\n    def run(self, lines: list[str]) -> list[str]:\n        \"\"\"\n        Each subclass of `Preprocessor` should override the `run` method, which\n        takes the document as a list of strings split by newlines and returns\n        the (possibly modified) list of lines.\n\n        \"\"\"\n        pass  # pragma: no cover\n\n\nclass NormalizeWhitespace(Preprocessor):\n    \"\"\" Normalize whitespace for consistent parsing. \"\"\"\n\n    def run(self, lines: list[str]) -> list[str]:\n        source = '\\n'.join(lines)\n        source = source.replace(util.STX, \"\").replace(util.ETX, \"\")\n        source = source.replace(\"\\r\\n\", \"\\n\").replace(\"\\r\", \"\\n\") + \"\\n\\n\"\n        source = source.expandtabs(self.md.tab_length)\n        source = re.sub(r'(?<=\\n) +\\n', '\\n', source)\n        return source.split('\\n')\n\n\nclass HtmlBlockPreprocessor(Preprocessor):\n    \"\"\"\n    Remove html blocks from the text and store them for later retrieval.\n\n    The raw HTML is stored in the [`htmlStash`][markdown.util.HtmlStash] of the\n    [`Markdown`][markdown.Markdown] instance.\n    \"\"\"\n\n    def run(self, lines: list[str]) -> list[str]:\n        source = '\\n'.join(lines)\n        parser = HTMLExtractor(self.md)\n        parser.feed(source)\n        parser.close()\n        return ''.join(parser.cleandoc).split('\\n')\n","size_bytes":3224},"markdown/serializers.py":{"content":"# Add x/html serialization to `Elementree`\n# Taken from ElementTree 1.3 preview with slight modifications\n#\n# Copyright (c) 1999-2007 by Fredrik Lundh.  All rights reserved.\n#\n# fredrik@pythonware.com\n# https://www.pythonware.com/\n#\n# --------------------------------------------------------------------\n# The ElementTree toolkit is\n#\n# Copyright (c) 1999-2007 by Fredrik Lundh\n#\n# By obtaining, using, and/or copying this software and/or its\n# associated documentation, you agree that you have read, understood,\n# and will comply with the following terms and conditions:\n#\n# Permission to use, copy, modify, and distribute this software and\n# its associated documentation for any purpose and without fee is\n# hereby granted, provided that the above copyright notice appears in\n# all copies, and that both that copyright notice and this permission\n# notice appear in supporting documentation, and that the name of\n# Secret Labs AB or the author not be used in advertising or publicity\n# pertaining to distribution of the software without specific, written\n# prior permission.\n#\n# SECRET LABS AB AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD\n# TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANT-\n# ABILITY AND FITNESS.  IN NO EVENT SHALL SECRET LABS AB OR THE AUTHOR\n# BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY\n# DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,\n# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS\n# ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE\n# OF THIS SOFTWARE.\n# --------------------------------------------------------------------\n\n\"\"\"\nPython-Markdown provides two serializers which render [`ElementTree.Element`][xml.etree.ElementTree.Element]\nobjects to a string of HTML. Both functions wrap the same underlying code with only a few minor\ndifferences as outlined below:\n\n1. Empty (self-closing) tags are rendered as `<tag>` for HTML and as `<tag />` for XHTML.\n2. Boolean attributes are rendered as `attrname` for HTML and as `attrname=\"attrname\"` for XHTML.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom xml.etree.ElementTree import ProcessingInstruction\nfrom xml.etree.ElementTree import Comment, ElementTree, Element, QName, HTML_EMPTY\nimport re\nfrom typing import Callable, Literal, NoReturn\n\n__all__ = ['to_html_string', 'to_xhtml_string']\n\nRE_AMP = re.compile(r'&(?!(?:\\#[0-9]+|\\#x[0-9a-f]+|[0-9a-z]+);)', re.I)\n\n\ndef _raise_serialization_error(text: str) -> NoReturn:  # pragma: no cover\n    raise TypeError(\n        \"cannot serialize {!r} (type {})\".format(text, type(text).__name__)\n        )\n\n\ndef _escape_cdata(text) -> str:\n    # escape character data\n    try:\n        # it's worth avoiding do-nothing calls for strings that are\n        # shorter than 500 character, or so.  assume that's, by far,\n        # the most common case in most applications.\n        if \"&\" in text:\n            # Only replace & when not part of an entity\n            text = RE_AMP.sub('&amp;', text)\n        if \"<\" in text:\n            text = text.replace(\"<\", \"&lt;\")\n        if \">\" in text:\n            text = text.replace(\">\", \"&gt;\")\n        return text\n    except (TypeError, AttributeError):  # pragma: no cover\n        _raise_serialization_error(text)\n\n\ndef _escape_attrib(text: str) -> str:\n    # escape attribute value\n    try:\n        if \"&\" in text:\n            # Only replace & when not part of an entity\n            text = RE_AMP.sub('&amp;', text)\n        if \"<\" in text:\n            text = text.replace(\"<\", \"&lt;\")\n        if \">\" in text:\n            text = text.replace(\">\", \"&gt;\")\n        if \"\\\"\" in text:\n            text = text.replace(\"\\\"\", \"&quot;\")\n        if \"\\n\" in text:\n            text = text.replace(\"\\n\", \"&#10;\")\n        return text\n    except (TypeError, AttributeError):  # pragma: no cover\n        _raise_serialization_error(text)\n\n\ndef _escape_attrib_html(text: str) -> str:\n    # escape attribute value\n    try:\n        if \"&\" in text:\n            # Only replace & when not part of an entity\n            text = RE_AMP.sub('&amp;', text)\n        if \"<\" in text:\n            text = text.replace(\"<\", \"&lt;\")\n        if \">\" in text:\n            text = text.replace(\">\", \"&gt;\")\n        if \"\\\"\" in text:\n            text = text.replace(\"\\\"\", \"&quot;\")\n        return text\n    except (TypeError, AttributeError):  # pragma: no cover\n        _raise_serialization_error(text)\n\n\ndef _serialize_html(write: Callable[[str], None], elem: Element, format: Literal[\"html\", \"xhtml\"]) -> None:\n    tag = elem.tag\n    text = elem.text\n    if tag is Comment:\n        write(\"<!--%s-->\" % _escape_cdata(text))\n    elif tag is ProcessingInstruction:\n        write(\"<?%s?>\" % _escape_cdata(text))\n    elif tag is None:\n        if text:\n            write(_escape_cdata(text))\n        for e in elem:\n            _serialize_html(write, e, format)\n    else:\n        namespace_uri = None\n        if isinstance(tag, QName):\n            # `QNAME` objects store their data as a string: `{uri}tag`\n            if tag.text[:1] == \"{\":\n                namespace_uri, tag = tag.text[1:].split(\"}\", 1)\n            else:\n                raise ValueError('QName objects must define a tag.')\n        write(\"<\" + tag)\n        items = elem.items()\n        if items:\n            items = sorted(items)  # lexical order\n            for k, v in items:\n                if isinstance(k, QName):\n                    # Assume a text only `QName`\n                    k = k.text\n                if isinstance(v, QName):\n                    # Assume a text only `QName`\n                    v = v.text\n                else:\n                    v = _escape_attrib_html(v)\n                if k == v and format == 'html':\n                    # handle boolean attributes\n                    write(\" %s\" % v)\n                else:\n                    write(' {}=\"{}\"'.format(k, v))\n        if namespace_uri:\n            write(' xmlns=\"%s\"' % (_escape_attrib(namespace_uri)))\n        if format == \"xhtml\" and tag.lower() in HTML_EMPTY:\n            write(\" />\")\n        else:\n            write(\">\")\n            if text:\n                if tag.lower() in [\"script\", \"style\"]:\n                    write(text)\n                else:\n                    write(_escape_cdata(text))\n            for e in elem:\n                _serialize_html(write, e, format)\n            if tag.lower() not in HTML_EMPTY:\n                write(\"</\" + tag + \">\")\n    if elem.tail:\n        write(_escape_cdata(elem.tail))\n\n\ndef _write_html(root: Element, format: Literal[\"html\", \"xhtml\"] = \"html\") -> str:\n    assert root is not None\n    data: list[str] = []\n    write = data.append\n    _serialize_html(write, root, format)\n    return \"\".join(data)\n\n\n# --------------------------------------------------------------------\n# public functions\n\n\ndef to_html_string(element: Element) -> str:\n    \"\"\" Serialize element and its children to a string of HTML5. \"\"\"\n    return _write_html(ElementTree(element).getroot(), format=\"html\")\n\n\ndef to_xhtml_string(element: Element) -> str:\n    \"\"\" Serialize element and its children to a string of XHTML. \"\"\"\n    return _write_html(ElementTree(element).getroot(), format=\"xhtml\")\n","size_bytes":7174},"markdown/test_tools.py":{"content":"# Python Markdown\n\n# A Python implementation of John Gruber's Markdown.\n\n# Documentation: https://python-markdown.github.io/\n# GitHub: https://github.com/Python-Markdown/markdown/\n# PyPI: https://pypi.org/project/Markdown/\n\n# Started by Manfred Stienstra (http://www.dwerg.net/).\n# Maintained for a few years by Yuri Takhteyev (http://www.freewisdom.org).\n# Currently maintained by Waylan Limberg (https://github.com/waylan),\n# Dmitry Shachnev (https://github.com/mitya57) and Isaac Muse (https://github.com/facelessuser).\n\n# Copyright 2007-2023 The Python Markdown Project (v. 1.7 and later)\n# Copyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b)\n# Copyright 2004 Manfred Stienstra (the original version)\n\n# License: BSD (see LICENSE.md for details).\n\n\"\"\" A collection of tools for testing the Markdown code base and extensions. \"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport sys\nimport unittest\nimport textwrap\nfrom typing import Any\nfrom . import markdown, Markdown, util\n\ntry:\n    import tidylib\nexcept ImportError:\n    tidylib = None\n\n__all__ = ['TestCase', 'LegacyTestCase', 'Kwargs']\n\n\nclass TestCase(unittest.TestCase):\n    \"\"\"\n    A [`unittest.TestCase`][] subclass with helpers for testing Markdown output.\n\n    Define `default_kwargs` as a `dict` of keywords to pass to Markdown for each\n    test. The defaults can be overridden on individual tests.\n\n    The `assertMarkdownRenders` method accepts the source text, the expected\n    output, and any keywords to pass to Markdown. The `default_kwargs` are used\n    except where overridden by `kwargs`. The output and expected output are passed\n    to `TestCase.assertMultiLineEqual`. An `AssertionError` is raised with a diff\n    if the actual output does not equal the expected output.\n\n    The `dedent` method is available to dedent triple-quoted strings if\n    necessary.\n\n    In all other respects, behaves as `unittest.TestCase`.\n    \"\"\"\n\n    default_kwargs: dict[str, Any] = {}\n    \"\"\" Default options to pass to Markdown for each test. \"\"\"\n\n    def assertMarkdownRenders(self, source, expected, expected_attrs=None, **kwargs):\n        \"\"\"\n        Test that source Markdown text renders to expected output with given keywords.\n\n        `expected_attrs` accepts a `dict`. Each key should be the name of an attribute\n        on the `Markdown` instance and the value should be the expected value after\n        the source text is parsed by Markdown. After the expected output is tested,\n        the expected value for each attribute is compared against the actual\n        attribute of the `Markdown` instance using `TestCase.assertEqual`.\n        \"\"\"\n\n        expected_attrs = expected_attrs or {}\n        kws = self.default_kwargs.copy()\n        kws.update(kwargs)\n        md = Markdown(**kws)\n        output = md.convert(source)\n        self.assertMultiLineEqual(output, expected)\n        for key, value in expected_attrs.items():\n            self.assertEqual(getattr(md, key), value)\n\n    def dedent(self, text):\n        \"\"\"\n        Dedent text.\n        \"\"\"\n\n        # TODO: If/when actual output ends with a newline, then use:\n        #     return textwrap.dedent(text.strip('/n'))\n        return textwrap.dedent(text).strip()\n\n\nclass recursionlimit:\n    \"\"\"\n    A context manager which temporarily modifies the Python recursion limit.\n\n    The testing framework, coverage, etc. may add an arbitrary number of levels to the depth. To maintain consistency\n    in the tests, the current stack depth is determined when called, then added to the provided limit.\n\n    Example usage:\n\n    ``` python\n    with recursionlimit(20):\n        # test code here\n    ```\n\n    See <https://stackoverflow.com/a/50120316/866026>.\n    \"\"\"\n\n    def __init__(self, limit):\n        self.limit = util._get_stack_depth() + limit\n        self.old_limit = sys.getrecursionlimit()\n\n    def __enter__(self):\n        sys.setrecursionlimit(self.limit)\n\n    def __exit__(self, type, value, tb):\n        sys.setrecursionlimit(self.old_limit)\n\n\n#########################\n# Legacy Test Framework #\n#########################\n\n\nclass Kwargs(dict):\n    \"\"\" A `dict` like class for holding keyword arguments. \"\"\"\n    pass\n\n\ndef _normalize_whitespace(text):\n    \"\"\" Normalize whitespace for a string of HTML using `tidylib`. \"\"\"\n    output, errors = tidylib.tidy_fragment(text, options={\n        'drop_empty_paras': 0,\n        'fix_backslash': 0,\n        'fix_bad_comments': 0,\n        'fix_uri': 0,\n        'join_styles': 0,\n        'lower_literals': 0,\n        'merge_divs': 0,\n        'output_xhtml': 1,\n        'quote_ampersand': 0,\n        'newline': 'LF'\n    })\n    return output\n\n\nclass LegacyTestMeta(type):\n    def __new__(cls, name, bases, dct):\n\n        def generate_test(infile, outfile, normalize, kwargs):\n            def test(self):\n                with open(infile, encoding=\"utf-8\") as f:\n                    input = f.read()\n                with open(outfile, encoding=\"utf-8\") as f:\n                    # Normalize line endings\n                    # (on Windows, git may have altered line endings).\n                    expected = f.read().replace(\"\\r\\n\", \"\\n\")\n                output = markdown(input, **kwargs)\n                if tidylib and normalize:\n                    try:\n                        expected = _normalize_whitespace(expected)\n                        output = _normalize_whitespace(output)\n                    except OSError:\n                        self.skipTest(\"Tidylib's c library not available.\")\n                elif normalize:\n                    self.skipTest('Tidylib not available.')\n                self.assertMultiLineEqual(output, expected)\n            return test\n\n        location = dct.get('location', '')\n        exclude = dct.get('exclude', [])\n        normalize = dct.get('normalize', False)\n        input_ext = dct.get('input_ext', '.txt')\n        output_ext = dct.get('output_ext', '.html')\n        kwargs = dct.get('default_kwargs', Kwargs())\n\n        if os.path.isdir(location):\n            for file in os.listdir(location):\n                infile = os.path.join(location, file)\n                if os.path.isfile(infile):\n                    tname, ext = os.path.splitext(file)\n                    if ext == input_ext:\n                        outfile = os.path.join(location, tname + output_ext)\n                        tname = tname.replace(' ', '_').replace('-', '_')\n                        kws = kwargs.copy()\n                        if tname in dct:\n                            kws.update(dct[tname])\n                        test_name = 'test_%s' % tname\n                        if tname not in exclude:\n                            dct[test_name] = generate_test(infile, outfile, normalize, kws)\n                        else:\n                            dct[test_name] = unittest.skip('Excluded')(lambda: None)\n\n        return type.__new__(cls, name, bases, dct)\n\n\nclass LegacyTestCase(unittest.TestCase, metaclass=LegacyTestMeta):\n    \"\"\"\n    A [`unittest.TestCase`][] subclass for running Markdown's legacy file-based tests.\n\n    A subclass should define various properties which point to a directory of\n    text-based test files and define various behaviors/defaults for those tests.\n    The following properties are supported:\n\n    Attributes:\n        location (str): A path to the directory of test files. An absolute path is preferred.\n        exclude (list[str]): A list of tests to exclude. Each test name should comprise the filename\n            without an extension.\n        normalize (bool): A boolean value indicating if the HTML should be normalized. Default: `False`.\n        input_ext (str): A string containing the file extension of input files. Default: `.txt`.\n        output_ext (str): A string containing the file extension of expected output files. Default: `html`.\n        default_kwargs (Kwargs[str, Any]): The default set of keyword arguments for all test files in the directory.\n\n    In addition, properties can be defined for each individual set of test files within\n    the directory. The property should be given the name of the file without the file\n    extension. Any spaces and dashes in the filename should be replaced with\n    underscores. The value of the property should be a `Kwargs` instance which\n    contains the keyword arguments that should be passed to `Markdown` for that\n    test file. The keyword arguments will \"update\" the `default_kwargs`.\n\n    When the class instance is created, it will walk the given directory and create\n    a separate `Unitttest` for each set of test files using the naming scheme:\n    `test_filename`. One `Unittest` will be run for each set of input and output files.\n    \"\"\"\n    pass\n","size_bytes":8662},"markdown/treeprocessors.py":{"content":"# Python Markdown\n\n# A Python implementation of John Gruber's Markdown.\n\n# Documentation: https://python-markdown.github.io/\n# GitHub: https://github.com/Python-Markdown/markdown/\n# PyPI: https://pypi.org/project/Markdown/\n\n# Started by Manfred Stienstra (http://www.dwerg.net/).\n# Maintained for a few years by Yuri Takhteyev (http://www.freewisdom.org).\n# Currently maintained by Waylan Limberg (https://github.com/waylan),\n# Dmitry Shachnev (https://github.com/mitya57) and Isaac Muse (https://github.com/facelessuser).\n\n# Copyright 2007-2023 The Python Markdown Project (v. 1.7 and later)\n# Copyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b)\n# Copyright 2004 Manfred Stienstra (the original version)\n\n# License: BSD (see LICENSE.md for details).\n\n\"\"\"\nTree processors manipulate the tree created by block processors. They can even create an entirely\nnew `ElementTree` object. This is an excellent place for creating summaries, adding collected\nreferences, or last minute adjustments.\n\n\"\"\"\n\nfrom __future__ import annotations\n\nimport re\nimport xml.etree.ElementTree as etree\nfrom typing import TYPE_CHECKING, Any\nfrom . import util\nfrom . import inlinepatterns\n\nif TYPE_CHECKING:  # pragma: no cover\n    from markdown import Markdown\n\n\ndef build_treeprocessors(md: Markdown, **kwargs: Any) -> util.Registry[Treeprocessor]:\n    \"\"\" Build the default  `treeprocessors` for Markdown. \"\"\"\n    treeprocessors = util.Registry()\n    treeprocessors.register(InlineProcessor(md), 'inline', 20)\n    treeprocessors.register(PrettifyTreeprocessor(md), 'prettify', 10)\n    treeprocessors.register(UnescapeTreeprocessor(md), 'unescape', 0)\n    return treeprocessors\n\n\ndef isString(s: object) -> bool:\n    \"\"\" Return `True` if object is a string but not an  [`AtomicString`][markdown.util.AtomicString]. \"\"\"\n    if not isinstance(s, util.AtomicString):\n        return isinstance(s, str)\n    return False\n\n\nclass Treeprocessor(util.Processor):\n    \"\"\"\n    `Treeprocessor`s are run on the `ElementTree` object before serialization.\n\n    Each `Treeprocessor` implements a `run` method that takes a pointer to an\n    `Element` and modifies it as necessary.\n\n    `Treeprocessors` must extend `markdown.Treeprocessor`.\n\n    \"\"\"\n    def run(self, root: etree.Element) -> etree.Element | None:\n        \"\"\"\n        Subclasses of `Treeprocessor` should implement a `run` method, which\n        takes a root `Element`. This method can return another `Element`\n        object, and the existing root `Element` will be replaced, or it can\n        modify the current tree and return `None`.\n        \"\"\"\n        pass  # pragma: no cover\n\n\nclass InlineProcessor(Treeprocessor):\n    \"\"\"\n    A `Treeprocessor` that traverses a tree, applying inline patterns.\n    \"\"\"\n\n    def __init__(self, md: Markdown):\n        self.__placeholder_prefix = util.INLINE_PLACEHOLDER_PREFIX\n        self.__placeholder_suffix = util.ETX\n        self.__placeholder_length = 4 + len(self.__placeholder_prefix) \\\n                                      + len(self.__placeholder_suffix)\n        self.__placeholder_re = util.INLINE_PLACEHOLDER_RE\n        self.md = md\n        self.inlinePatterns = md.inlinePatterns\n        self.ancestors: list[str] = []\n\n    def __makePlaceholder(self, type: str) -> tuple[str, str]:\n        \"\"\" Generate a placeholder \"\"\"\n        id = \"%04d\" % len(self.stashed_nodes)\n        hash = util.INLINE_PLACEHOLDER % id\n        return hash, id\n\n    def __findPlaceholder(self, data: str, index: int) -> tuple[str | None, int]:\n        \"\"\"\n        Extract id from data string, start from index.\n\n        Arguments:\n            data: String.\n            index: Index, from which we start search.\n\n        Returns:\n            Placeholder id and string index, after the found placeholder.\n\n        \"\"\"\n        m = self.__placeholder_re.search(data, index)\n        if m:\n            return m.group(1), m.end()\n        else:\n            return None, index + 1\n\n    def __stashNode(self, node: etree.Element | str, type: str) -> str:\n        \"\"\" Add node to stash. \"\"\"\n        placeholder, id = self.__makePlaceholder(type)\n        self.stashed_nodes[id] = node\n        return placeholder\n\n    def __handleInline(self, data: str, patternIndex: int = 0) -> str:\n        \"\"\"\n        Process string with inline patterns and replace it with placeholders.\n\n        Arguments:\n            data: A line of Markdown text.\n            patternIndex: The index of the `inlinePattern` to start with.\n\n        Returns:\n            String with placeholders.\n\n        \"\"\"\n        if not isinstance(data, util.AtomicString):\n            startIndex = 0\n            count = len(self.inlinePatterns)\n            while patternIndex < count:\n                data, matched, startIndex = self.__applyPattern(\n                    self.inlinePatterns[patternIndex], data, patternIndex, startIndex\n                )\n                if not matched:\n                    patternIndex += 1\n        return data\n\n    def __processElementText(self, node: etree.Element, subnode: etree.Element, isText: bool = True) -> None:\n        \"\"\"\n        Process placeholders in `Element.text` or `Element.tail`\n        of Elements popped from `self.stashed_nodes`.\n\n        Arguments:\n            node: Parent node.\n            subnode: Processing node.\n            isText: Boolean variable, True - it's text, False - it's a tail.\n\n        \"\"\"\n        if isText:\n            text = subnode.text\n            subnode.text = None\n        else:\n            text = subnode.tail\n            subnode.tail = None\n\n        childResult = self.__processPlaceholders(text, subnode, isText)\n\n        if not isText and node is not subnode:\n            pos = list(node).index(subnode) + 1\n        else:\n            pos = 0\n\n        childResult.reverse()\n        for newChild in childResult:\n            node.insert(pos, newChild[0])\n\n    def __processPlaceholders(\n        self,\n        data: str | None,\n        parent: etree.Element,\n        isText: bool = True\n    ) -> list[tuple[etree.Element, list[str]]]:\n        \"\"\"\n        Process string with placeholders and generate `ElementTree` tree.\n\n        Arguments:\n            data: String with placeholders instead of `ElementTree` elements.\n            parent: Element, which contains processing inline data.\n            isText: Boolean variable, True - it's text, False - it's a tail.\n\n        Returns:\n            List with `ElementTree` elements with applied inline patterns.\n\n        \"\"\"\n        def linkText(text: str | None) -> None:\n            if text:\n                if result:\n                    if result[-1][0].tail:\n                        result[-1][0].tail += text\n                    else:\n                        result[-1][0].tail = text\n                elif not isText:\n                    if parent.tail:\n                        parent.tail += text\n                    else:\n                        parent.tail = text\n                else:\n                    if parent.text:\n                        parent.text += text\n                    else:\n                        parent.text = text\n        result = []\n        strartIndex = 0\n        while data:\n            index = data.find(self.__placeholder_prefix, strartIndex)\n            if index != -1:\n                id, phEndIndex = self.__findPlaceholder(data, index)\n\n                if id in self.stashed_nodes:\n                    node = self.stashed_nodes.get(id)\n\n                    if index > 0:\n                        text = data[strartIndex:index]\n                        linkText(text)\n\n                    if not isinstance(node, str):  # it's Element\n                        for child in [node] + list(node):\n                            if child.tail:\n                                if child.tail.strip():\n                                    self.__processElementText(\n                                        node, child, False\n                                    )\n                            if child.text:\n                                if child.text.strip():\n                                    self.__processElementText(child, child)\n                    else:  # it's just a string\n                        linkText(node)\n                        strartIndex = phEndIndex\n                        continue\n\n                    strartIndex = phEndIndex\n                    result.append((node, self.ancestors[:]))\n\n                else:  # wrong placeholder\n                    end = index + len(self.__placeholder_prefix)\n                    linkText(data[strartIndex:end])\n                    strartIndex = end\n            else:\n                text = data[strartIndex:]\n                if isinstance(data, util.AtomicString):\n                    # We don't want to loose the `AtomicString`\n                    text = util.AtomicString(text)\n                linkText(text)\n                data = \"\"\n\n        return result\n\n    def __applyPattern(\n        self,\n        pattern: inlinepatterns.Pattern,\n        data: str,\n        patternIndex: int,\n        startIndex: int = 0\n    ) -> tuple[str, bool, int]:\n        \"\"\"\n        Check if the line fits the pattern, create the necessary\n        elements, add it to `stashed_nodes`.\n\n        Arguments:\n            data: The text to be processed.\n            pattern: The pattern to be checked.\n            patternIndex: Index of current pattern.\n            startIndex: String index, from which we start searching.\n\n        Returns:\n            String with placeholders instead of `ElementTree` elements.\n\n        \"\"\"\n        new_style = isinstance(pattern, inlinepatterns.InlineProcessor)\n\n        for exclude in pattern.ANCESTOR_EXCLUDES:\n            if exclude.lower() in self.ancestors:\n                return data, False, 0\n\n        if new_style:\n            match = None\n            # Since `handleMatch` may reject our first match,\n            # we iterate over the buffer looking for matches\n            # until we can't find any more.\n            for match in pattern.getCompiledRegExp().finditer(data, startIndex):\n                node, start, end = pattern.handleMatch(match, data)\n                if start is None or end is None:\n                    startIndex += match.end(0)\n                    match = None\n                    continue\n                break\n        else:  # pragma: no cover\n            match = pattern.getCompiledRegExp().match(data[startIndex:])\n            leftData = data[:startIndex]\n\n        if not match:\n            return data, False, 0\n\n        if not new_style:  # pragma: no cover\n            node = pattern.handleMatch(match)\n            start = match.start(0)\n            end = match.end(0)\n\n        if node is None:\n            return data, True, end\n\n        if not isinstance(node, str):\n            if not isinstance(node.text, util.AtomicString):\n                # We need to process current node too\n                for child in [node] + list(node):\n                    if not isString(node):\n                        if child.text:\n                            self.ancestors.append(child.tag.lower())\n                            child.text = self.__handleInline(\n                                child.text, patternIndex + 1\n                            )\n                            self.ancestors.pop()\n                        if child.tail:\n                            child.tail = self.__handleInline(\n                                child.tail, patternIndex\n                            )\n\n        placeholder = self.__stashNode(node, pattern.type())\n\n        if new_style:\n            return \"{}{}{}\".format(data[:start],\n                                   placeholder, data[end:]), True, 0\n        else:  # pragma: no cover\n            return \"{}{}{}{}\".format(leftData,\n                                     match.group(1),\n                                     placeholder, match.groups()[-1]), True, 0\n\n    def __build_ancestors(self, parent: etree.Element | None, parents: list[str]) -> None:\n        \"\"\"Build the ancestor list.\"\"\"\n        ancestors = []\n        while parent is not None:\n            if parent is not None:\n                ancestors.append(parent.tag.lower())\n            parent = self.parent_map.get(parent)\n        ancestors.reverse()\n        parents.extend(ancestors)\n\n    def run(self, tree: etree.Element, ancestors: list[str] | None = None) -> etree.Element:\n        \"\"\"Apply inline patterns to a parsed Markdown tree.\n\n        Iterate over `Element`, find elements with inline tag, apply inline\n        patterns and append newly created Elements to tree.  To avoid further\n        processing of string with inline patterns, instead of normal string,\n        use subclass [`AtomicString`][markdown.util.AtomicString]:\n\n            node.text = markdown.util.AtomicString(\"This will not be processed.\")\n\n        Arguments:\n            tree: `Element` object, representing Markdown tree.\n            ancestors: List of parent tag names that precede the tree node (if needed).\n\n        Returns:\n            An element tree object with applied inline patterns.\n\n        \"\"\"\n        self.stashed_nodes: dict[str, etree.Element | str] = {}\n\n        # Ensure a valid parent list, but copy passed in lists\n        # to ensure we don't have the user accidentally change it on us.\n        tree_parents = [] if ancestors is None else ancestors[:]\n\n        self.parent_map = {c: p for p in tree.iter() for c in p}\n        stack = [(tree, tree_parents)]\n\n        while stack:\n            currElement, parents = stack.pop()\n\n            self.ancestors = parents\n            self.__build_ancestors(currElement, self.ancestors)\n\n            insertQueue = []\n            for child in currElement:\n                if child.text and not isinstance(\n                    child.text, util.AtomicString\n                ):\n                    self.ancestors.append(child.tag.lower())\n                    text = child.text\n                    child.text = None\n                    lst = self.__processPlaceholders(\n                        self.__handleInline(text), child\n                    )\n                    for item in lst:\n                        self.parent_map[item[0]] = child\n                    stack += lst\n                    insertQueue.append((child, lst))\n                    self.ancestors.pop()\n                if child.tail:\n                    tail = self.__handleInline(child.tail)\n                    dumby = etree.Element('d')\n                    child.tail = None\n                    tailResult = self.__processPlaceholders(tail, dumby, False)\n                    if dumby.tail:\n                        child.tail = dumby.tail\n                    pos = list(currElement).index(child) + 1\n                    tailResult.reverse()\n                    for newChild in tailResult:\n                        self.parent_map[newChild[0]] = currElement\n                        currElement.insert(pos, newChild[0])\n                if len(child):\n                    self.parent_map[child] = currElement\n                    stack.append((child, self.ancestors[:]))\n\n            for element, lst in insertQueue:\n                for i, obj in enumerate(lst):\n                    newChild = obj[0]\n                    element.insert(i, newChild)\n        return tree\n\n\nclass PrettifyTreeprocessor(Treeprocessor):\n    \"\"\" Add line breaks to the html document. \"\"\"\n\n    def _prettifyETree(self, elem: etree.Element) -> None:\n        \"\"\" Recursively add line breaks to `ElementTree` children. \"\"\"\n\n        i = \"\\n\"\n        if self.md.is_block_level(elem.tag) and elem.tag not in ['code', 'pre']:\n            if (not elem.text or not elem.text.strip()) \\\n                    and len(elem) and self.md.is_block_level(elem[0].tag):\n                elem.text = i\n            for e in elem:\n                if self.md.is_block_level(e.tag):\n                    self._prettifyETree(e)\n        if not elem.tail or not elem.tail.strip():\n            elem.tail = i\n\n    def run(self, root: etree.Element) -> None:\n        \"\"\" Add line breaks to `Element` object and its children. \"\"\"\n\n        self._prettifyETree(root)\n        # Do `<br />`'s separately as they are often in the middle of\n        # inline content and missed by `_prettifyETree`.\n        brs = root.iter('br')\n        for br in brs:\n            if not br.tail or not br.tail.strip():\n                br.tail = '\\n'\n            else:\n                br.tail = '\\n%s' % br.tail\n        # Clean up extra empty lines at end of code blocks.\n        pres = root.iter('pre')\n        for pre in pres:\n            if len(pre) and pre[0].tag == 'code':\n                code = pre[0]\n                # Only prettify code containing text only\n                if not len(code) and code.text is not None:\n                    code.text = util.AtomicString(code.text.rstrip() + '\\n')\n\n\nclass UnescapeTreeprocessor(Treeprocessor):\n    \"\"\" Restore escaped chars \"\"\"\n\n    RE = re.compile(r'{}(\\d+){}'.format(util.STX, util.ETX))\n\n    def _unescape(self, m: re.Match[str]) -> str:\n        return chr(int(m.group(1)))\n\n    def unescape(self, text: str) -> str:\n        return self.RE.sub(self._unescape, text)\n\n    def run(self, root: etree.Element) -> None:\n        \"\"\" Loop over all elements and unescape all text. \"\"\"\n        for elem in root.iter():\n            # Unescape text content\n            if elem.text and not elem.tag == 'code':\n                elem.text = self.unescape(elem.text)\n            # Unescape tail content\n            if elem.tail:\n                elem.tail = self.unescape(elem.tail)\n            # Unescape attribute values\n            for key, value in elem.items():\n                elem.set(key, self.unescape(value))\n","size_bytes":17651},"markdown/util.py":{"content":"# Python Markdown\n\n# A Python implementation of John Gruber's Markdown.\n\n# Documentation: https://python-markdown.github.io/\n# GitHub: https://github.com/Python-Markdown/markdown/\n# PyPI: https://pypi.org/project/Markdown/\n\n# Started by Manfred Stienstra (http://www.dwerg.net/).\n# Maintained for a few years by Yuri Takhteyev (http://www.freewisdom.org).\n# Currently maintained by Waylan Limberg (https://github.com/waylan),\n# Dmitry Shachnev (https://github.com/mitya57) and Isaac Muse (https://github.com/facelessuser).\n\n# Copyright 2007-2023 The Python Markdown Project (v. 1.7 and later)\n# Copyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b)\n# Copyright 2004 Manfred Stienstra (the original version)\n\n# License: BSD (see LICENSE.md for details).\n\n\"\"\"\nThis module contains various contacts, classes and functions which get referenced and used\nthroughout the code base.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport re\nimport sys\nimport warnings\nfrom functools import wraps, lru_cache\nfrom itertools import count\nfrom typing import TYPE_CHECKING, Generic, Iterator, NamedTuple, TypeVar, TypedDict, overload\n\nif TYPE_CHECKING:  # pragma: no cover\n    from markdown import Markdown\n    import xml.etree.ElementTree as etree\n\n_T = TypeVar('_T')\n\n\n\"\"\"\nConstants you might want to modify\n-----------------------------------------------------------------------------\n\"\"\"\n\n\nBLOCK_LEVEL_ELEMENTS: list[str] = [\n    # Elements which are invalid to wrap in a `<p>` tag.\n    # See https://w3c.github.io/html/grouping-content.html#the-p-element\n    'address', 'article', 'aside', 'blockquote', 'details', 'div', 'dl',\n    'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3',\n    'h4', 'h5', 'h6', 'header', 'hgroup', 'hr', 'main', 'menu', 'nav', 'ol',\n    'p', 'pre', 'section', 'table', 'ul',\n    # Other elements which Markdown should not be mucking up the contents of.\n    'canvas', 'colgroup', 'dd', 'body', 'dt', 'group', 'html', 'iframe', 'li', 'legend',\n    'math', 'map', 'noscript', 'output', 'object', 'option', 'progress', 'script',\n    'style', 'summary', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'thead', 'tr', 'video',\n    'center'\n]\n\"\"\"\nList of HTML tags which get treated as block-level elements. Same as the `block_level_elements`\nattribute of the [`Markdown`][markdown.Markdown] class. Generally one should use the\nattribute on the class. This remains for compatibility with older extensions.\n\"\"\"\n\n# Placeholders\nSTX = '\\u0002'\n\"\"\" \"Start of Text\" marker for placeholder templates. \"\"\"\nETX = '\\u0003'\n\"\"\" \"End of Text\" marker for placeholder templates. \"\"\"\nINLINE_PLACEHOLDER_PREFIX = STX+\"klzzwxh:\"\n\"\"\" Prefix for inline placeholder template. \"\"\"\nINLINE_PLACEHOLDER = INLINE_PLACEHOLDER_PREFIX + \"%s\" + ETX\n\"\"\" Placeholder template for stashed inline text. \"\"\"\nINLINE_PLACEHOLDER_RE = re.compile(INLINE_PLACEHOLDER % r'([0-9]+)')\n\"\"\" Regular Expression which matches inline placeholders. \"\"\"\nAMP_SUBSTITUTE = STX+\"amp\"+ETX\n\"\"\" Placeholder template for HTML entities. \"\"\"\nHTML_PLACEHOLDER = STX + \"wzxhzdk:%s\" + ETX\n\"\"\" Placeholder template for raw HTML. \"\"\"\nHTML_PLACEHOLDER_RE = re.compile(HTML_PLACEHOLDER % r'([0-9]+)')\n\"\"\" Regular expression which matches HTML placeholders. \"\"\"\nTAG_PLACEHOLDER = STX + \"hzzhzkh:%s\" + ETX\n\"\"\" Placeholder template for tags. \"\"\"\n\n\n# Constants you probably do not need to change\n# -----------------------------------------------------------------------------\n\nRTL_BIDI_RANGES = (\n    ('\\u0590', '\\u07FF'),\n    # Hebrew (0590-05FF), Arabic (0600-06FF),\n    # Syriac (0700-074F), Arabic supplement (0750-077F),\n    # Thaana (0780-07BF), Nko (07C0-07FF).\n    ('\\u2D30', '\\u2D7F')  # Tifinagh\n)\n\n\n# AUXILIARY GLOBAL FUNCTIONS\n# =============================================================================\n\n\n@lru_cache(maxsize=None)\ndef get_installed_extensions():\n    \"\"\" Return all entry_points in the `markdown.extensions` group. \"\"\"\n    if sys.version_info >= (3, 10):\n        from importlib import metadata\n    else:  # `<PY310` use backport\n        import importlib_metadata as metadata\n    # Only load extension entry_points once.\n    return metadata.entry_points(group='markdown.extensions')\n\n\ndef deprecated(message: str, stacklevel: int = 2):\n    \"\"\"\n    Raise a [`DeprecationWarning`][] when wrapped function/method is called.\n\n    Usage:\n\n    ```python\n    @deprecated(\"This method will be removed in version X; use Y instead.\")\n    def some_method():\n        pass\n    ```\n    \"\"\"\n    def wrapper(func):\n        @wraps(func)\n        def deprecated_func(*args, **kwargs):\n            warnings.warn(\n                f\"'{func.__name__}' is deprecated. {message}\",\n                category=DeprecationWarning,\n                stacklevel=stacklevel\n            )\n            return func(*args, **kwargs)\n        return deprecated_func\n    return wrapper\n\n\ndef parseBoolValue(value: str | None, fail_on_errors: bool = True, preserve_none: bool = False) -> bool | None:\n    \"\"\"Parses a string representing a boolean value. If parsing was successful,\n       returns `True` or `False`. If `preserve_none=True`, returns `True`, `False`,\n       or `None`. If parsing was not successful, raises `ValueError`, or, if\n       `fail_on_errors=False`, returns `None`.\"\"\"\n    if not isinstance(value, str):\n        if preserve_none and value is None:\n            return value\n        return bool(value)\n    elif preserve_none and value.lower() == 'none':\n        return None\n    elif value.lower() in ('true', 'yes', 'y', 'on', '1'):\n        return True\n    elif value.lower() in ('false', 'no', 'n', 'off', '0', 'none'):\n        return False\n    elif fail_on_errors:\n        raise ValueError('Cannot parse bool value: %r' % value)\n\n\ndef code_escape(text: str) -> str:\n    \"\"\"HTML escape a string of code.\"\"\"\n    if \"&\" in text:\n        text = text.replace(\"&\", \"&amp;\")\n    if \"<\" in text:\n        text = text.replace(\"<\", \"&lt;\")\n    if \">\" in text:\n        text = text.replace(\">\", \"&gt;\")\n    return text\n\n\ndef _get_stack_depth(size: int = 2) -> int:\n    \"\"\"Get current stack depth, performantly.\n    \"\"\"\n    frame = sys._getframe(size)\n\n    for size in count(size):\n        frame = frame.f_back\n        if not frame:\n            return size\n\n\ndef nearing_recursion_limit() -> bool:\n    \"\"\"Return true if current stack depth is within 100 of maximum limit.\"\"\"\n    return sys.getrecursionlimit() - _get_stack_depth() < 100\n\n\n# MISC AUXILIARY CLASSES\n# =============================================================================\n\n\nclass AtomicString(str):\n    \"\"\"A string which should not be further processed.\"\"\"\n    pass\n\n\nclass Processor:\n    \"\"\" The base class for all processors.\n\n    Attributes:\n        Processor.md: The `Markdown` instance passed in an initialization.\n\n    Arguments:\n        md: The `Markdown` instance this processor is a part of.\n\n    \"\"\"\n    def __init__(self, md: Markdown | None = None):\n        self.md = md\n\n\nif TYPE_CHECKING:  # pragma: no cover\n    class TagData(TypedDict):\n        tag: str\n        attrs: dict[str, str]\n        left_index: int\n        right_index: int\n\n\nclass HtmlStash:\n    \"\"\"\n    This class is used for stashing HTML objects that we extract\n    in the beginning and replace with place-holders.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\" Create an `HtmlStash`. \"\"\"\n        self.html_counter = 0  # for counting inline html segments\n        self.rawHtmlBlocks: list[str | etree.Element] = []\n        self.tag_counter = 0\n        self.tag_data: list[TagData] = []  # list of dictionaries in the order tags appear\n\n    def store(self, html: str | etree.Element) -> str:\n        \"\"\"\n        Saves an HTML segment for later reinsertion.  Returns a\n        placeholder string that needs to be inserted into the\n        document.\n\n        Keyword arguments:\n            html: An html segment.\n\n        Returns:\n            A placeholder string.\n\n        \"\"\"\n        self.rawHtmlBlocks.append(html)\n        placeholder = self.get_placeholder(self.html_counter)\n        self.html_counter += 1\n        return placeholder\n\n    def reset(self) -> None:\n        \"\"\" Clear the stash. \"\"\"\n        self.html_counter = 0\n        self.rawHtmlBlocks = []\n\n    def get_placeholder(self, key: int) -> str:\n        return HTML_PLACEHOLDER % key\n\n    def store_tag(self, tag: str, attrs: dict[str, str], left_index: int, right_index: int) -> str:\n        \"\"\"Store tag data and return a placeholder.\"\"\"\n        self.tag_data.append({'tag': tag, 'attrs': attrs,\n                              'left_index': left_index,\n                              'right_index': right_index})\n        placeholder = TAG_PLACEHOLDER % str(self.tag_counter)\n        self.tag_counter += 1  # equal to the tag's index in `self.tag_data`\n        return placeholder\n\n\n# Used internally by `Registry` for each item in its sorted list.\n# Provides an easier to read API when editing the code later.\n# For example, `item.name` is more clear than `item[0]`.\nclass _PriorityItem(NamedTuple):\n    name: str\n    priority: float\n\n\nclass Registry(Generic[_T]):\n    \"\"\"\n    A priority sorted registry.\n\n    A `Registry` instance provides two public methods to alter the data of the\n    registry: `register` and `deregister`. Use `register` to add items and\n    `deregister` to remove items. See each method for specifics.\n\n    When registering an item, a \"name\" and a \"priority\" must be provided. All\n    items are automatically sorted by \"priority\" from highest to lowest. The\n    \"name\" is used to remove (\"deregister\") and get items.\n\n    A `Registry` instance it like a list (which maintains order) when reading\n    data. You may iterate over the items, get an item and get a count (length)\n    of all items. You may also check that the registry contains an item.\n\n    When getting an item you may use either the index of the item or the\n    string-based \"name\". For example:\n\n        registry = Registry()\n        registry.register(SomeItem(), 'itemname', 20)\n        # Get the item by index\n        item = registry[0]\n        # Get the item by name\n        item = registry['itemname']\n\n    When checking that the registry contains an item, you may use either the\n    string-based \"name\", or a reference to the actual item. For example:\n\n        someitem = SomeItem()\n        registry.register(someitem, 'itemname', 20)\n        # Contains the name\n        assert 'itemname' in registry\n        # Contains the item instance\n        assert someitem in registry\n\n    The method `get_index_for_name` is also available to obtain the index of\n    an item using that item's assigned \"name\".\n    \"\"\"\n\n    def __init__(self):\n        self._data: dict[str, _T] = {}\n        self._priority: list[_PriorityItem] = []\n        self._is_sorted = False\n\n    def __contains__(self, item: str | _T) -> bool:\n        if isinstance(item, str):\n            # Check if an item exists by this name.\n            return item in self._data.keys()\n        # Check if this instance exists.\n        return item in self._data.values()\n\n    def __iter__(self) -> Iterator[_T]:\n        self._sort()\n        return iter([self._data[k] for k, p in self._priority])\n\n    @overload\n    def __getitem__(self, key: str | int) -> _T:  # pragma: no cover\n        ...\n\n    @overload\n    def __getitem__(self, key: slice) -> Registry[_T]:  # pragma: no cover\n        ...\n\n    def __getitem__(self, key: str | int | slice) -> _T | Registry[_T]:\n        self._sort()\n        if isinstance(key, slice):\n            data: Registry[_T] = Registry()\n            for k, p in self._priority[key]:\n                data.register(self._data[k], k, p)\n            return data\n        if isinstance(key, int):\n            return self._data[self._priority[key].name]\n        return self._data[key]\n\n    def __len__(self) -> int:\n        return len(self._priority)\n\n    def __repr__(self):\n        return '<{}({})>'.format(self.__class__.__name__, list(self))\n\n    def get_index_for_name(self, name: str) -> int:\n        \"\"\"\n        Return the index of the given name.\n        \"\"\"\n        if name in self:\n            self._sort()\n            return self._priority.index(\n                [x for x in self._priority if x.name == name][0]\n            )\n        raise ValueError('No item named \"{}\" exists.'.format(name))\n\n    def register(self, item: _T, name: str, priority: float) -> None:\n        \"\"\"\n        Add an item to the registry with the given name and priority.\n\n        Arguments:\n            item: The item being registered.\n            name: A string used to reference the item.\n            priority: An integer or float used to sort against all items.\n\n        If an item is registered with a \"name\" which already exists, the\n        existing item is replaced with the new item. Treat carefully as the\n        old item is lost with no way to recover it. The new item will be\n        sorted according to its priority and will **not** retain the position\n        of the old item.\n        \"\"\"\n        if name in self:\n            # Remove existing item of same name first\n            self.deregister(name)\n        self._is_sorted = False\n        self._data[name] = item\n        self._priority.append(_PriorityItem(name, priority))\n\n    def deregister(self, name: str, strict: bool = True) -> None:\n        \"\"\"\n        Remove an item from the registry.\n\n        Set `strict=False` to fail silently. Otherwise a [`ValueError`][] is raised for an unknown `name`.\n        \"\"\"\n        try:\n            index = self.get_index_for_name(name)\n            del self._priority[index]\n            del self._data[name]\n        except ValueError:\n            if strict:\n                raise\n\n    def _sort(self) -> None:\n        \"\"\"\n        Sort the registry by priority from highest to lowest.\n\n        This method is called internally and should never be explicitly called.\n        \"\"\"\n        if not self._is_sorted:\n            self._priority.sort(key=lambda item: item.priority, reverse=True)\n            self._is_sorted = True\n","size_bytes":13943},"migrations/env.py":{"content":"import logging\nfrom logging.config import fileConfig\n\nfrom flask import current_app\n\nfrom alembic import context\n\n# this is the Alembic Config object, which provides\n# access to the values within the .ini file in use.\nconfig = context.config\n\n# Interpret the config file for Python logging.\n# This line sets up loggers basically.\nfileConfig(config.config_file_name)\nlogger = logging.getLogger('alembic.env')\n\n\ndef get_engine():\n    try:\n        # this works with Flask-SQLAlchemy<3 and Alchemical\n        return current_app.extensions['migrate'].db.get_engine()\n    except (TypeError, AttributeError):\n        # this works with Flask-SQLAlchemy>=3\n        return current_app.extensions['migrate'].db.engine\n\n\ndef get_engine_url():\n    try:\n        return get_engine().url.render_as_string(hide_password=False).replace(\n            '%', '%%')\n    except AttributeError:\n        return str(get_engine().url).replace('%', '%%')\n\n\n# add your model's MetaData object here\n# for 'autogenerate' support\n# from myapp import mymodel\n# target_metadata = mymodel.Base.metadata\nconfig.set_main_option('sqlalchemy.url', get_engine_url())\ntarget_db = current_app.extensions['migrate'].db\n\n# other values from the config, defined by the needs of env.py,\n# can be acquired:\n# my_important_option = config.get_main_option(\"my_important_option\")\n# ... etc.\n\n\ndef get_metadata():\n    if hasattr(target_db, 'metadatas'):\n        return target_db.metadatas[None]\n    return target_db.metadata\n\n\ndef run_migrations_offline():\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    url = config.get_main_option(\"sqlalchemy.url\")\n    context.configure(\n        url=url, target_metadata=get_metadata(), literal_binds=True\n    )\n\n    with context.begin_transaction():\n        context.run_migrations()\n\n\ndef run_migrations_online():\n    \"\"\"Run migrations in 'online' mode.\n\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n\n    \"\"\"\n\n    # this callback is used to prevent an auto-migration from being generated\n    # when there are no changes to the schema\n    # reference: http://alembic.zzzcomputing.com/en/latest/cookbook.html\n    def process_revision_directives(context, revision, directives):\n        if getattr(config.cmd_opts, 'autogenerate', False):\n            script = directives[0]\n            if script.upgrade_ops.is_empty():\n                directives[:] = []\n                logger.info('No changes in schema detected.')\n\n    conf_args = current_app.extensions['migrate'].configure_args\n    if conf_args.get(\"process_revision_directives\") is None:\n        conf_args[\"process_revision_directives\"] = process_revision_directives\n\n    connectable = get_engine()\n\n    with connectable.connect() as connection:\n        context.configure(\n            connection=connection,\n            target_metadata=get_metadata(),\n            **conf_args\n        )\n\n        with context.begin_transaction():\n            context.run_migrations()\n\n\nif context.is_offline_mode():\n    run_migrations_offline()\nelse:\n    run_migrations_online()\n","size_bytes":3344},"app/static/style.css":{"content":"/* Reset e Base */\n* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\n:root {\n    /* Cores principais - Paleta profissional */\n    --primary: #2563eb;\n    --primary-hover: #1d4ed8;\n    --primary-light: #eff6ff;\n    --secondary: #64748b;\n    --success: #059669;\n    --success-hover: #047857;\n    --danger: #dc2626;\n    --warning: #d97706;\n    --info: #0284c7;\n    --light: #f8fafc;\n    --dark: #0f172a;\n    --gray-50: #f8fafc;\n    --gray-100: #f1f5f9;\n    --gray-200: #e2e8f0;\n    --gray-300: #cbd5e1;\n    --gray-400: #94a3b8;\n    --gray-500: #64748b;\n    --gray-600: #475569;\n    --gray-700: #334155;\n    --gray-800: #1e293b;\n    --gray-900: #0f172a;\n\n    /* Tipografia */\n    --font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n    --font-size-xs: 0.75rem;\n    --font-size-sm: 0.875rem;\n    --font-size-base: 1rem;\n    --font-size-lg: 1.125rem;\n    --font-size-xl: 1.25rem;\n    --font-size-2xl: 1.5rem;\n    --font-size-3xl: 1.875rem;\n\n    /* Espa√ßamento */\n    --spacing-1: 0.25rem;\n    --spacing-2: 0.5rem;\n    --spacing-3: 0.75rem;\n    --spacing-4: 1rem;\n    --spacing-5: 1.25rem;\n    --spacing-6: 1.5rem;\n    --spacing-8: 2rem;\n    --spacing-12: 3rem;\n    --spacing-16: 4rem;\n\n    /* Bordas */\n    --border-radius: 0.5rem;\n    --border-radius-lg: 0.75rem;\n    --border-radius-xl: 1rem;\n\n    /* Sombras */\n    --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);\n    --shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);\n    --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);\n    --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);\n    --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);\n\n    /* Transi√ß√µes */\n    --transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);\n    --transition-fast: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);\n}\n\n/* Base styles */\nhtml {\n    height: 100%;\n    scroll-behavior: smooth;\n}\n\nbody {\n    font-family: var(--font-family);\n    background: linear-gradient(135deg, #ffffff 0%, #f8fafc 50%, #f1f5f9 100%);\n    color: var(--gray-900);\n    line-height: 1.6;\n    min-height: 100vh;\n    display: flex;\n    flex-direction: column;\n}\n\n/* Layout principal */\n.main-content {\n    flex: 1;\n    padding-bottom: var(--spacing-16);\n}\n\n/* Footer fixo */\n.footer {\n    background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);\n    border-top: 1px solid var(--gray-200);\n    margin-top: auto;\n    padding: var(--spacing-6) 0;\n    font-size: var(--font-size-sm);\n    color: var(--gray-800);\n    box-shadow: var(--shadow-sm);\n}\n\n/* Navbar moderna */\n.navbar {\n    background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%) !important;\n    backdrop-filter: blur(10px);\n    border-bottom: 1px solid var(--gray-200);\n    box-shadow: var(--shadow-md);\n}\n\n.navbar-brand {\n    font-weight: 700;\n    font-size: var(--font-size-xl);\n    color: var(--primary) !important;\n}\n\n.nav-link {\n    font-weight: 500;\n    color: var(--gray-800) !important;\n    padding: var(--spacing-3) var(--spacing-4) !important;\n    border-radius: var(--border-radius);\n    transition: var(--transition);\n}\n\n.nav-link:hover {\n    background: var(--primary-light);\n    color: var(--primary) !important;\n}\n\n.nav-link.active {\n    background: var(--primary);\n    color: white !important;\n}\n\n/* Cards modernos */\n.card {\n    border: none;\n    border-radius: var(--border-radius-lg);\n    box-shadow: var(--shadow-sm);\n    transition: var(--transition);\n    background: white;\n}\n\n.card:hover {\n    box-shadow: var(--shadow-md);\n    transform: translateY(-1px);\n}\n\n.card-header {\n    background: var(--gray-50);\n    border-bottom: 1px solid var(--gray-200);\n    border-radius: var(--border-radius-lg) var(--border-radius-lg) 0 0;\n    padding: var(--spacing-5);\n    font-weight: 600;\n    color: var(--gray-800);\n}\n\n.card-body {\n    padding: var(--spacing-6);\n}\n\n/* Bot√µes profissionais */\n.btn {\n    font-weight: 500;\n    border-radius: var(--border-radius);\n    padding: var(--spacing-3) var(--spacing-5);\n    font-size: var(--font-size-sm);\n    transition: var(--transition);\n    border: none;\n    cursor: pointer;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    gap: var(--spacing-2);\n    text-decoration: none;\n    min-height: 2.5rem;\n}\n\n.btn:focus {\n    outline: 2px solid transparent;\n    outline-offset: 2px;\n    box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);\n}\n\n.btn-primary {\n    background: var(--primary);\n    color: white;\n}\n\n.btn-primary:hover {\n    background: var(--primary-hover);\n    color: white;\n    transform: translateY(-1px);\n    box-shadow: var(--shadow-md);\n}\n\n.btn-success {\n    background: var(--success);\n    color: white;\n}\n\n.btn-success:hover {\n    background: var(--success-hover);\n    color: white;\n    transform: translateY(-1px);\n    box-shadow: var(--shadow-md);\n}\n\n.btn-danger {\n    background: var(--danger);\n    color: white;\n}\n\n.btn-danger:hover {\n    background: #b91c1c;\n    color: white;\n    transform: translateY(-1px);\n    box-shadow: var(--shadow-md);\n}\n\n.btn-secondary {\n    background: var(--gray-100);\n    color: var(--gray-700);\n    border: 1px solid var(--gray-300);\n}\n\n.btn-secondary:hover {\n    background: var(--gray-200);\n    color: var(--gray-800);\n    border-color: var(--gray-400);\n}\n\n.btn-outline-primary {\n    background: transparent;\n    color: var(--primary);\n    border: 1px solid var(--primary);\n}\n\n.btn-outline-primary:hover {\n    background: var(--primary);\n    color: white;\n}\n\n.btn-sm {\n    padding: var(--spacing-2) var(--spacing-4);\n    font-size: var(--font-size-xs);\n    min-height: 2rem;\n}\n\n.btn-lg {\n    padding: var(--spacing-4) var(--spacing-8);\n    font-size: var(--font-size-lg);\n    min-height: 3rem;\n}\n\n/* Formul√°rios modernos */\n.form-control {\n    border: 1px solid var(--gray-300);\n    border-radius: var(--border-radius);\n    padding: var(--spacing-3) var(--spacing-4);\n    font-size: var(--font-size-sm);\n    transition: var(--transition);\n    background: white;\n    min-height: 2.5rem;\n}\n\n.form-control:focus {\n    outline: none;\n    border-color: var(--primary);\n    box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);\n}\n\n.form-control[type=\"date\"],\n.form-control[type=\"datetime-local\"],\n.form-control[type=\"time\"] {\n    padding: var(--spacing-2) var(--spacing-3);\n    font-size: var(--font-size-sm);\n    min-height: 2.5rem;\n}\n\n.form-label {\n    font-weight: 500;\n    color: var(--gray-700);\n    margin-bottom: var(--spacing-2);\n    font-size: var(--font-size-sm);\n}\n\n.form-select {\n    border: 1px solid var(--gray-300);\n    border-radius: var(--border-radius);\n    padding: var(--spacing-3) var(--spacing-4);\n    font-size: var(--font-size-sm);\n    background: white;\n    min-height: 2.5rem;\n}\n\n.form-select:focus {\n    outline: none;\n    border-color: var(--primary);\n    box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);\n}\n\n.input-group {\n    position: relative;\n}\n\n.input-group-text {\n    background: var(--gray-50);\n    border: 1px solid var(--gray-300);\n    color: var(--gray-600);\n    padding: var(--spacing-3);\n    border-radius: var(--border-radius) 0 0 var(--border-radius);\n}\n\n.form-check-input {\n    border: 1px solid var(--gray-300);\n    margin-top: 0.25em;\n}\n\n.form-check-input:checked {\n    background-color: var(--primary);\n    border-color: var(--primary);\n}\n\n/* Tabelas modernas */\n.table {\n    background: white;\n    border-radius: var(--border-radius-lg);\n    overflow: hidden;\n    box-shadow: var(--shadow-sm);\n}\n\n.table thead th {\n    background: var(--gray-50);\n    border-bottom: 2px solid var(--gray-200);\n    font-weight: 600;\n    color: var(--gray-800);\n    padding: var(--spacing-4);\n    font-size: var(--font-size-sm);\n    text-transform: uppercase;\n    letter-spacing: 0.025em;\n}\n\n.table tbody td {\n    padding: var(--spacing-4);\n    border-bottom: 1px solid var(--gray-200);\n    vertical-align: middle;\n}\n\n.table tbody tr:hover {\n    background: var(--gray-50);\n}\n\n/* Badges e status */\n.badge {\n    font-weight: 500;\n    padding: var(--spacing-1) var(--spacing-3);\n    border-radius: var(--border-radius);\n    font-size: var(--font-size-xs);\n    text-transform: uppercase;\n    letter-spacing: 0.025em;\n}\n\n.badge-success {\n    background: #dcfce7;\n    color: #166534;\n}\n\n.badge-danger {\n    background: #fef2f2;\n    color: #991b1b;\n}\n\n.badge-warning {\n    background: #fefbeb;\n    color: #92400e;\n}\n\n.badge-info {\n    background: #eff6ff;\n    color: #1e40af;\n}\n\n/* Alertas modernos */\n.alert {\n    border: none;\n    border-radius: var(--border-radius-lg);\n    padding: var(--spacing-4) var(--spacing-5);\n    margin-bottom: var(--spacing-4);\n    border-left: 4px solid;\n}\n\n.alert-success {\n    background: #f0fdf4;\n    color: #166534;\n    border-left-color: var(--success);\n}\n\n.alert-danger {\n    background: #fef2f2;\n    color: #991b1b;\n    border-left-color: var(--danger);\n}\n\n.alert-warning {\n    background: #fefbeb;\n    color: #92400e;\n    border-left-color: var(--warning);\n}\n\n.alert-info {\n    background: #eff6ff;\n    color: #1e40af;\n    border-left-color: var(--info);\n}\n\n/* Dashboard cards */\n.dashboard-card {\n    background: white;\n    border-radius: var(--border-radius-xl);\n    padding: var(--spacing-6);\n    box-shadow: var(--shadow-sm);\n    transition: var(--transition);\n    border: 1px solid var(--gray-200);\n}\n\n.dashboard-card:hover {\n    box-shadow: var(--shadow-md);\n    transform: translateY(-2px);\n}\n\n.dashboard-card-icon {\n    width: 3rem;\n    height: 3rem;\n    border-radius: var(--border-radius-lg);\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    font-size: var(--font-size-xl);\n    margin-bottom: var(--spacing-4);\n}\n\n.dashboard-card-icon.primary {\n    background: var(--primary-light);\n    color: var(--primary);\n}\n\n.dashboard-card-icon.success {\n    background: #f0fdf4;\n    color: var(--success);\n}\n\n.dashboard-card-icon.warning {\n    background: #fefbeb;\n    color: var(--warning);\n}\n\n.dashboard-card-icon.danger {\n    background: #fef2f2;\n    color: var(--danger);\n}\n\n/* Modais modernos */\n.modal-content {\n    border: none;\n    border-radius: var(--border-radius-xl);\n    box-shadow: var(--shadow-xl);\n}\n\n.modal-header {\n    background: var(--gray-50);\n    border-bottom: 1px solid var(--gray-200);\n    border-radius: var(--border-radius-xl) var(--border-radius-xl) 0 0;\n    padding: var(--spacing-6);\n}\n\n.modal-body {\n    padding: var(--spacing-6);\n}\n\n.modal-footer {\n    background: var(--gray-50);\n    border-top: 1px solid var(--gray-200);\n    border-radius: 0 0 var(--border-radius-xl) var(--border-radius-xl);\n    padding: var(--spacing-5) var(--spacing-6);\n}\n\n/* Breadcrumbs */\n.breadcrumb {\n    background: transparent;\n    padding: 0;\n    margin-bottom: var(--spacing-6);\n}\n\n.breadcrumb-item {\n    font-size: var(--font-size-sm);\n    color: var(--gray-600);\n}\n\n.breadcrumb-item.active {\n    color: var(--gray-900);\n    font-weight: 500;\n}\n\n/* Pagina√ß√£o */\n.pagination {\n    gap: var(--spacing-2);\n}\n\n.page-link {\n    border: 1px solid var(--gray-300);\n    color: var(--gray-700);\n    padding: var(--spacing-2) var(--spacing-4);\n    border-radius: var(--border-radius);\n    transition: var(--transition);\n}\n\n.page-link:hover {\n    background: var(--primary);\n    border-color: var(--primary);\n    color: white;\n}\n\n.page-item.active .page-link {\n    background: var(--primary);\n    border-color: var(--primary);\n    color: white;\n}\n\n/* Utilit√°rios */\n.text-xs { font-size: var(--font-size-xs); }\n.text-sm { font-size: var(--font-size-sm); }\n.text-lg { font-size: var(--font-size-lg); }\n.text-xl { font-size: var(--font-size-xl); }\n.text-2xl { font-size: var(--font-size-2xl); }\n.text-3xl { font-size: var(--font-size-3xl); }\n\n.font-medium { font-weight: 500; }\n.font-semibold { font-weight: 600; }\n.font-bold { font-weight: 700; }\n\n.text-primary { color: var(--primary); }\n.text-success { color: var(--success); }\n.text-danger { color: var(--danger); }\n.text-warning { color: var(--warning); }\n.text-muted { color: var(--gray-500); }\n\n/* Scrollbar personalizada */\n::-webkit-scrollbar {\n    width: 6px;\n    height: 6px;\n}\n\n::-webkit-scrollbar-track {\n    background: var(--gray-100);\n}\n\n::-webkit-scrollbar-thumb {\n    background: var(--gray-400);\n    border-radius: 3px;\n}\n\n::-webkit-scrollbar-thumb:hover {\n    background: var(--gray-500);\n}\n\n/* Anima√ß√µes suaves */\n.fade-in {\n    animation: fadeIn 0.3s ease-out;\n}\n\n@keyframes fadeIn {\n    from {\n        opacity: 0;\n        transform: translateY(10px);\n    }\n    to {\n        opacity: 1;\n        transform: translateY(0);\n    }\n}\n\n/* Loading spinner */\n.spinner-border {\n    width: 1rem;\n    height: 1rem;\n    border-width: 2px;\n}\n\n/* Responsive design */\n@media (max-width: 768px) {\n    .container {\n        padding: 0 var(--spacing-4);\n    }\n\n    .card-body {\n        padding: var(--spacing-4);\n    }\n\n    .btn {\n        padding: var(--spacing-3) var(--spacing-4);\n        font-size: var(--font-size-sm);\n    }\n\n    .dashboard-card {\n        padding: var(--spacing-4);\n    }\n\n    .table {\n        font-size: var(--font-size-sm);\n    }\n\n    .table thead th,\n    .table tbody td {\n        padding: var(--spacing-3);\n    }\n}\n\n/* Dark mode manual */\n[data-theme=\"dark\"] {\n    --gray-50: #0f172a;\n    --gray-100: #1e293b;\n    --gray-200: #334155;\n    --gray-300: #475569;\n    --gray-400: #64748b;\n    --gray-500: #94a3b8;\n    --gray-600: #cbd5e1;\n    --gray-700: #e2e8f0;\n    --gray-800: #f1f5f9;\n    --gray-900: #f8fafc;\n}\n\n[data-theme=\"dark\"] body {\n    background: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #334155 100%);\n    color: var(--gray-900);\n}\n\n[data-theme=\"dark\"] .navbar {\n    background: linear-gradient(135deg, #1e293b 0%, #334155 100%) !important;\n    border-bottom-color: var(--gray-600);\n}\n\n[data-theme=\"dark\"] .footer {\n    background: linear-gradient(135deg, #1e293b 0%, #334155 100%);\n    border-top-color: var(--gray-600);\n    color: var(--gray-300);\n}\n\n[data-theme=\"dark\"] .card,\n[data-theme=\"dark\"] .dashboard-card {\n    background: var(--gray-100);\n    border-color: var(--gray-600);\n}\n\n[data-theme=\"dark\"] .nav-link {\n    color: var(--gray-300) !important;\n}\n\n/* Modern components espec√≠ficos */\n.modern-card {\n    background: white;\n    border-radius: var(--border-radius-xl);\n    box-shadow: var(--shadow-sm);\n    border: 1px solid var(--gray-200);\n    overflow: hidden;\n    transition: var(--transition);\n}\n\n.modern-card:hover {\n    box-shadow: var(--shadow-md);\n    transform: translateY(-1px);\n}\n\n.modern-card-header {\n    background: linear-gradient(135deg, var(--primary) 0%, var(--primary-hover) 100%);\n    color: white;\n    padding: var(--spacing-5) var(--spacing-6);\n    font-weight: 600;\n}\n\n.btn-modern {\n    background: white;\n    border: 1px solid var(--gray-300);\n    border-radius: var(--border-radius-lg);\n    padding: var(--spacing-4) var(--spacing-6);\n    font-weight: 500;\n    transition: var(--transition);\n    box-shadow: var(--shadow-sm);\n}\n\n.btn-modern:hover {\n    box-shadow: var(--shadow-md);\n    transform: translateY(-1px);\n    border-color: var(--primary);\n    color: var(--primary);\n}\n\n.status-badge {\n    display: inline-flex;\n    align-items: center;\n    gap: var(--spacing-2);\n    padding: var(--spacing-2) var(--spacing-3);\n    border-radius: var(--border-radius);\n    font-size: var(--font-size-xs);\n    font-weight: 500;\n    text-transform: uppercase;\n    letter-spacing: 0.025em;\n}\n\n.status-success {\n    background: #f0fdf4;\n    color: #166534;\n    border: 1px solid #bbf7d0;\n}\n\n.status-danger {\n    background: #fef2f2;\n    color: #991b1b;\n    border: 1px solid #fecaca;\n}\n\n.status-warning {\n    background: #fefbeb;\n    color: #92400e;\n    border: 1px solid #fed7aa;\n}\n\n.status-info {\n    background: #eff6ff;\n    color: #1e40af;\n    border: 1px solid #dbeafe;\n}\n\n/* Cores dos cart√µes */\n.bg-primary { background-color: #007bff !important; }\n.bg-success { background-color: #28a745 !important; }\n.bg-warning { background-color: #ffc107 !important; }\n.bg-danger { background-color: #dc3545 !important; }\n.bg-info { background-color: #17a2b8 !important; }\n.bg-purple { background-color: #6f42c1 !important; }","size_bytes":16104},"app/static/sw.js":{"content":"\nconst CACHE_NAME = 'ti-reminder-v1.0.1';\nconst OFFLINE_URL = '/static/offline.html';\n\n// Recursos para cache\nconst STATIC_ASSETS = [\n    '/',\n    '/static/style.css',\n    '/static/js/components.js',\n    '/static/js/notifications.js',\n    '/static/manifest.json',\n    '/static/icons/icon-192x192.png',\n    'https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css',\n    'https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js',\n    'https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css'\n];\n\n// Instalar Service Worker\nself.addEventListener('install', event => {\n    console.log(`[SW] Installing version ${CACHE_NAME}...`);\n    event.waitUntil(\n        caches.open(CACHE_NAME)\n            .then(cache => {\n                console.log('[SW] Caching static assets');\n                return cache.addAll(STATIC_ASSETS);\n            })\n            .then(() => {\n                console.log('[SW] Installation complete');\n                return self.skipWaiting();\n            })\n    );\n});\n\n// Ativar Service Worker\nself.addEventListener('activate', event => {\n    console.log(`[SW] Activating version ${CACHE_NAME}...`);\n    event.waitUntil(\n        caches.keys().then(cacheNames => {\n            return Promise.all(\n                cacheNames.map(cacheName => {\n                    if (cacheName !== CACHE_NAME) {\n                        console.log('[SW] Deleting old cache:', cacheName);\n                        return caches.delete(cacheName);\n                    }\n                })\n            );\n        }).then(() => {\n            console.log('[SW] Activation complete');\n            return self.clients.claim();\n        })\n    );\n});\n\n// Interceptar requisi√ß√µes\nself.addEventListener('fetch', event => {\n    const { request } = event;\n    const url = new URL(request.url);\n\n    // Cache first para assets est√°ticos\n    if (STATIC_ASSETS.includes(url.pathname) || \n        url.pathname.startsWith('/static/')) {\n        event.respondWith(\n            caches.match(request)\n                .then(response => {\n                    return response || fetch(request);\n                })\n        );\n        return;\n    }\n\n    // Network first para APIs e p√°ginas din√¢micas\n    if (url.pathname.startsWith('/api/') || \n        request.method !== 'GET') {\n        event.respondWith(\n            fetch(request)\n                .then(response => {\n                    // Cache successful responses\n                    if (response.status === 200) {\n                        const responseClone = response.clone();\n                        caches.open(CACHE_NAME)\n                            .then(cache => {\n                                cache.put(request, responseClone);\n                            });\n                    }\n                    return response;\n                })\n                .catch(() => {\n                    // Fallback para cache se offline\n                    return caches.match(request);\n                })\n        );\n        return;\n    }\n\n    // Cache first com network fallback para p√°ginas\n    event.respondWith(\n        caches.match(request)\n            .then(response => {\n                return response || fetch(request)\n                    .then(fetchResponse => {\n                        // Cache p√°ginas importantes\n                        if (fetchResponse.status === 200) {\n                            const responseClone = fetchResponse.clone();\n                            caches.open(CACHE_NAME)\n                                .then(cache => {\n                                    cache.put(request, responseClone);\n                                });\n                        }\n                        return fetchResponse;\n                    })\n                    .catch(() => {\n                        // P√°gina offline para navega√ß√£o\n                        if (request.mode === 'navigate') {\n                            return caches.match(OFFLINE_URL);\n                        }\n                    });\n            })\n    );\n});\n\n// Background Sync para dados offline\nself.addEventListener('sync', event => {\n    if (event.tag === 'background-sync-reminders') {\n        event.waitUntil(syncReminders());\n    }\n    if (event.tag === 'background-sync-tasks') {\n        event.waitUntil(syncTasks());\n    }\n});\n\n// Push notifications\nself.addEventListener('push', event => {\n    let payload;\n    try {\n        // Tentar analisar os dados como JSON\n        if (event.data) {\n            const text = event.data.text();\n            try {\n                payload = JSON.parse(text);\n            } catch (e) {\n                // Se n√£o for JSON, usar o texto como est√°\n                payload = { message: text };\n            }\n        } else {\n            payload = { message: 'Nova notifica√ß√£o do TI OSN System' };\n        }\n    } catch (error) {\n        console.error('Erro ao processar notifica√ß√£o push:', error);\n        payload = { message: 'Nova notifica√ß√£o do TI OSN System' };\n    }\n\n    // Configurar op√ß√µes da notifica√ß√£o\n    const options = {\n        body: payload.message || payload.body || 'Nova notifica√ß√£o do TI OSN System',\n        icon: '/static/icons/icon-192x192.png',\n        badge: '/static/icons/badge-72x72.png',\n        vibrate: [100, 50, 100],\n        data: {\n            dateOfArrival: Date.now(),\n            primaryKey: payload.id || '1',\n            url: payload.url || '/',\n            ...payload\n        },\n        actions: [\n            {\n                action: 'explore',\n                title: 'Ver detalhes',\n                icon: '/static/icons/checkmark.png'\n            },\n            {\n                action: 'close',\n                title: 'Fechar',\n                icon: '/static/icons/xmark.png'\n            }\n        ],\n        // Garantir que a notifica√ß√£o seja exibida mesmo que o dispositivo esteja em modo de economia de energia\n        requireInteraction: true\n    };\n\n    const title = payload.title || 'TI OSN System';\n\n    event.waitUntil(\n        self.registration.showNotification(title, options)\n    );\n});\n\n// Clique em notifica√ß√µes\nself.addEventListener('notificationclick', event => {\n    // Fechar a notifica√ß√£o\n    event.notification.close();\n    \n    // Ignorar se a a√ß√£o for 'close'\n    if (event.action === 'close') return;\n    \n    // Determinar a URL de destino com base nos dados da notifica√ß√£o\n    let targetUrl = '/';\n    const notificationData = event.notification.data || {};\n    \n    // Se a notifica√ß√£o tiver uma URL espec√≠fica, us√°-la\n    if (notificationData.url && notificationData.url !== '/') {\n        targetUrl = notificationData.url;\n    } else {\n        // Caso contr√°rio, determinar a URL com base no tipo de notifica√ß√£o\n        const tag = event.notification.tag || '';\n        \n        if (tag.startsWith('reminder-')) {\n            // Notifica√ß√£o de lembrete\n            const reminderId = tag.replace('reminder-', '');\n            targetUrl = `/reminders?highlight=${reminderId}`;\n        } else if (tag.startsWith('chamado-')) {\n            // Notifica√ß√£o de chamado\n            const chamadoId = tag.replace('chamado-', '');\n            targetUrl = `/chamados/detalhe/${chamadoId}`;\n        } else if (tag === 'tasks-overdue') {\n            // Notifica√ß√£o de tarefas vencidas\n            targetUrl = '/tasks?filter=overdue';\n        }\n    }\n    \n    // Abrir a aplica√ß√£o na URL determinada\n    event.waitUntil(\n        clients.matchAll({type: 'window', includeUncontrolled: true})\n            .then(clientList => {\n                // Verificar se j√° existe uma janela aberta com a URL alvo\n                for (const client of clientList) {\n                    const clientUrl = new URL(client.url);\n                    const targetUrlObj = new URL(targetUrl, self.location.origin);\n                    \n                    // Se a URL base for a mesma, focar nessa janela\n                    if (clientUrl.pathname === targetUrlObj.pathname && 'focus' in client) {\n                        return client.focus();\n                    }\n                }\n                \n                // Se n√£o encontrar uma janela compat√≠vel, abrir uma nova\n                if (clients.openWindow) {\n                    return clients.openWindow(targetUrl);\n                }\n            })\n            .catch(error => {\n                console.error('Erro ao processar clique na notifica√ß√£o:', error);\n            })\n    );\n});\n\n// Fun√ß√µes auxiliares\nasync function syncReminders() {\n    try {\n        const pendingData = await getStoredData('pendingReminders');\n        if (pendingData && pendingData.length > 0) {\n            for (const reminder of pendingData) {\n                await fetch('/reminders', {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json',\n                    },\n                    body: JSON.stringify(reminder)\n                });\n            }\n            await clearStoredData('pendingReminders');\n        }\n    } catch (error) {\n        console.error('[SW] Erro ao sincronizar lembretes:', error);\n    }\n}\n\nasync function syncTasks() {\n    try {\n        const pendingData = await getStoredData('pendingTasks');\n        if (pendingData && pendingData.length > 0) {\n            for (const task of pendingData) {\n                await fetch('/tasks', {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json',\n                    },\n                    body: JSON.stringify(task)\n                });\n            }\n            await clearStoredData('pendingTasks');\n        }\n    } catch (error) {\n        console.error('[SW] Erro ao sincronizar tarefas:', error);\n    }\n}\n\nasync function getStoredData(key) {\n    const cache = await caches.open(CACHE_NAME);\n    const response = await cache.match(`/offline-data/${key}`);\n    if (response) {\n        return await response.json();\n    }\n    return null;\n}\n\nasync function clearStoredData(key) {\n    const cache = await caches.open(CACHE_NAME);\n    await cache.delete(`/offline-data/${key}`);\n}\n","size_bytes":10145},"markdown/extensions/__init__.py":{"content":"# Python Markdown\n\n# A Python implementation of John Gruber's Markdown.\n\n# Documentation: https://python-markdown.github.io/\n# GitHub: https://github.com/Python-Markdown/markdown/\n# PyPI: https://pypi.org/project/Markdown/\n\n# Started by Manfred Stienstra (http://www.dwerg.net/).\n# Maintained for a few years by Yuri Takhteyev (http://www.freewisdom.org).\n# Currently maintained by Waylan Limberg (https://github.com/waylan),\n# Dmitry Shachnev (https://github.com/mitya57) and Isaac Muse (https://github.com/facelessuser).\n\n# Copyright 2007-2023 The Python Markdown Project (v. 1.7 and later)\n# Copyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b)\n# Copyright 2004 Manfred Stienstra (the original version)\n\n# License: BSD (see LICENSE.md for details).\n\n\"\"\"\nMarkdown accepts an [`Extension`][markdown.extensions.Extension] instance for each extension. Therefore, each extension\nmust to define a class that extends [`Extension`][markdown.extensions.Extension] and over-rides the\n[`extendMarkdown`][markdown.extensions.Extension.extendMarkdown] method. Within this class one can manage configuration\noptions for their extension and attach the various processors and patterns which make up an extension to the\n[`Markdown`][markdown.Markdown] instance.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING, Any, Iterable, Mapping\nfrom ..util import parseBoolValue\n\nif TYPE_CHECKING:  # pragma: no cover\n    from markdown import Markdown\n\n\nclass Extension:\n    \"\"\" Base class for extensions to subclass. \"\"\"\n\n    config: Mapping[str, list] = {}\n    \"\"\"\n    Default configuration for an extension.\n\n    This attribute is to be defined in a subclass and must be of the following format:\n\n    ``` python\n    config = {\n        'key': ['value', 'description']\n    }\n    ```\n\n    Note that [`setConfig`][markdown.extensions.Extension.setConfig] will raise a [`KeyError`][]\n    if a default is not set for each option.\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        \"\"\" Initiate Extension and set up configs. \"\"\"\n        self.setConfigs(kwargs)\n\n    def getConfig(self, key: str, default: Any = '') -> Any:\n        \"\"\"\n        Return a single configuration option value.\n\n        Arguments:\n            key: The configuration option name.\n            default: Default value to return if key is not set.\n\n        Returns:\n            Value of stored configuration option.\n        \"\"\"\n        if key in self.config:\n            return self.config[key][0]\n        else:\n            return default\n\n    def getConfigs(self) -> dict[str, Any]:\n        \"\"\"\n        Return all configuration options.\n\n        Returns:\n            All configuration options.\n        \"\"\"\n        return {key: self.getConfig(key) for key in self.config.keys()}\n\n    def getConfigInfo(self) -> list[tuple[str, str]]:\n        \"\"\"\n        Return descriptions of all configuration options.\n\n        Returns:\n            All descriptions of configuration options.\n        \"\"\"\n        return [(key, self.config[key][1]) for key in self.config.keys()]\n\n    def setConfig(self, key: str, value: Any) -> None:\n        \"\"\"\n        Set a configuration option.\n\n        If the corresponding default value set in [`config`][markdown.extensions.Extension.config]\n        is a `bool` value or `None`, then `value` is passed through\n        [`parseBoolValue`][markdown.util.parseBoolValue] before being stored.\n\n        Arguments:\n            key: Name of configuration option to set.\n            value: Value to assign to option.\n\n        Raises:\n            KeyError: If `key` is not known.\n        \"\"\"\n        if isinstance(self.config[key][0], bool):\n            value = parseBoolValue(value)\n        if self.config[key][0] is None:\n            value = parseBoolValue(value, preserve_none=True)\n        self.config[key][0] = value\n\n    def setConfigs(self, items: Mapping[str, Any] | Iterable[tuple[str, Any]]) -> None:\n        \"\"\"\n        Loop through a collection of configuration options, passing each to\n        [`setConfig`][markdown.extensions.Extension.setConfig].\n\n        Arguments:\n            items: Collection of configuration options.\n\n        Raises:\n            KeyError: for any unknown key.\n        \"\"\"\n        if hasattr(items, 'items'):\n            # it's a dict\n            items = items.items()\n        for key, value in items:\n            self.setConfig(key, value)\n\n    def extendMarkdown(self, md: Markdown) -> None:\n        \"\"\"\n        Add the various processors and patterns to the Markdown Instance.\n\n        This method must be overridden by every extension.\n\n        Arguments:\n            md: The Markdown instance.\n\n        \"\"\"\n        raise NotImplementedError(\n            'Extension \"%s.%s\" must define an \"extendMarkdown\"'\n            'method.' % (self.__class__.__module__, self.__class__.__name__)\n        )\n","size_bytes":4822},"markdown/extensions/abbr.py":{"content":"# Abbreviation Extension for Python-Markdown\n# ==========================================\n\n# This extension adds abbreviation handling to Python-Markdown.\n\n# See https://Python-Markdown.github.io/extensions/abbreviations\n# for documentation.\n\n# Original code Copyright 2007-2008 [Waylan Limberg](http://achinghead.com/)\n# and [Seemant Kulleen](http://www.kulleen.org/)\n\n# All changes Copyright 2008-2014 The Python Markdown Project\n\n# License: [BSD](https://opensource.org/licenses/bsd-license.php)\n\n\"\"\"\nThis extension adds abbreviation handling to Python-Markdown.\n\nSee the [documentation](https://Python-Markdown.github.io/extensions/abbreviations)\nfor details.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom . import Extension\nfrom ..blockprocessors import BlockProcessor\nfrom ..inlinepatterns import InlineProcessor\nfrom ..treeprocessors import Treeprocessor\nfrom ..util import AtomicString, deprecated\nfrom typing import TYPE_CHECKING\nimport re\nimport xml.etree.ElementTree as etree\n\nif TYPE_CHECKING:  # pragma: no cover\n    from .. import Markdown\n    from ..blockparser import BlockParser\n\n\nclass AbbrExtension(Extension):\n    \"\"\" Abbreviation Extension for Python-Markdown. \"\"\"\n\n    def __init__(self, **kwargs):\n        \"\"\" Initiate Extension and set up configs. \"\"\"\n        self.config = {\n            'glossary': [\n                {},\n                'A dictionary where the `key` is the abbreviation and the `value` is the definition.'\n                \"Default: `{}`\"\n            ],\n        }\n        \"\"\" Default configuration options. \"\"\"\n        super().__init__(**kwargs)\n        self.abbrs = {}\n        self.glossary = {}\n\n    def reset(self):\n        \"\"\" Clear all previously defined abbreviations. \"\"\"\n        self.abbrs.clear()\n        if (self.glossary):\n            self.abbrs.update(self.glossary)\n\n    def reset_glossary(self):\n        \"\"\" Clear all abbreviations from the glossary. \"\"\"\n        self.glossary.clear()\n\n    def load_glossary(self, dictionary: dict[str, str]):\n        \"\"\"Adds `dictionary` to our glossary. Any abbreviations that already exist will be overwritten.\"\"\"\n        if dictionary:\n            self.glossary = {**dictionary, **self.glossary}\n\n    def extendMarkdown(self, md):\n        \"\"\" Insert `AbbrTreeprocessor` and `AbbrBlockprocessor`. \"\"\"\n        if (self.config['glossary'][0]):\n            self.load_glossary(self.config['glossary'][0])\n        self.abbrs.update(self.glossary)\n        md.registerExtension(self)\n        md.treeprocessors.register(AbbrTreeprocessor(md, self.abbrs), 'abbr', 7)\n        md.parser.blockprocessors.register(AbbrBlockprocessor(md.parser, self.abbrs), 'abbr', 16)\n\n\nclass AbbrTreeprocessor(Treeprocessor):\n    \"\"\" Replace abbreviation text with `<abbr>` elements. \"\"\"\n\n    def __init__(self, md: Markdown | None = None, abbrs: dict | None = None):\n        self.abbrs: dict = abbrs if abbrs is not None else {}\n        self.RE: re.RegexObject | None = None\n        super().__init__(md)\n\n    def create_element(self, title: str, text: str, tail: str) -> etree.Element:\n        ''' Create an `abbr` element. '''\n        abbr = etree.Element('abbr', {'title': title})\n        abbr.text = AtomicString(text)\n        abbr.tail = tail\n        return abbr\n\n    def iter_element(self, el: etree.Element, parent: etree.Element | None = None) -> None:\n        ''' Recursively iterate over elements, run regex on text and wrap matches in `abbr` tags. '''\n        for child in reversed(el):\n            self.iter_element(child, el)\n        if text := el.text:\n            if not isinstance(text, AtomicString):\n                for m in reversed(list(self.RE.finditer(text))):\n                    if self.abbrs[m.group(0)]:\n                        abbr = self.create_element(self.abbrs[m.group(0)], m.group(0), text[m.end():])\n                        el.insert(0, abbr)\n                        text = text[:m.start()]\n                el.text = text\n        if parent is not None and el.tail:\n            tail = el.tail\n            index = list(parent).index(el) + 1\n            if not isinstance(tail, AtomicString):\n                for m in reversed(list(self.RE.finditer(tail))):\n                    abbr = self.create_element(self.abbrs[m.group(0)], m.group(0), tail[m.end():])\n                    parent.insert(index, abbr)\n                    tail = tail[:m.start()]\n                el.tail = tail\n\n    def run(self, root: etree.Element) -> etree.Element | None:\n        ''' Step through tree to find known abbreviations. '''\n        if not self.abbrs:\n            # No abbreviations defined. Skip running processor.\n            return\n        # Build and compile regex\n        abbr_list = list(self.abbrs.keys())\n        abbr_list.sort(key=len, reverse=True)\n        self.RE = re.compile(f\"\\\\b(?:{ '|'.join(re.escape(key) for key in abbr_list) })\\\\b\")\n        # Step through tree and modify on matches\n        self.iter_element(root)\n\n\nclass AbbrBlockprocessor(BlockProcessor):\n    \"\"\" Parse text for abbreviation references. \"\"\"\n\n    RE = re.compile(r'^[*]\\[(?P<abbr>[^\\\\]*?)\\][ ]?:[ ]*\\n?[ ]*(?P<title>.*)$', re.MULTILINE)\n\n    def __init__(self, parser: BlockParser, abbrs: dict):\n        self.abbrs: dict = abbrs\n        super().__init__(parser)\n\n    def test(self, parent: etree.Element, block: str) -> bool:\n        return True\n\n    def run(self, parent: etree.Element, blocks: list[str]) -> bool:\n        \"\"\"\n        Find and remove all abbreviation references from the text.\n        Each reference is added to the abbreviation collection.\n\n        \"\"\"\n        block = blocks.pop(0)\n        m = self.RE.search(block)\n        if m:\n            abbr = m.group('abbr').strip()\n            title = m.group('title').strip()\n            if title and abbr:\n                if title == \"''\" or title == '\"\"':\n                    self.abbrs.pop(abbr)\n                else:\n                    self.abbrs[abbr] = title\n                if block[m.end():].strip():\n                    # Add any content after match back to blocks as separate block\n                    blocks.insert(0, block[m.end():].lstrip('\\n'))\n                if block[:m.start()].strip():\n                    # Add any content before match back to blocks as separate block\n                    blocks.insert(0, block[:m.start()].rstrip('\\n'))\n                return True\n        # No match. Restore block.\n        blocks.insert(0, block)\n        return False\n\n\nAbbrPreprocessor = deprecated(\"This class has been renamed to `AbbrBlockprocessor`.\")(AbbrBlockprocessor)\n\n\n@deprecated(\"This class will be removed in the future; use `AbbrTreeprocessor` instead.\")\nclass AbbrInlineProcessor(InlineProcessor):\n    \"\"\" Abbreviation inline pattern. \"\"\"\n\n    def __init__(self, pattern: str, title: str):\n        super().__init__(pattern)\n        self.title = title\n\n    def handleMatch(self, m: re.Match[str], data: str) -> tuple[etree.Element, int, int]:\n        abbr = etree.Element('abbr')\n        abbr.text = AtomicString(m.group('abbr'))\n        abbr.set('title', self.title)\n        return abbr, m.start(0), m.end(0)\n\n\ndef makeExtension(**kwargs):  # pragma: no cover\n    return AbbrExtension(**kwargs)\n","size_bytes":7141},"markdown/extensions/admonition.py":{"content":"# Admonition extension for Python-Markdown\n# ========================================\n\n# Adds rST-style admonitions. Inspired by [rST][] feature with the same name.\n\n# [rST]: http://docutils.sourceforge.net/docs/ref/rst/directives.html#specific-admonitions\n\n# See https://Python-Markdown.github.io/extensions/admonition\n# for documentation.\n\n# Original code Copyright [Tiago Serafim](https://www.tiagoserafim.com/).\n\n# All changes Copyright The Python Markdown Project\n\n# License: [BSD](https://opensource.org/licenses/bsd-license.php)\n\n\n\"\"\"\nAdds rST-style admonitions to Python-Markdown.\nInspired by [rST][] feature with the same name.\n\n[rST]: http://docutils.sourceforge.net/docs/ref/rst/directives.html#specific-admonitions\n\nSee the [documentation](https://Python-Markdown.github.io/extensions/admonition)\nfor details.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom . import Extension\nfrom ..blockprocessors import BlockProcessor\nimport xml.etree.ElementTree as etree\nimport re\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:  # pragma: no cover\n    from markdown import blockparser\n\n\nclass AdmonitionExtension(Extension):\n    \"\"\" Admonition extension for Python-Markdown. \"\"\"\n\n    def extendMarkdown(self, md):\n        \"\"\" Add Admonition to Markdown instance. \"\"\"\n        md.registerExtension(self)\n\n        md.parser.blockprocessors.register(AdmonitionProcessor(md.parser), 'admonition', 105)\n\n\nclass AdmonitionProcessor(BlockProcessor):\n\n    CLASSNAME = 'admonition'\n    CLASSNAME_TITLE = 'admonition-title'\n    RE = re.compile(r'(?:^|\\n)!!! ?([\\w\\-]+(?: +[\\w\\-]+)*)(?: +\"(.*?)\")? *(?:\\n|$)')\n    RE_SPACES = re.compile('  +')\n\n    def __init__(self, parser: blockparser.BlockParser):\n        \"\"\"Initialization.\"\"\"\n\n        super().__init__(parser)\n\n        self.current_sibling: etree.Element | None = None\n        self.content_indent = 0\n\n    def parse_content(self, parent: etree.Element, block: str) -> tuple[etree.Element | None, str, str]:\n        \"\"\"Get sibling admonition.\n\n        Retrieve the appropriate sibling element. This can get tricky when\n        dealing with lists.\n\n        \"\"\"\n\n        old_block = block\n        the_rest = ''\n\n        # We already acquired the block via test\n        if self.current_sibling is not None:\n            sibling = self.current_sibling\n            block, the_rest = self.detab(block, self.content_indent)\n            self.current_sibling = None\n            self.content_indent = 0\n            return sibling, block, the_rest\n\n        sibling = self.lastChild(parent)\n\n        if sibling is None or sibling.tag != 'div' or sibling.get('class', '').find(self.CLASSNAME) == -1:\n            sibling = None\n        else:\n            # If the last child is a list and the content is sufficiently indented\n            # to be under it, then the content's sibling is in the list.\n            last_child = self.lastChild(sibling)\n            indent = 0\n            while last_child is not None:\n                if (\n                    sibling is not None and block.startswith(' ' * self.tab_length * 2) and\n                    last_child is not None and last_child.tag in ('ul', 'ol', 'dl')\n                ):\n\n                    # The expectation is that we'll find an `<li>` or `<dt>`.\n                    # We should get its last child as well.\n                    sibling = self.lastChild(last_child)\n                    last_child = self.lastChild(sibling) if sibling is not None else None\n\n                    # Context has been lost at this point, so we must adjust the\n                    # text's indentation level so it will be evaluated correctly\n                    # under the list.\n                    block = block[self.tab_length:]\n                    indent += self.tab_length\n                else:\n                    last_child = None\n\n            if not block.startswith(' ' * self.tab_length):\n                sibling = None\n\n            if sibling is not None:\n                indent += self.tab_length\n                block, the_rest = self.detab(old_block, indent)\n                self.current_sibling = sibling\n                self.content_indent = indent\n\n        return sibling, block, the_rest\n\n    def test(self, parent: etree.Element, block: str) -> bool:\n\n        if self.RE.search(block):\n            return True\n        else:\n            return self.parse_content(parent, block)[0] is not None\n\n    def run(self, parent: etree.Element, blocks: list[str]) -> None:\n        block = blocks.pop(0)\n        m = self.RE.search(block)\n\n        if m:\n            if m.start() > 0:\n                self.parser.parseBlocks(parent, [block[:m.start()]])\n            block = block[m.end():]  # removes the first line\n            block, theRest = self.detab(block)\n        else:\n            sibling, block, theRest = self.parse_content(parent, block)\n\n        if m:\n            klass, title = self.get_class_and_title(m)\n            div = etree.SubElement(parent, 'div')\n            div.set('class', '{} {}'.format(self.CLASSNAME, klass))\n            if title:\n                p = etree.SubElement(div, 'p')\n                p.text = title\n                p.set('class', self.CLASSNAME_TITLE)\n        else:\n            # Sibling is a list item, but we need to wrap it's content should be wrapped in <p>\n            if sibling.tag in ('li', 'dd') and sibling.text:\n                text = sibling.text\n                sibling.text = ''\n                p = etree.SubElement(sibling, 'p')\n                p.text = text\n\n            div = sibling\n\n        self.parser.parseChunk(div, block)\n\n        if theRest:\n            # This block contained unindented line(s) after the first indented\n            # line. Insert these lines as the first block of the master blocks\n            # list for future processing.\n            blocks.insert(0, theRest)\n\n    def get_class_and_title(self, match: re.Match[str]) -> tuple[str, str | None]:\n        klass, title = match.group(1).lower(), match.group(2)\n        klass = self.RE_SPACES.sub(' ', klass)\n        if title is None:\n            # no title was provided, use the capitalized class name as title\n            # e.g.: `!!! note` will render\n            # `<p class=\"admonition-title\">Note</p>`\n            title = klass.split(' ', 1)[0].capitalize()\n        elif title == '':\n            # an explicit blank title should not be rendered\n            # e.g.: `!!! warning \"\"` will *not* render `p` with a title\n            title = None\n        return klass, title\n\n\ndef makeExtension(**kwargs):  # pragma: no cover\n    return AdmonitionExtension(**kwargs)\n","size_bytes":6566},"markdown/extensions/attr_list.py":{"content":"# Attribute List Extension for Python-Markdown\n# ============================================\n\n# Adds attribute list syntax. Inspired by\n# [Maruku](http://maruku.rubyforge.org/proposal.html#attribute_lists)'s\n# feature of the same name.\n\n# See https://Python-Markdown.github.io/extensions/attr_list\n# for documentation.\n\n# Original code Copyright 2011 [Waylan Limberg](http://achinghead.com/).\n\n# All changes Copyright 2011-2014 The Python Markdown Project\n\n# License: [BSD](https://opensource.org/licenses/bsd-license.php)\n\n\"\"\"\nAdds attribute list syntax to Python-Markdown.\nInspired by\n[Maruku](http://maruku.rubyforge.org/proposal.html#attribute_lists)'s\nfeature of the same name.\n\nSee the [documentation](https://Python-Markdown.github.io/extensions/attr_list)\nfor details.\n\"\"\"\n\nfrom __future__ import annotations\nfrom typing import TYPE_CHECKING\n\nfrom . import Extension\nfrom ..treeprocessors import Treeprocessor\nimport re\n\nif TYPE_CHECKING:  # pragma: no cover\n    from xml.etree.ElementTree import Element\n\n\ndef _handle_double_quote(s, t):\n    k, v = t.split('=', 1)\n    return k, v.strip('\"')\n\n\ndef _handle_single_quote(s, t):\n    k, v = t.split('=', 1)\n    return k, v.strip(\"'\")\n\n\ndef _handle_key_value(s, t):\n    return t.split('=', 1)\n\n\ndef _handle_word(s, t):\n    if t.startswith('.'):\n        return '.', t[1:]\n    if t.startswith('#'):\n        return 'id', t[1:]\n    return t, t\n\n\n_scanner = re.Scanner([\n    (r'[^ =}]+=\".*?\"', _handle_double_quote),\n    (r\"[^ =}]+='.*?'\", _handle_single_quote),\n    (r'[^ =}]+=[^ =}]+', _handle_key_value),\n    (r'[^ =}]+', _handle_word),\n    (r' ', None)\n])\n\n\ndef get_attrs_and_remainder(attrs_string: str) -> tuple[list[tuple[str, str]], str]:\n    \"\"\" Parse attribute list and return a list of attribute tuples.\n\n    Additionally, return any text that remained after a curly brace. In typical cases, its presence\n    should mean that the input does not match the intended attribute list syntax.\n    \"\"\"\n    attrs, remainder = _scanner.scan(attrs_string)\n    # To keep historic behavior, discard all unparsable text prior to '}'.\n    index = remainder.find('}')\n    remainder = remainder[index:] if index != -1 else ''\n    return attrs, remainder\n\n\ndef get_attrs(str: str) -> list[tuple[str, str]]:  # pragma: no cover\n    \"\"\" Soft-deprecated. Prefer `get_attrs_and_remainder`. \"\"\"\n    return get_attrs_and_remainder(str)[0]\n\n\ndef isheader(elem: Element) -> bool:\n    return elem.tag in ['h1', 'h2', 'h3', 'h4', 'h5', 'h6']\n\n\nclass AttrListTreeprocessor(Treeprocessor):\n\n    BASE_RE = r'\\{\\:?[ ]*([^\\}\\n ][^\\n]*)[ ]*\\}'\n    HEADER_RE = re.compile(r'[ ]+{}[ ]*$'.format(BASE_RE))\n    BLOCK_RE = re.compile(r'\\n[ ]*{}[ ]*$'.format(BASE_RE))\n    INLINE_RE = re.compile(r'^{}'.format(BASE_RE))\n    NAME_RE = re.compile(r'[^A-Z_a-z\\u00c0-\\u00d6\\u00d8-\\u00f6\\u00f8-\\u02ff'\n                         r'\\u0370-\\u037d\\u037f-\\u1fff\\u200c-\\u200d'\n                         r'\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff'\n                         r'\\uf900-\\ufdcf\\ufdf0-\\ufffd'\n                         r'\\:\\-\\.0-9\\u00b7\\u0300-\\u036f\\u203f-\\u2040]+')\n\n    def run(self, doc: Element) -> None:\n        for elem in doc.iter():\n            if self.md.is_block_level(elem.tag):\n                # Block level: check for `attrs` on last line of text\n                RE = self.BLOCK_RE\n                if isheader(elem) or elem.tag in ['dt', 'td', 'th']:\n                    # header, def-term, or table cell: check for attributes at end of element\n                    RE = self.HEADER_RE\n                if len(elem) and elem.tag == 'li':\n                    # special case list items. children may include a `ul` or `ol`.\n                    pos = None\n                    # find the `ul` or `ol` position\n                    for i, child in enumerate(elem):\n                        if child.tag in ['ul', 'ol']:\n                            pos = i\n                            break\n                    if pos is None and elem[-1].tail:\n                        # use tail of last child. no `ul` or `ol`.\n                        m = RE.search(elem[-1].tail)\n                        if m:\n                            if not self.assign_attrs(elem, m.group(1), strict=True):\n                                elem[-1].tail = elem[-1].tail[:m.start()]\n                    elif pos is not None and pos > 0 and elem[pos-1].tail:\n                        # use tail of last child before `ul` or `ol`\n                        m = RE.search(elem[pos-1].tail)\n                        if m:\n                            if not self.assign_attrs(elem, m.group(1), strict=True):\n                                elem[pos-1].tail = elem[pos-1].tail[:m.start()]\n                    elif elem.text:\n                        # use text. `ul` is first child.\n                        m = RE.search(elem.text)\n                        if m:\n                            if not self.assign_attrs(elem, m.group(1), strict=True):\n                                elem.text = elem.text[:m.start()]\n                elif len(elem) and elem[-1].tail:\n                    # has children. Get from tail of last child\n                    m = RE.search(elem[-1].tail)\n                    if m:\n                        if not self.assign_attrs(elem, m.group(1), strict=True):\n                            elem[-1].tail = elem[-1].tail[:m.start()]\n                            if isheader(elem):\n                                # clean up trailing #s\n                                elem[-1].tail = elem[-1].tail.rstrip('#').rstrip()\n                elif elem.text:\n                    # no children. Get from text.\n                    m = RE.search(elem.text)\n                    if m:\n                        if not self.assign_attrs(elem, m.group(1), strict=True):\n                            elem.text = elem.text[:m.start()]\n                            if isheader(elem):\n                                # clean up trailing #s\n                                elem.text = elem.text.rstrip('#').rstrip()\n            else:\n                # inline: check for `attrs` at start of tail\n                if elem.tail:\n                    m = self.INLINE_RE.match(elem.tail)\n                    if m:\n                        remainder = self.assign_attrs(elem, m.group(1))\n                        elem.tail = elem.tail[m.end():] + remainder\n\n    def assign_attrs(self, elem: Element, attrs_string: str, *, strict: bool = False) -> str:\n        \"\"\" Assign `attrs` to element.\n\n        If the `attrs_string` has an extra closing curly brace, the remaining text is returned.\n\n        The `strict` argument controls whether to still assign `attrs` if there is a remaining `}`.\n        \"\"\"\n        attrs, remainder = get_attrs_and_remainder(attrs_string)\n        if strict and remainder:\n            return remainder\n\n        for k, v in attrs:\n            if k == '.':\n                # add to class\n                cls = elem.get('class')\n                if cls:\n                    elem.set('class', '{} {}'.format(cls, v))\n                else:\n                    elem.set('class', v)\n            else:\n                # assign attribute `k` with `v`\n                elem.set(self.sanitize_name(k), v)\n        # The text that we initially over-matched will be put back.\n        return remainder\n\n    def sanitize_name(self, name: str) -> str:\n        \"\"\"\n        Sanitize name as 'an XML Name, minus the `:`.'\n        See <https://www.w3.org/TR/REC-xml-names/#NT-NCName>.\n        \"\"\"\n        return self.NAME_RE.sub('_', name)\n\n\nclass AttrListExtension(Extension):\n    \"\"\" Attribute List extension for Python-Markdown \"\"\"\n    def extendMarkdown(self, md):\n        md.treeprocessors.register(AttrListTreeprocessor(md), 'attr_list', 8)\n        md.registerExtension(self)\n\n\ndef makeExtension(**kwargs):  # pragma: no cover\n    return AttrListExtension(**kwargs)\n","size_bytes":7838},"markdown/extensions/codehilite.py":{"content":"# CodeHilite Extension for Python-Markdown\n# ========================================\n\n# Adds code/syntax highlighting to standard Python-Markdown code blocks.\n\n# See https://Python-Markdown.github.io/extensions/code_hilite\n# for documentation.\n\n# Original code Copyright 2006-2008 [Waylan Limberg](http://achinghead.com/).\n\n# All changes Copyright 2008-2014 The Python Markdown Project\n\n# License: [BSD](https://opensource.org/licenses/bsd-license.php)\n\n\"\"\"\nAdds code/syntax highlighting to standard Python-Markdown code blocks.\n\nSee the [documentation](https://Python-Markdown.github.io/extensions/code_hilite)\nfor details.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom . import Extension\nfrom ..treeprocessors import Treeprocessor\nfrom ..util import parseBoolValue\nfrom typing import TYPE_CHECKING, Callable, Any\n\nif TYPE_CHECKING:  # pragma: no cover\n    import xml.etree.ElementTree as etree\n\ntry:  # pragma: no cover\n    from pygments import highlight\n    from pygments.lexers import get_lexer_by_name, guess_lexer\n    from pygments.formatters import get_formatter_by_name\n    from pygments.util import ClassNotFound\n    pygments = True\nexcept ImportError:  # pragma: no cover\n    pygments = False\n\n\ndef parse_hl_lines(expr: str) -> list[int]:\n    \"\"\"Support our syntax for emphasizing certain lines of code.\n\n    `expr` should be like '1 2' to emphasize lines 1 and 2 of a code block.\n    Returns a list of integers, the line numbers to emphasize.\n    \"\"\"\n    if not expr:\n        return []\n\n    try:\n        return list(map(int, expr.split()))\n    except ValueError:  # pragma: no cover\n        return []\n\n\n# ------------------ The Main CodeHilite Class ----------------------\nclass CodeHilite:\n    \"\"\"\n    Determine language of source code, and pass it on to the Pygments highlighter.\n\n    Usage:\n\n    ```python\n    code = CodeHilite(src=some_code, lang='python')\n    html = code.hilite()\n    ```\n\n    Arguments:\n        src: Source string or any object with a `.readline` attribute.\n\n    Keyword arguments:\n        lang (str): String name of Pygments lexer to use for highlighting. Default: `None`.\n        guess_lang (bool): Auto-detect which lexer to use.\n            Ignored if `lang` is set to a valid value. Default: `True`.\n        use_pygments (bool): Pass code to Pygments for code highlighting. If `False`, the code is\n            instead wrapped for highlighting by a JavaScript library. Default: `True`.\n        pygments_formatter (str): The name of a Pygments formatter or a formatter class used for\n            highlighting the code blocks. Default: `html`.\n        linenums (bool): An alias to Pygments `linenos` formatter option. Default: `None`.\n        css_class (str): An alias to Pygments `cssclass` formatter option. Default: 'codehilite'.\n        lang_prefix (str): Prefix prepended to the language. Default: \"language-\".\n\n    Other Options:\n\n    Any other options are accepted and passed on to the lexer and formatter. Therefore,\n    valid options include any options which are accepted by the `html` formatter or\n    whichever lexer the code's language uses. Note that most lexers do not have any\n    options. However, a few have very useful options, such as PHP's `startinline` option.\n    Any invalid options are ignored without error.\n\n    * **Formatter options**: <https://pygments.org/docs/formatters/#HtmlFormatter>\n    * **Lexer Options**: <https://pygments.org/docs/lexers/>\n\n    Additionally, when Pygments is enabled, the code's language is passed to the\n    formatter as an extra option `lang_str`, whose value being `{lang_prefix}{lang}`.\n    This option has no effect to the Pygments' builtin formatters.\n\n    Advanced Usage:\n\n    ```python\n    code = CodeHilite(\n        src = some_code,\n        lang = 'php',\n        startinline = True,      # Lexer option. Snippet does not start with `<?php`.\n        linenostart = 42,        # Formatter option. Snippet starts on line 42.\n        hl_lines = [45, 49, 50], # Formatter option. Highlight lines 45, 49, and 50.\n        linenos = 'inline'       # Formatter option. Avoid alignment problems.\n    )\n    html = code.hilite()\n    ```\n\n    \"\"\"\n\n    def __init__(self, src: str, **options):\n        self.src = src\n        self.lang: str | None = options.pop('lang', None)\n        self.guess_lang: bool = options.pop('guess_lang', True)\n        self.use_pygments: bool = options.pop('use_pygments', True)\n        self.lang_prefix: str = options.pop('lang_prefix', 'language-')\n        self.pygments_formatter: str | Callable = options.pop('pygments_formatter', 'html')\n\n        if 'linenos' not in options:\n            options['linenos'] = options.pop('linenums', None)\n        if 'cssclass' not in options:\n            options['cssclass'] = options.pop('css_class', 'codehilite')\n        if 'wrapcode' not in options:\n            # Override Pygments default\n            options['wrapcode'] = True\n        # Disallow use of `full` option\n        options['full'] = False\n\n        self.options = options\n\n    def hilite(self, shebang: bool = True) -> str:\n        \"\"\"\n        Pass code to the [Pygments](https://pygments.org/) highlighter with\n        optional line numbers. The output should then be styled with CSS to\n        your liking. No styles are applied by default - only styling hooks\n        (i.e.: `<span class=\"k\">`).\n\n        returns : A string of html.\n\n        \"\"\"\n\n        self.src = self.src.strip('\\n')\n\n        if self.lang is None and shebang:\n            self._parseHeader()\n\n        if pygments and self.use_pygments:\n            try:\n                lexer = get_lexer_by_name(self.lang, **self.options)\n            except ValueError:\n                try:\n                    if self.guess_lang:\n                        lexer = guess_lexer(self.src, **self.options)\n                    else:\n                        lexer = get_lexer_by_name('text', **self.options)\n                except ValueError:  # pragma: no cover\n                    lexer = get_lexer_by_name('text', **self.options)\n            if not self.lang:\n                # Use the guessed lexer's language instead\n                self.lang = lexer.aliases[0]\n            lang_str = f'{self.lang_prefix}{self.lang}'\n            if isinstance(self.pygments_formatter, str):\n                try:\n                    formatter = get_formatter_by_name(self.pygments_formatter, **self.options)\n                except ClassNotFound:\n                    formatter = get_formatter_by_name('html', **self.options)\n            else:\n                formatter = self.pygments_formatter(lang_str=lang_str, **self.options)\n            return highlight(self.src, lexer, formatter)\n        else:\n            # just escape and build markup usable by JavaScript highlighting libraries\n            txt = self.src.replace('&', '&amp;')\n            txt = txt.replace('<', '&lt;')\n            txt = txt.replace('>', '&gt;')\n            txt = txt.replace('\"', '&quot;')\n            classes = []\n            if self.lang:\n                classes.append('{}{}'.format(self.lang_prefix, self.lang))\n            if self.options['linenos']:\n                classes.append('linenums')\n            class_str = ''\n            if classes:\n                class_str = ' class=\"{}\"'.format(' '.join(classes))\n            return '<pre class=\"{}\"><code{}>{}\\n</code></pre>\\n'.format(\n                self.options['cssclass'],\n                class_str,\n                txt\n            )\n\n    def _parseHeader(self) -> None:\n        \"\"\"\n        Determines language of a code block from shebang line and whether the\n        said line should be removed or left in place. If the shebang line\n        contains a path (even a single /) then it is assumed to be a real\n        shebang line and left alone. However, if no path is given\n        (e.i.: `#!python` or `:::python`) then it is assumed to be a mock shebang\n        for language identification of a code fragment and removed from the\n        code block prior to processing for code highlighting. When a mock\n        shebang (e.i: `#!python`) is found, line numbering is turned on. When\n        colons are found in place of a shebang (e.i.: `:::python`), line\n        numbering is left in the current state - off by default.\n\n        Also parses optional list of highlight lines, like:\n\n            :::python hl_lines=\"1 3\"\n        \"\"\"\n\n        import re\n\n        # split text into lines\n        lines = self.src.split(\"\\n\")\n        # pull first line to examine\n        fl = lines.pop(0)\n\n        c = re.compile(r'''\n            (?:(?:^::+)|(?P<shebang>^[#]!)) # Shebang or 2 or more colons\n            (?P<path>(?:/\\w+)*[/ ])?        # Zero or 1 path\n            (?P<lang>[\\w#.+-]*)             # The language\n            \\s*                             # Arbitrary whitespace\n            # Optional highlight lines, single- or double-quote-delimited\n            (hl_lines=(?P<quot>\"|')(?P<hl_lines>.*?)(?P=quot))?\n            ''',  re.VERBOSE)\n        # search first line for shebang\n        m = c.search(fl)\n        if m:\n            # we have a match\n            try:\n                self.lang = m.group('lang').lower()\n            except IndexError:  # pragma: no cover\n                self.lang = None\n            if m.group('path'):\n                # path exists - restore first line\n                lines.insert(0, fl)\n            if self.options['linenos'] is None and m.group('shebang'):\n                # Overridable and Shebang exists - use line numbers\n                self.options['linenos'] = True\n\n            self.options['hl_lines'] = parse_hl_lines(m.group('hl_lines'))\n        else:\n            # No match\n            lines.insert(0, fl)\n\n        self.src = \"\\n\".join(lines).strip(\"\\n\")\n\n\n# ------------------ The Markdown Extension -------------------------------\n\n\nclass HiliteTreeprocessor(Treeprocessor):\n    \"\"\" Highlight source code in code blocks. \"\"\"\n\n    config: dict[str, Any]\n\n    def code_unescape(self, text: str) -> str:\n        \"\"\"Unescape code.\"\"\"\n        text = text.replace(\"&lt;\", \"<\")\n        text = text.replace(\"&gt;\", \">\")\n        # Escaped '&' should be replaced at the end to avoid\n        # conflicting with < and >.\n        text = text.replace(\"&amp;\", \"&\")\n        return text\n\n    def run(self, root: etree.Element) -> None:\n        \"\"\" Find code blocks and store in `htmlStash`. \"\"\"\n        blocks = root.iter('pre')\n        for block in blocks:\n            if len(block) == 1 and block[0].tag == 'code':\n                local_config = self.config.copy()\n                text = block[0].text\n                if text is None:\n                    continue\n                code = CodeHilite(\n                    self.code_unescape(text),\n                    tab_length=self.md.tab_length,\n                    style=local_config.pop('pygments_style', 'default'),\n                    **local_config\n                )\n                placeholder = self.md.htmlStash.store(code.hilite())\n                # Clear code block in `etree` instance\n                block.clear()\n                # Change to `p` element which will later\n                # be removed when inserting raw html\n                block.tag = 'p'\n                block.text = placeholder\n\n\nclass CodeHiliteExtension(Extension):\n    \"\"\" Add source code highlighting to markdown code blocks. \"\"\"\n\n    def __init__(self, **kwargs):\n        # define default configs\n        self.config = {\n            'linenums': [\n                None, \"Use lines numbers. True|table|inline=yes, False=no, None=auto. Default: `None`.\"\n            ],\n            'guess_lang': [\n                True, \"Automatic language detection - Default: `True`.\"\n            ],\n            'css_class': [\n                \"codehilite\", \"Set class name for wrapper <div> - Default: `codehilite`.\"\n            ],\n            'pygments_style': [\n                'default', 'Pygments HTML Formatter Style (Colorscheme). Default: `default`.'\n            ],\n            'noclasses': [\n                False, 'Use inline styles instead of CSS classes - Default `False`.'\n            ],\n            'use_pygments': [\n                True, 'Highlight code blocks with pygments. Disable if using a JavaScript library. Default: `True`.'\n            ],\n            'lang_prefix': [\n                'language-', 'Prefix prepended to the language when `use_pygments` is false. Default: `language-`.'\n            ],\n            'pygments_formatter': [\n                'html', 'Use a specific formatter for Pygments highlighting. Default: `html`.'\n            ],\n        }\n        \"\"\" Default configuration options. \"\"\"\n\n        for key, value in kwargs.items():\n            if key in self.config:\n                self.setConfig(key, value)\n            else:\n                # manually set unknown keywords.\n                if isinstance(value, str):\n                    try:\n                        # Attempt to parse `str` as a boolean value\n                        value = parseBoolValue(value, preserve_none=True)\n                    except ValueError:\n                        pass  # Assume it's not a boolean value. Use as-is.\n                self.config[key] = [value, '']\n\n    def extendMarkdown(self, md):\n        \"\"\" Add `HilitePostprocessor` to Markdown instance. \"\"\"\n        hiliter = HiliteTreeprocessor(md)\n        hiliter.config = self.getConfigs()\n        md.treeprocessors.register(hiliter, 'hilite', 30)\n\n        md.registerExtension(self)\n\n\ndef makeExtension(**kwargs):  # pragma: no cover\n    return CodeHiliteExtension(**kwargs)\n","size_bytes":13503},"markdown/extensions/def_list.py":{"content":"# Definition List Extension for Python-Markdown\n# =============================================\n\n# Adds parsing of Definition Lists to Python-Markdown.\n\n# See https://Python-Markdown.github.io/extensions/definition_lists\n# for documentation.\n\n# Original code Copyright 2008 [Waylan Limberg](http://achinghead.com)\n\n# All changes Copyright 2008-2014 The Python Markdown Project\n\n# License: [BSD](https://opensource.org/licenses/bsd-license.php)\n\n\"\"\"\nAdds parsing of Definition Lists to Python-Markdown.\n\nSee the [documentation](https://Python-Markdown.github.io/extensions/definition_lists)\nfor details.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom . import Extension\nfrom ..blockprocessors import BlockProcessor, ListIndentProcessor\nimport xml.etree.ElementTree as etree\nimport re\n\n\nclass DefListProcessor(BlockProcessor):\n    \"\"\" Process Definition Lists. \"\"\"\n\n    RE = re.compile(r'(^|\\n)[ ]{0,3}:[ ]{1,3}(.*?)(\\n|$)')\n    NO_INDENT_RE = re.compile(r'^[ ]{0,3}[^ :]')\n\n    def test(self, parent: etree.Element, block: str) -> bool:\n        return bool(self.RE.search(block))\n\n    def run(self, parent: etree.Element, blocks: list[str]) -> bool | None:\n\n        raw_block = blocks.pop(0)\n        m = self.RE.search(raw_block)\n        terms = [term.strip() for term in\n                 raw_block[:m.start()].split('\\n') if term.strip()]\n        block = raw_block[m.end():]\n        no_indent = self.NO_INDENT_RE.match(block)\n        if no_indent:\n            d, theRest = (block, None)\n        else:\n            d, theRest = self.detab(block)\n        if d:\n            d = '{}\\n{}'.format(m.group(2), d)\n        else:\n            d = m.group(2)\n        sibling = self.lastChild(parent)\n        if not terms and sibling is None:\n            # This is not a definition item. Most likely a paragraph that\n            # starts with a colon at the beginning of a document or list.\n            blocks.insert(0, raw_block)\n            return False\n        if not terms and sibling.tag == 'p':\n            # The previous paragraph contains the terms\n            state = 'looselist'\n            terms = sibling.text.split('\\n')\n            parent.remove(sibling)\n            # Acquire new sibling\n            sibling = self.lastChild(parent)\n        else:\n            state = 'list'\n\n        if sibling is not None and sibling.tag == 'dl':\n            # This is another item on an existing list\n            dl = sibling\n            if not terms and len(dl) and dl[-1].tag == 'dd' and len(dl[-1]):\n                state = 'looselist'\n        else:\n            # This is a new list\n            dl = etree.SubElement(parent, 'dl')\n        # Add terms\n        for term in terms:\n            dt = etree.SubElement(dl, 'dt')\n            dt.text = term\n        # Add definition\n        self.parser.state.set(state)\n        dd = etree.SubElement(dl, 'dd')\n        self.parser.parseBlocks(dd, [d])\n        self.parser.state.reset()\n\n        if theRest:\n            blocks.insert(0, theRest)\n\n\nclass DefListIndentProcessor(ListIndentProcessor):\n    \"\"\" Process indented children of definition list items. \"\"\"\n\n    # Definition lists need to be aware of all list types\n    ITEM_TYPES = ['dd', 'li']\n    \"\"\" Include `dd` in list item types. \"\"\"\n    LIST_TYPES = ['dl', 'ol', 'ul']\n    \"\"\" Include `dl` is list types. \"\"\"\n\n    def create_item(self, parent: etree.Element, block: str) -> None:\n        \"\"\" Create a new `dd` or `li` (depending on parent) and parse the block with it as the parent. \"\"\"\n\n        dd = etree.SubElement(parent, 'dd')\n        self.parser.parseBlocks(dd, [block])\n\n\nclass DefListExtension(Extension):\n    \"\"\" Add definition lists to Markdown. \"\"\"\n\n    def extendMarkdown(self, md):\n        \"\"\" Add an instance of `DefListProcessor` to `BlockParser`. \"\"\"\n        md.parser.blockprocessors.register(DefListIndentProcessor(md.parser), 'defindent', 85)\n        md.parser.blockprocessors.register(DefListProcessor(md.parser), 'deflist', 25)\n\n\ndef makeExtension(**kwargs):  # pragma: no cover\n    return DefListExtension(**kwargs)\n","size_bytes":4029},"markdown/extensions/extra.py":{"content":"# Python-Markdown Extra Extension\n# ===============================\n\n# A compilation of various Python-Markdown extensions that imitates\n# [PHP Markdown Extra](http://michelf.com/projects/php-markdown/extra/).\n\n# See https://Python-Markdown.github.io/extensions/extra\n# for documentation.\n\n# Copyright The Python Markdown Project\n\n# License: [BSD](https://opensource.org/licenses/bsd-license.php)\n\n\"\"\"\nA compilation of various Python-Markdown extensions that imitates\n[PHP Markdown Extra](http://michelf.com/projects/php-markdown/extra/).\n\nNote that each of the individual extensions still need to be available\non your `PYTHONPATH`. This extension simply wraps them all up as a\nconvenience so that only one extension needs to be listed when\ninitiating Markdown. See the documentation for each individual\nextension for specifics about that extension.\n\nThere may be additional extensions that are distributed with\nPython-Markdown that are not included here in Extra. Those extensions\nare not part of PHP Markdown Extra, and therefore, not part of\nPython-Markdown Extra. If you really would like Extra to include\nadditional extensions, we suggest creating your own clone of Extra\nunder a different name. You could also edit the `extensions` global\nvariable defined below, but be aware that such changes may be lost\nwhen you upgrade to any future version of Python-Markdown.\n\nSee the [documentation](https://Python-Markdown.github.io/extensions/extra)\nfor details.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom . import Extension\n\nextensions = [\n    'fenced_code',\n    'footnotes',\n    'attr_list',\n    'def_list',\n    'tables',\n    'abbr',\n    'md_in_html'\n]\n\"\"\" The list of included extensions. \"\"\"\n\n\nclass ExtraExtension(Extension):\n    \"\"\" Add various extensions to Markdown class.\"\"\"\n\n    def __init__(self, **kwargs):\n        \"\"\" `config` is a dumb holder which gets passed to the actual extension later. \"\"\"\n        self.config = kwargs\n\n    def extendMarkdown(self, md):\n        \"\"\" Register extension instances. \"\"\"\n        md.registerExtensions(extensions, self.config)\n\n\ndef makeExtension(**kwargs):  # pragma: no cover\n    return ExtraExtension(**kwargs)\n","size_bytes":2163},"markdown/extensions/fenced_code.py":{"content":"# Fenced Code Extension for Python Markdown\n# =========================================\n\n# This extension adds Fenced Code Blocks to Python-Markdown.\n\n# See https://Python-Markdown.github.io/extensions/fenced_code_blocks\n# for documentation.\n\n# Original code Copyright 2007-2008 [Waylan Limberg](http://achinghead.com/).\n\n# All changes Copyright 2008-2014 The Python Markdown Project\n\n# License: [BSD](https://opensource.org/licenses/bsd-license.php)\n\n\"\"\"\nThis extension adds Fenced Code Blocks to Python-Markdown.\n\nSee the [documentation](https://Python-Markdown.github.io/extensions/fenced_code_blocks)\nfor details.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom textwrap import dedent\nfrom . import Extension\nfrom ..preprocessors import Preprocessor\nfrom .codehilite import CodeHilite, CodeHiliteExtension, parse_hl_lines\nfrom .attr_list import get_attrs_and_remainder, AttrListExtension\nfrom ..util import parseBoolValue\nfrom ..serializers import _escape_attrib_html\nimport re\nfrom typing import TYPE_CHECKING, Any, Iterable\n\nif TYPE_CHECKING:  # pragma: no cover\n    from markdown import Markdown\n\n\nclass FencedCodeExtension(Extension):\n    def __init__(self, **kwargs):\n        self.config = {\n            'lang_prefix': ['language-', 'Prefix prepended to the language. Default: \"language-\"']\n        }\n        \"\"\" Default configuration options. \"\"\"\n        super().__init__(**kwargs)\n\n    def extendMarkdown(self, md):\n        \"\"\" Add `FencedBlockPreprocessor` to the Markdown instance. \"\"\"\n        md.registerExtension(self)\n\n        md.preprocessors.register(FencedBlockPreprocessor(md, self.getConfigs()), 'fenced_code_block', 25)\n\n\nclass FencedBlockPreprocessor(Preprocessor):\n    \"\"\" Find and extract fenced code blocks. \"\"\"\n\n    FENCED_BLOCK_RE = re.compile(\n        dedent(r'''\n            (?P<fence>^(?:~{3,}|`{3,}))[ ]*                          # opening fence\n            ((\\{(?P<attrs>[^\\n]*)\\})|                                # (optional {attrs} or\n            (\\.?(?P<lang>[\\w#.+-]*)[ ]*)?                            # optional (.)lang\n            (hl_lines=(?P<quot>\"|')(?P<hl_lines>.*?)(?P=quot)[ ]*)?) # optional hl_lines)\n            \\n                                                       # newline (end of opening fence)\n            (?P<code>.*?)(?<=\\n)                                     # the code block\n            (?P=fence)[ ]*$                                          # closing fence\n        '''),\n        re.MULTILINE | re.DOTALL | re.VERBOSE\n    )\n\n    def __init__(self, md: Markdown, config: dict[str, Any]):\n        super().__init__(md)\n        self.config = config\n        self.checked_for_deps = False\n        self.codehilite_conf: dict[str, Any] = {}\n        self.use_attr_list = False\n        # List of options to convert to boolean values\n        self.bool_options = [\n            'linenums',\n            'guess_lang',\n            'noclasses',\n            'use_pygments'\n        ]\n\n    def run(self, lines: list[str]) -> list[str]:\n        \"\"\" Match and store Fenced Code Blocks in the `HtmlStash`. \"\"\"\n\n        # Check for dependent extensions\n        if not self.checked_for_deps:\n            for ext in self.md.registeredExtensions:\n                if isinstance(ext, CodeHiliteExtension):\n                    self.codehilite_conf = ext.getConfigs()\n                if isinstance(ext, AttrListExtension):\n                    self.use_attr_list = True\n\n            self.checked_for_deps = True\n\n        text = \"\\n\".join(lines)\n        index = 0\n        while 1:\n            m = self.FENCED_BLOCK_RE.search(text, index)\n            if m:\n                lang, id, classes, config = None, '', [], {}\n                if m.group('attrs'):\n                    attrs, remainder = get_attrs_and_remainder(m.group('attrs'))\n                    if remainder:  # Does not have correctly matching curly braces, so the syntax is invalid.\n                        index = m.end('attrs')  # Explicitly skip over this, to prevent an infinite loop.\n                        continue\n                    id, classes, config = self.handle_attrs(attrs)\n                    if len(classes):\n                        lang = classes.pop(0)\n                else:\n                    if m.group('lang'):\n                        lang = m.group('lang')\n                    if m.group('hl_lines'):\n                        # Support `hl_lines` outside of `attrs` for backward-compatibility\n                        config['hl_lines'] = parse_hl_lines(m.group('hl_lines'))\n\n                # If `config` is not empty, then the `codehighlite` extension\n                # is enabled, so we call it to highlight the code\n                if self.codehilite_conf and self.codehilite_conf['use_pygments'] and config.get('use_pygments', True):\n                    local_config = self.codehilite_conf.copy()\n                    local_config.update(config)\n                    # Combine classes with `cssclass`. Ensure `cssclass` is at end\n                    # as Pygments appends a suffix under certain circumstances.\n                    # Ignore ID as Pygments does not offer an option to set it.\n                    if classes:\n                        local_config['css_class'] = '{} {}'.format(\n                            ' '.join(classes),\n                            local_config['css_class']\n                        )\n                    highliter = CodeHilite(\n                        m.group('code'),\n                        lang=lang,\n                        style=local_config.pop('pygments_style', 'default'),\n                        **local_config\n                    )\n\n                    code = highliter.hilite(shebang=False)\n                else:\n                    id_attr = lang_attr = class_attr = kv_pairs = ''\n                    if lang:\n                        prefix = self.config.get('lang_prefix', 'language-')\n                        lang_attr = f' class=\"{prefix}{_escape_attrib_html(lang)}\"'\n                    if classes:\n                        class_attr = f' class=\"{_escape_attrib_html(\" \".join(classes))}\"'\n                    if id:\n                        id_attr = f' id=\"{_escape_attrib_html(id)}\"'\n                    if self.use_attr_list and config and not config.get('use_pygments', False):\n                        # Only assign key/value pairs to code element if `attr_list` extension is enabled, key/value\n                        # pairs were defined on the code block, and the `use_pygments` key was not set to `True`. The\n                        # `use_pygments` key could be either set to `False` or not defined. It is omitted from output.\n                        kv_pairs = ''.join(\n                            f' {k}=\"{_escape_attrib_html(v)}\"' for k, v in config.items() if k != 'use_pygments'\n                        )\n                    code = self._escape(m.group('code'))\n                    code = f'<pre{id_attr}{class_attr}><code{lang_attr}{kv_pairs}>{code}</code></pre>'\n\n                placeholder = self.md.htmlStash.store(code)\n                text = f'{text[:m.start()]}\\n{placeholder}\\n{text[m.end():]}'\n                # Continue from after the replaced text in the next iteration.\n                index = m.start() + 1 + len(placeholder)\n            else:\n                break\n        return text.split(\"\\n\")\n\n    def handle_attrs(self, attrs: Iterable[tuple[str, str]]) -> tuple[str, list[str], dict[str, Any]]:\n        \"\"\" Return tuple: `(id, [list, of, classes], {configs})` \"\"\"\n        id = ''\n        classes = []\n        configs = {}\n        for k, v in attrs:\n            if k == 'id':\n                id = v\n            elif k == '.':\n                classes.append(v)\n            elif k == 'hl_lines':\n                configs[k] = parse_hl_lines(v)\n            elif k in self.bool_options:\n                configs[k] = parseBoolValue(v, fail_on_errors=False, preserve_none=True)\n            else:\n                configs[k] = v\n        return id, classes, configs\n\n    def _escape(self, txt: str) -> str:\n        \"\"\" basic html escaping \"\"\"\n        txt = txt.replace('&', '&amp;')\n        txt = txt.replace('<', '&lt;')\n        txt = txt.replace('>', '&gt;')\n        txt = txt.replace('\"', '&quot;')\n        return txt\n\n\ndef makeExtension(**kwargs):  # pragma: no cover\n    return FencedCodeExtension(**kwargs)\n","size_bytes":8300},"markdown/extensions/footnotes.py":{"content":"# Footnotes Extension for Python-Markdown\n# =======================================\n\n# Adds footnote handling to Python-Markdown.\n\n# See https://Python-Markdown.github.io/extensions/footnotes\n# for documentation.\n\n# Copyright The Python Markdown Project\n\n# License: [BSD](https://opensource.org/licenses/bsd-license.php)\n\n\"\"\"\nAdds footnote handling to Python-Markdown.\n\nSee the [documentation](https://Python-Markdown.github.io/extensions/footnotes)\nfor details.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom . import Extension\nfrom ..blockprocessors import BlockProcessor\nfrom ..inlinepatterns import InlineProcessor\nfrom ..treeprocessors import Treeprocessor\nfrom ..postprocessors import Postprocessor\nfrom .. import util\nfrom collections import OrderedDict\nimport re\nimport copy\nimport xml.etree.ElementTree as etree\n\nFN_BACKLINK_TEXT = util.STX + \"zz1337820767766393qq\" + util.ETX\nNBSP_PLACEHOLDER = util.STX + \"qq3936677670287331zz\" + util.ETX\nRE_REF_ID = re.compile(r'(fnref)(\\d+)')\n\n\nclass FootnoteExtension(Extension):\n    \"\"\" Footnote Extension. \"\"\"\n\n    def __init__(self, **kwargs):\n        \"\"\" Setup configs. \"\"\"\n\n        self.config = {\n            'PLACE_MARKER': [\n                '///Footnotes Go Here///', 'The text string that marks where the footnotes go'\n            ],\n            'UNIQUE_IDS': [\n                False, 'Avoid name collisions across multiple calls to `reset()`.'\n            ],\n            'BACKLINK_TEXT': [\n                '&#8617;', \"The text string that links from the footnote to the reader's place.\"\n            ],\n            'SUPERSCRIPT_TEXT': [\n                '{}', \"The text string that links from the reader's place to the footnote.\"\n            ],\n            'BACKLINK_TITLE': [\n                'Jump back to footnote %d in the text',\n                'The text string used for the title HTML attribute of the backlink. '\n                '%d will be replaced by the footnote number.'\n            ],\n            'SEPARATOR': [\n                ':', 'Footnote separator.'\n            ]\n        }\n        \"\"\" Default configuration options. \"\"\"\n        super().__init__(**kwargs)\n\n        # In multiple invocations, emit links that don't get tangled.\n        self.unique_prefix = 0\n        self.found_refs: dict[str, int] = {}\n        self.used_refs: set[str] = set()\n\n        self.reset()\n\n    def extendMarkdown(self, md):\n        \"\"\" Add pieces to Markdown. \"\"\"\n        md.registerExtension(self)\n        self.parser = md.parser\n        self.md = md\n        # Insert a `blockprocessor` before `ReferencePreprocessor`\n        md.parser.blockprocessors.register(FootnoteBlockProcessor(self), 'footnote', 17)\n\n        # Insert an inline pattern before `ImageReferencePattern`\n        FOOTNOTE_RE = r'\\[\\^([^\\]]*)\\]'  # blah blah [^1] blah\n        md.inlinePatterns.register(FootnoteInlineProcessor(FOOTNOTE_RE, self), 'footnote', 175)\n        # Insert a tree-processor that would actually add the footnote div\n        # This must be before all other tree-processors (i.e., `inline` and\n        # `codehilite`) so they can run on the the contents of the div.\n        md.treeprocessors.register(FootnoteTreeprocessor(self), 'footnote', 50)\n\n        # Insert a tree-processor that will run after inline is done.\n        # In this tree-processor we want to check our duplicate footnote tracker\n        # And add additional `backrefs` to the footnote pointing back to the\n        # duplicated references.\n        md.treeprocessors.register(FootnotePostTreeprocessor(self), 'footnote-duplicate', 15)\n\n        # Insert a postprocessor after amp_substitute processor\n        md.postprocessors.register(FootnotePostprocessor(self), 'footnote', 25)\n\n    def reset(self) -> None:\n        \"\"\" Clear footnotes on reset, and prepare for distinct document. \"\"\"\n        self.footnotes: OrderedDict[str, str] = OrderedDict()\n        self.unique_prefix += 1\n        self.found_refs = {}\n        self.used_refs = set()\n\n    def unique_ref(self, reference: str, found: bool = False) -> str:\n        \"\"\" Get a unique reference if there are duplicates. \"\"\"\n        if not found:\n            return reference\n\n        original_ref = reference\n        while reference in self.used_refs:\n            ref, rest = reference.split(self.get_separator(), 1)\n            m = RE_REF_ID.match(ref)\n            if m:\n                reference = '%s%d%s%s' % (m.group(1), int(m.group(2))+1, self.get_separator(), rest)\n            else:\n                reference = '%s%d%s%s' % (ref, 2, self.get_separator(), rest)\n\n        self.used_refs.add(reference)\n        if original_ref in self.found_refs:\n            self.found_refs[original_ref] += 1\n        else:\n            self.found_refs[original_ref] = 1\n        return reference\n\n    def findFootnotesPlaceholder(\n        self, root: etree.Element\n    ) -> tuple[etree.Element, etree.Element, bool] | None:\n        \"\"\" Return ElementTree Element that contains Footnote placeholder. \"\"\"\n        def finder(element):\n            for child in element:\n                if child.text:\n                    if child.text.find(self.getConfig(\"PLACE_MARKER\")) > -1:\n                        return child, element, True\n                if child.tail:\n                    if child.tail.find(self.getConfig(\"PLACE_MARKER\")) > -1:\n                        return child, element, False\n                child_res = finder(child)\n                if child_res is not None:\n                    return child_res\n            return None\n\n        res = finder(root)\n        return res\n\n    def setFootnote(self, id: str, text: str) -> None:\n        \"\"\" Store a footnote for later retrieval. \"\"\"\n        self.footnotes[id] = text\n\n    def get_separator(self) -> str:\n        \"\"\" Get the footnote separator. \"\"\"\n        return self.getConfig(\"SEPARATOR\")\n\n    def makeFootnoteId(self, id: str) -> str:\n        \"\"\" Return footnote link id. \"\"\"\n        if self.getConfig(\"UNIQUE_IDS\"):\n            return 'fn%s%d-%s' % (self.get_separator(), self.unique_prefix, id)\n        else:\n            return 'fn{}{}'.format(self.get_separator(), id)\n\n    def makeFootnoteRefId(self, id: str, found: bool = False) -> str:\n        \"\"\" Return footnote back-link id. \"\"\"\n        if self.getConfig(\"UNIQUE_IDS\"):\n            return self.unique_ref('fnref%s%d-%s' % (self.get_separator(), self.unique_prefix, id), found)\n        else:\n            return self.unique_ref('fnref{}{}'.format(self.get_separator(), id), found)\n\n    def makeFootnotesDiv(self, root: etree.Element) -> etree.Element | None:\n        \"\"\" Return `div` of footnotes as `etree` Element. \"\"\"\n\n        if not list(self.footnotes.keys()):\n            return None\n\n        div = etree.Element(\"div\")\n        div.set('class', 'footnote')\n        etree.SubElement(div, \"hr\")\n        ol = etree.SubElement(div, \"ol\")\n        surrogate_parent = etree.Element(\"div\")\n\n        # Backward compatibility with old '%d' placeholder\n        backlink_title = self.getConfig(\"BACKLINK_TITLE\").replace(\"%d\", \"{}\")\n\n        for index, id in enumerate(self.footnotes.keys(), start=1):\n            li = etree.SubElement(ol, \"li\")\n            li.set(\"id\", self.makeFootnoteId(id))\n            # Parse footnote with surrogate parent as `li` cannot be used.\n            # List block handlers have special logic to deal with `li`.\n            # When we are done parsing, we will copy everything over to `li`.\n            self.parser.parseChunk(surrogate_parent, self.footnotes[id])\n            for el in list(surrogate_parent):\n                li.append(el)\n                surrogate_parent.remove(el)\n            backlink = etree.Element(\"a\")\n            backlink.set(\"href\", \"#\" + self.makeFootnoteRefId(id))\n            backlink.set(\"class\", \"footnote-backref\")\n            backlink.set(\n                \"title\",\n                backlink_title.format(index)\n            )\n            backlink.text = FN_BACKLINK_TEXT\n\n            if len(li):\n                node = li[-1]\n                if node.tag == \"p\":\n                    node.text = node.text + NBSP_PLACEHOLDER\n                    node.append(backlink)\n                else:\n                    p = etree.SubElement(li, \"p\")\n                    p.append(backlink)\n        return div\n\n\nclass FootnoteBlockProcessor(BlockProcessor):\n    \"\"\" Find all footnote references and store for later use. \"\"\"\n\n    RE = re.compile(r'^[ ]{0,3}\\[\\^([^\\]]*)\\]:[ ]*(.*)$', re.MULTILINE)\n\n    def __init__(self, footnotes: FootnoteExtension):\n        super().__init__(footnotes.parser)\n        self.footnotes = footnotes\n\n    def test(self, parent: etree.Element, block: str) -> bool:\n        return True\n\n    def run(self, parent: etree.Element, blocks: list[str]) -> bool:\n        \"\"\" Find, set, and remove footnote definitions. \"\"\"\n        block = blocks.pop(0)\n        m = self.RE.search(block)\n        if m:\n            id = m.group(1)\n            fn_blocks = [m.group(2)]\n\n            # Handle rest of block\n            therest = block[m.end():].lstrip('\\n')\n            m2 = self.RE.search(therest)\n            if m2:\n                # Another footnote exists in the rest of this block.\n                # Any content before match is continuation of this footnote, which may be lazily indented.\n                before = therest[:m2.start()].rstrip('\\n')\n                fn_blocks[0] = '\\n'.join([fn_blocks[0], self.detab(before)]).lstrip('\\n')\n                # Add back to blocks everything from beginning of match forward for next iteration.\n                blocks.insert(0, therest[m2.start():])\n            else:\n                # All remaining lines of block are continuation of this footnote, which may be lazily indented.\n                fn_blocks[0] = '\\n'.join([fn_blocks[0], self.detab(therest)]).strip('\\n')\n\n                # Check for child elements in remaining blocks.\n                fn_blocks.extend(self.detectTabbed(blocks))\n\n            footnote = \"\\n\\n\".join(fn_blocks)\n            self.footnotes.setFootnote(id, footnote.rstrip())\n\n            if block[:m.start()].strip():\n                # Add any content before match back to blocks as separate block\n                blocks.insert(0, block[:m.start()].rstrip('\\n'))\n            return True\n        # No match. Restore block.\n        blocks.insert(0, block)\n        return False\n\n    def detectTabbed(self, blocks: list[str]) -> list[str]:\n        \"\"\" Find indented text and remove indent before further processing.\n\n        Returns:\n            A list of blocks with indentation removed.\n        \"\"\"\n        fn_blocks = []\n        while blocks:\n            if blocks[0].startswith(' '*4):\n                block = blocks.pop(0)\n                # Check for new footnotes within this block and split at new footnote.\n                m = self.RE.search(block)\n                if m:\n                    # Another footnote exists in this block.\n                    # Any content before match is continuation of this footnote, which may be lazily indented.\n                    before = block[:m.start()].rstrip('\\n')\n                    fn_blocks.append(self.detab(before))\n                    # Add back to blocks everything from beginning of match forward for next iteration.\n                    blocks.insert(0, block[m.start():])\n                    # End of this footnote.\n                    break\n                else:\n                    # Entire block is part of this footnote.\n                    fn_blocks.append(self.detab(block))\n            else:\n                # End of this footnote.\n                break\n        return fn_blocks\n\n    def detab(self, block: str) -> str:\n        \"\"\" Remove one level of indent from a block.\n\n        Preserve lazily indented blocks by only removing indent from indented lines.\n        \"\"\"\n        lines = block.split('\\n')\n        for i, line in enumerate(lines):\n            if line.startswith(' '*4):\n                lines[i] = line[4:]\n        return '\\n'.join(lines)\n\n\nclass FootnoteInlineProcessor(InlineProcessor):\n    \"\"\" `InlineProcessor` for footnote markers in a document's body text. \"\"\"\n\n    def __init__(self, pattern: str, footnotes: FootnoteExtension):\n        super().__init__(pattern)\n        self.footnotes = footnotes\n\n    def handleMatch(self, m: re.Match[str], data: str) -> tuple[etree.Element | None, int | None, int | None]:\n        id = m.group(1)\n        if id in self.footnotes.footnotes.keys():\n            sup = etree.Element(\"sup\")\n            a = etree.SubElement(sup, \"a\")\n            sup.set('id', self.footnotes.makeFootnoteRefId(id, found=True))\n            a.set('href', '#' + self.footnotes.makeFootnoteId(id))\n            a.set('class', 'footnote-ref')\n            a.text = self.footnotes.getConfig(\"SUPERSCRIPT_TEXT\").format(\n                list(self.footnotes.footnotes.keys()).index(id) + 1\n            )\n            return sup, m.start(0), m.end(0)\n        else:\n            return None, None, None\n\n\nclass FootnotePostTreeprocessor(Treeprocessor):\n    \"\"\" Amend footnote div with duplicates. \"\"\"\n\n    def __init__(self, footnotes: FootnoteExtension):\n        self.footnotes = footnotes\n\n    def add_duplicates(self, li: etree.Element, duplicates: int) -> None:\n        \"\"\" Adjust current `li` and add the duplicates: `fnref2`, `fnref3`, etc. \"\"\"\n        for link in li.iter('a'):\n            # Find the link that needs to be duplicated.\n            if link.attrib.get('class', '') == 'footnote-backref':\n                ref, rest = link.attrib['href'].split(self.footnotes.get_separator(), 1)\n                # Duplicate link the number of times we need to\n                # and point the to the appropriate references.\n                links = []\n                for index in range(2, duplicates + 1):\n                    sib_link = copy.deepcopy(link)\n                    sib_link.attrib['href'] = '%s%d%s%s' % (ref, index, self.footnotes.get_separator(), rest)\n                    links.append(sib_link)\n                    self.offset += 1\n                # Add all the new duplicate links.\n                el = list(li)[-1]\n                for link in links:\n                    el.append(link)\n                break\n\n    def get_num_duplicates(self, li: etree.Element) -> int:\n        \"\"\" Get the number of duplicate refs of the footnote. \"\"\"\n        fn, rest = li.attrib.get('id', '').split(self.footnotes.get_separator(), 1)\n        link_id = '{}ref{}{}'.format(fn, self.footnotes.get_separator(), rest)\n        return self.footnotes.found_refs.get(link_id, 0)\n\n    def handle_duplicates(self, parent: etree.Element) -> None:\n        \"\"\" Find duplicate footnotes and format and add the duplicates. \"\"\"\n        for li in list(parent):\n            # Check number of duplicates footnotes and insert\n            # additional links if needed.\n            count = self.get_num_duplicates(li)\n            if count > 1:\n                self.add_duplicates(li, count)\n\n    def run(self, root: etree.Element) -> None:\n        \"\"\" Crawl the footnote div and add missing duplicate footnotes. \"\"\"\n        self.offset = 0\n        for div in root.iter('div'):\n            if div.attrib.get('class', '') == 'footnote':\n                # Footnotes should be under the first ordered list under\n                # the footnote div.  So once we find it, quit.\n                for ol in div.iter('ol'):\n                    self.handle_duplicates(ol)\n                    break\n\n\nclass FootnoteTreeprocessor(Treeprocessor):\n    \"\"\" Build and append footnote div to end of document. \"\"\"\n\n    def __init__(self, footnotes: FootnoteExtension):\n        self.footnotes = footnotes\n\n    def run(self, root: etree.Element) -> None:\n        footnotesDiv = self.footnotes.makeFootnotesDiv(root)\n        if footnotesDiv is not None:\n            result = self.footnotes.findFootnotesPlaceholder(root)\n            if result:\n                child, parent, isText = result\n                ind = list(parent).index(child)\n                if isText:\n                    parent.remove(child)\n                    parent.insert(ind, footnotesDiv)\n                else:\n                    parent.insert(ind + 1, footnotesDiv)\n                    child.tail = None\n            else:\n                root.append(footnotesDiv)\n\n\nclass FootnotePostprocessor(Postprocessor):\n    \"\"\" Replace placeholders with html entities. \"\"\"\n    def __init__(self, footnotes: FootnoteExtension):\n        self.footnotes = footnotes\n\n    def run(self, text: str) -> str:\n        text = text.replace(\n            FN_BACKLINK_TEXT, self.footnotes.getConfig(\"BACKLINK_TEXT\")\n        )\n        return text.replace(NBSP_PLACEHOLDER, \"&#160;\")\n\n\ndef makeExtension(**kwargs):  # pragma: no cover\n    \"\"\" Return an instance of the `FootnoteExtension` \"\"\"\n    return FootnoteExtension(**kwargs)\n","size_bytes":16710},"markdown/extensions/legacy_attrs.py":{"content":"# Python Markdown\n\n# A Python implementation of John Gruber's Markdown.\n\n# Documentation: https://python-markdown.github.io/\n# GitHub: https://github.com/Python-Markdown/markdown/\n# PyPI: https://pypi.org/project/Markdown/\n\n# Started by Manfred Stienstra (http://www.dwerg.net/).\n# Maintained for a few years by Yuri Takhteyev (http://www.freewisdom.org).\n# Currently maintained by Waylan Limberg (https://github.com/waylan),\n# Dmitry Shachnev (https://github.com/mitya57) and Isaac Muse (https://github.com/facelessuser).\n\n# Copyright 2007-2023 The Python Markdown Project (v. 1.7 and later)\n# Copyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b)\n# Copyright 2004 Manfred Stienstra (the original version)\n\n# License: BSD (see LICENSE.md for details).\n\n\"\"\"\nAn extension to Python Markdown which implements legacy attributes.\n\nPrior to Python-Markdown version 3.0, the Markdown class had an `enable_attributes`\nkeyword which was on by default and provided for attributes to be defined for elements\nusing the format `{@key=value}`. This extension is provided as a replacement for\nbackward compatibility. New documents should be authored using `attr_lists`. However,\nnumerous documents exist which have been using the old attribute format for many\nyears. This extension can be used to continue to render those documents correctly.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport re\nfrom markdown.treeprocessors import Treeprocessor, isString\nfrom markdown.extensions import Extension\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:  # pragma: no cover\n    import xml.etree.ElementTree as etree\n\n\nATTR_RE = re.compile(r'\\{@([^\\}]*)=([^\\}]*)}')  # {@id=123}\n\n\nclass LegacyAttrs(Treeprocessor):\n    def run(self, doc: etree.Element) -> None:\n        \"\"\"Find and set values of attributes ({@key=value}). \"\"\"\n        for el in doc.iter():\n            alt = el.get('alt', None)\n            if alt is not None:\n                el.set('alt', self.handleAttributes(el, alt))\n            if el.text and isString(el.text):\n                el.text = self.handleAttributes(el, el.text)\n            if el.tail and isString(el.tail):\n                el.tail = self.handleAttributes(el, el.tail)\n\n    def handleAttributes(self, el: etree.Element, txt: str) -> str:\n        \"\"\" Set attributes and return text without definitions. \"\"\"\n        def attributeCallback(match: re.Match[str]):\n            el.set(match.group(1), match.group(2).replace('\\n', ' '))\n        return ATTR_RE.sub(attributeCallback, txt)\n\n\nclass LegacyAttrExtension(Extension):\n    def extendMarkdown(self, md):\n        \"\"\" Add `LegacyAttrs` to Markdown instance. \"\"\"\n        md.treeprocessors.register(LegacyAttrs(md), 'legacyattrs', 15)\n\n\ndef makeExtension(**kwargs):  # pragma: no cover\n    return LegacyAttrExtension(**kwargs)\n","size_bytes":2788},"markdown/extensions/legacy_em.py":{"content":"# Legacy Em Extension for Python-Markdown\n# =======================================\n\n# This extension provides legacy behavior for _connected_words_.\n\n# Copyright 2015-2018 The Python Markdown Project\n\n# License: [BSD](https://opensource.org/licenses/bsd-license.php)\n\n\"\"\"\nThis extension provides legacy behavior for _connected_words_.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom . import Extension\nfrom ..inlinepatterns import UnderscoreProcessor, EmStrongItem, EM_STRONG2_RE, STRONG_EM2_RE\nimport re\n\n# _emphasis_\nEMPHASIS_RE = r'(_)([^_]+)\\1'\n\n# __strong__\nSTRONG_RE = r'(_{2})(.+?)\\1'\n\n# __strong_em___\nSTRONG_EM_RE = r'(_)\\1(?!\\1)([^_]+?)\\1(?!\\1)(.+?)\\1{3}'\n\n\nclass LegacyUnderscoreProcessor(UnderscoreProcessor):\n    \"\"\"Emphasis processor for handling strong and em matches inside underscores.\"\"\"\n\n    PATTERNS = [\n        EmStrongItem(re.compile(EM_STRONG2_RE, re.DOTALL | re.UNICODE), 'double', 'strong,em'),\n        EmStrongItem(re.compile(STRONG_EM2_RE, re.DOTALL | re.UNICODE), 'double', 'em,strong'),\n        EmStrongItem(re.compile(STRONG_EM_RE, re.DOTALL | re.UNICODE), 'double2', 'strong,em'),\n        EmStrongItem(re.compile(STRONG_RE, re.DOTALL | re.UNICODE), 'single', 'strong'),\n        EmStrongItem(re.compile(EMPHASIS_RE, re.DOTALL | re.UNICODE), 'single', 'em')\n    ]\n\n\nclass LegacyEmExtension(Extension):\n    \"\"\" Add legacy_em extension to Markdown class.\"\"\"\n\n    def extendMarkdown(self, md):\n        \"\"\" Modify inline patterns. \"\"\"\n        md.inlinePatterns.register(LegacyUnderscoreProcessor(r'_'), 'em_strong2', 50)\n\n\ndef makeExtension(**kwargs):  # pragma: no cover\n    \"\"\" Return an instance of the `LegacyEmExtension` \"\"\"\n    return LegacyEmExtension(**kwargs)\n","size_bytes":1693},"markdown/extensions/md_in_html.py":{"content":"# Python-Markdown Markdown in HTML Extension\n# ===============================\n\n# An implementation of [PHP Markdown Extra](http://michelf.com/projects/php-markdown/extra/)'s\n# parsing of Markdown syntax in raw HTML.\n\n# See https://Python-Markdown.github.io/extensions/raw_html\n# for documentation.\n\n# Copyright The Python Markdown Project\n\n# License: [BSD](https://opensource.org/licenses/bsd-license.php)\n\n\"\"\"\nParse Markdown syntax within raw HTML.\nBased on the implementation in [PHP Markdown Extra](http://michelf.com/projects/php-markdown/extra/).\n\nSee the [documentation](https://Python-Markdown.github.io/extensions/raw_html)\nfor details.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom . import Extension\nfrom ..blockprocessors import BlockProcessor\nfrom ..preprocessors import Preprocessor\nfrom ..postprocessors import RawHtmlPostprocessor\nfrom .. import util\nfrom ..htmlparser import HTMLExtractor, blank_line_re\nimport xml.etree.ElementTree as etree\nfrom typing import TYPE_CHECKING, Literal, Mapping\n\nif TYPE_CHECKING:  # pragma: no cover\n    from markdown import Markdown\n\n\nclass HTMLExtractorExtra(HTMLExtractor):\n    \"\"\"\n    Override `HTMLExtractor` and create `etree` `Elements` for any elements which should have content parsed as\n    Markdown.\n    \"\"\"\n\n    def __init__(self, md: Markdown, *args, **kwargs):\n        # All block-level tags.\n        self.block_level_tags = set(md.block_level_elements.copy())\n        # Block-level tags in which the content only gets span level parsing\n        self.span_tags = set(\n            ['address', 'dd', 'dt', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'legend', 'li', 'p', 'summary', 'td', 'th']\n        )\n        # Block-level tags which never get their content parsed.\n        self.raw_tags = set(['canvas', 'math', 'option', 'pre', 'script', 'style', 'textarea'])\n\n        super().__init__(md, *args, **kwargs)\n\n        # Block-level tags in which the content gets parsed as blocks\n        self.block_tags = set(self.block_level_tags) - (self.span_tags | self.raw_tags | self.empty_tags)\n        self.span_and_blocks_tags = self.block_tags | self.span_tags\n\n    def reset(self):\n        \"\"\"Reset this instance.  Loses all unprocessed data.\"\"\"\n        self.mdstack: list[str] = []  # When markdown=1, stack contains a list of tags\n        self.treebuilder = etree.TreeBuilder()\n        self.mdstate: list[Literal['block', 'span', 'off', None]] = []\n        self.mdstarted: list[bool] = []\n        super().reset()\n\n    def close(self):\n        \"\"\"Handle any buffered data.\"\"\"\n        super().close()\n        # Handle any unclosed tags.\n        if self.mdstack:\n            # Close the outermost parent. `handle_endtag` will close all unclosed children.\n            self.handle_endtag(self.mdstack[0])\n\n    def get_element(self) -> etree.Element:\n        \"\"\" Return element from `treebuilder` and reset `treebuilder` for later use. \"\"\"\n        element = self.treebuilder.close()\n        self.treebuilder = etree.TreeBuilder()\n        return element\n\n    def get_state(self, tag, attrs: Mapping[str, str]) -> Literal['block', 'span', 'off', None]:\n        \"\"\" Return state from tag and `markdown` attribute. One of 'block', 'span', or 'off'. \"\"\"\n        md_attr = attrs.get('markdown', '0')\n        if md_attr == 'markdown':\n            # `<tag markdown>` is the same as `<tag markdown='1'>`.\n            md_attr = '1'\n        parent_state = self.mdstate[-1] if self.mdstate else None\n        if parent_state == 'off' or (parent_state == 'span' and md_attr != '0'):\n            # Only use the parent state if it is more restrictive than the markdown attribute.\n            md_attr = parent_state\n        if ((md_attr == '1' and tag in self.block_tags) or\n                (md_attr == 'block' and tag in self.span_and_blocks_tags)):\n            return 'block'\n        elif ((md_attr == '1' and tag in self.span_tags) or\n              (md_attr == 'span' and tag in self.span_and_blocks_tags)):\n            return 'span'\n        elif tag in self.block_level_tags:\n            return 'off'\n        else:  # pragma: no cover\n            return None\n\n    def handle_starttag(self, tag, attrs):\n        # Handle tags that should always be empty and do not specify a closing tag\n        if tag in self.empty_tags and (self.at_line_start() or self.intail):\n            attrs = {key: value if value is not None else key for key, value in attrs}\n            if \"markdown\" in attrs:\n                attrs.pop('markdown')\n                element = etree.Element(tag, attrs)\n                data = etree.tostring(element, encoding='unicode', method='html')\n            else:\n                data = self.get_starttag_text()\n            self.handle_empty_tag(data, True)\n            return\n\n        if (\n            tag in self.block_level_tags and\n            (self.at_line_start() or self.intail or self.mdstarted and self.mdstarted[-1])\n        ):\n            # Valueless attribute (ex: `<tag checked>`) results in `[('checked', None)]`.\n            # Convert to `{'checked': 'checked'}`.\n            attrs = {key: value if value is not None else key for key, value in attrs}\n            state = self.get_state(tag, attrs)\n            if self.inraw or (state in [None, 'off'] and not self.mdstack):\n                # fall back to default behavior\n                attrs.pop('markdown', None)\n                super().handle_starttag(tag, attrs)\n            else:\n                if 'p' in self.mdstack and tag in self.block_level_tags:\n                    # Close unclosed 'p' tag\n                    self.handle_endtag('p')\n                self.mdstate.append(state)\n                self.mdstack.append(tag)\n                self.mdstarted.append(True)\n                attrs['markdown'] = state\n                self.treebuilder.start(tag, attrs)\n\n        else:\n            # Span level tag\n            if self.inraw:\n                super().handle_starttag(tag, attrs)\n            else:\n                text = self.get_starttag_text()\n                if self.mdstate and self.mdstate[-1] == \"off\":\n                    self.handle_data(self.md.htmlStash.store(text))\n                else:\n                    self.handle_data(text)\n                if tag in self.CDATA_CONTENT_ELEMENTS:\n                    # This is presumably a standalone tag in a code span (see #1036).\n                    self.clear_cdata_mode()\n\n    def handle_endtag(self, tag):\n        if tag in self.block_level_tags:\n            if self.inraw:\n                super().handle_endtag(tag)\n            elif tag in self.mdstack:\n                # Close element and any unclosed children\n                while self.mdstack:\n                    item = self.mdstack.pop()\n                    self.mdstate.pop()\n                    self.mdstarted.pop()\n                    self.treebuilder.end(item)\n                    if item == tag:\n                        break\n                if not self.mdstack:\n                    # Last item in stack is closed. Stash it\n                    element = self.get_element()\n                    # Get last entry to see if it ends in newlines\n                    # If it is an element, assume there is no newlines\n                    item = self.cleandoc[-1] if self.cleandoc else ''\n                    # If we only have one newline before block element, add another\n                    if not item.endswith('\\n\\n') and item.endswith('\\n'):\n                        self.cleandoc.append('\\n')\n\n                    # Flatten the HTML structure of \"markdown\" blocks such that when they\n                    # get parsed, content will be parsed similar inside the blocks as it\n                    # does outside the block. Having real HTML elements in the tree before\n                    # the content adjacent content is processed can cause unpredictable\n                    # issues for extensions.\n                    current = element\n                    last = []\n                    while current is not None:\n                        for child in list(current):\n                            current.remove(child)\n                            text = current.text if current.text is not None else ''\n                            tail = child.tail if child.tail is not None else ''\n                            child.tail = None\n                            state = child.attrib.get('markdown', 'off')\n\n                            # Add a newline to tail if it is not just a trailing newline\n                            if tail != '\\n':\n                                tail = '\\n' + tail.rstrip('\\n')\n\n                            # Ensure there is an empty new line between blocks\n                            if not text.endswith('\\n\\n'):\n                                text = text.rstrip('\\n') + '\\n\\n'\n\n                            # Process the block nested under the span appropriately\n                            if state in ('span', 'block'):\n                                current.text = f'{text}{self.md.htmlStash.store(child)}{tail}'\n                                last.append(child)\n                            else:\n                                # Non-Markdown HTML will not be recursively parsed for Markdown,\n                                # so we can just remove markers and leave them unflattened.\n                                # Additionally, we don't need to append to our list for further\n                                # processing.\n                                child.attrib.pop('markdown')\n                                [c.attrib.pop('markdown', None) for c in child.iter()]\n                                current.text = f'{text}{self.md.htmlStash.store(child)}{tail}'\n                        # Target the child elements that have been expanded.\n                        current = last.pop(0) if last else None\n\n                    self.cleandoc.append(self.md.htmlStash.store(element))\n                    self.cleandoc.append('\\n\\n')\n                    self.state = []\n                    # Check if element has a tail\n                    if not blank_line_re.match(\n                            self.rawdata[self.line_offset + self.offset + len(self.get_endtag_text(tag)):]):\n                        # More content exists after `endtag`.\n                        self.intail = True\n            else:\n                # Treat orphan closing tag as a span level tag.\n                text = self.get_endtag_text(tag)\n                if self.mdstate and self.mdstate[-1] == \"off\":\n                    self.handle_data(self.md.htmlStash.store(text))\n                else:\n                    self.handle_data(text)\n        else:\n            # Span level tag\n            if self.inraw:\n                super().handle_endtag(tag)\n            else:\n                text = self.get_endtag_text(tag)\n                if self.mdstate and self.mdstate[-1] == \"off\":\n                    self.handle_data(self.md.htmlStash.store(text))\n                else:\n                    self.handle_data(text)\n\n    def handle_startendtag(self, tag, attrs):\n        if tag in self.empty_tags:\n            attrs = {key: value if value is not None else key for key, value in attrs}\n            if \"markdown\" in attrs:\n                attrs.pop('markdown')\n                element = etree.Element(tag, attrs)\n                data = etree.tostring(element, encoding='unicode', method='html')\n            else:\n                data = self.get_starttag_text()\n        else:\n            data = self.get_starttag_text()\n        self.handle_empty_tag(data, is_block=self.md.is_block_level(tag))\n\n    def handle_data(self, data):\n        if self.intail and '\\n' in data:\n            self.intail = False\n        if self.inraw or not self.mdstack:\n            super().handle_data(data)\n        else:\n            self.mdstarted[-1] = False\n            self.treebuilder.data(data)\n\n    def handle_empty_tag(self, data, is_block):\n        if self.inraw or not self.mdstack:\n            super().handle_empty_tag(data, is_block)\n        else:\n            if self.at_line_start() and is_block:\n                self.handle_data('\\n' + self.md.htmlStash.store(data) + '\\n\\n')\n            elif self.mdstate and self.mdstate[-1] == \"off\":\n                self.handle_data(self.md.htmlStash.store(data))\n            else:\n                self.handle_data(data)\n\n    def parse_pi(self, i: int) -> int:\n        if self.at_line_start() or self.intail or self.mdstack:\n            # The same override exists in `HTMLExtractor` without the check\n            # for `mdstack`. Therefore, use parent of `HTMLExtractor` instead.\n            return super(HTMLExtractor, self).parse_pi(i)\n        # This is not the beginning of a raw block so treat as plain data\n        # and avoid consuming any tags which may follow (see #1066).\n        self.handle_data('<?')\n        return i + 2\n\n    def parse_html_declaration(self, i: int) -> int:\n        if self.at_line_start() or self.intail or self.mdstack:\n            if self.rawdata[i:i+3] == '<![' and not self.rawdata[i:i+9] == '<![CDATA[':\n                # We have encountered the bug in #1534 (Python bug `gh-77057`).\n                # Provide an override until we drop support for Python < 3.13.\n                result = self.parse_bogus_comment(i)\n                if result == -1:\n                    self.handle_data(self.rawdata[i:i + 1])\n                    return i + 1\n                return result\n            # The same override exists in `HTMLExtractor` without the check\n            # for `mdstack`. Therefore, use parent of `HTMLExtractor` instead.\n            return super(HTMLExtractor, self).parse_html_declaration(i)\n        # This is not the beginning of a raw block so treat as plain data\n        # and avoid consuming any tags which may follow (see #1066).\n        self.handle_data('<!')\n        return i + 2\n\n\nclass HtmlBlockPreprocessor(Preprocessor):\n    \"\"\"Remove html blocks from the text and store them for later retrieval.\"\"\"\n\n    def run(self, lines: list[str]) -> list[str]:\n        source = '\\n'.join(lines)\n        parser = HTMLExtractorExtra(self.md)\n        parser.feed(source)\n        parser.close()\n        return ''.join(parser.cleandoc).split('\\n')\n\n\nclass MarkdownInHtmlProcessor(BlockProcessor):\n    \"\"\"Process Markdown Inside HTML Blocks which have been stored in the `HtmlStash`.\"\"\"\n\n    def test(self, parent: etree.Element, block: str) -> bool:\n        # Always return True. `run` will return `False` it not a valid match.\n        return True\n\n    def parse_element_content(self, element: etree.Element) -> None:\n        \"\"\"\n        Recursively parse the text content of an `etree` Element as Markdown.\n\n        Any block level elements generated from the Markdown will be inserted as children of the element in place\n        of the text content. All `markdown` attributes are removed. For any elements in which Markdown parsing has\n        been disabled, the text content of it and its children are wrapped in an `AtomicString`.\n        \"\"\"\n\n        md_attr = element.attrib.pop('markdown', 'off')\n\n        if md_attr == 'block':\n            # Parse the block elements content as Markdown\n            if element.text:\n                block = element.text.rstrip('\\n')\n                element.text = ''\n                self.parser.parseBlocks(element, block.split('\\n\\n'))\n\n        elif md_attr == 'span':\n            # Span elements need to be recursively processed for block elements and raw HTML\n            # as their content is not normally accessed by block processors, so expand stashed\n            # HTML under the span. Span content itself will not be parsed here, but will await\n            # the inline parser.\n            block = element.text if element.text is not None else ''\n            element.text = ''\n            child = None\n            start = 0\n\n            # Search the content for HTML placeholders and process the elements\n            for m in util.HTML_PLACEHOLDER_RE.finditer(block):\n                index = int(m.group(1))\n                el = self.parser.md.htmlStash.rawHtmlBlocks[index]\n                end = m.start()\n\n                if isinstance(el, etree.Element):\n                    # Replace the placeholder with the element and process it.\n                    # Content after the placeholder should be attached to the tail.\n                    if child is None:\n                        element.text += block[start:end]\n                    else:\n                        child.tail += block[start:end]\n                    element.append(el)\n                    self.parse_element_content(el)\n                    child = el\n                    if child.tail is None:\n                        child.tail = ''\n                    self.parser.md.htmlStash.rawHtmlBlocks.pop(index)\n                    self.parser.md.htmlStash.rawHtmlBlocks.insert(index, '')\n\n                else:\n                    # Not an element object, so insert content back into the element\n                    if child is None:\n                        element.text += block[start:end]\n                    else:\n                        child.tail += block[start:end]\n                start = end\n\n            # Insert anything left after last element\n            if child is None:\n                element.text += block[start:]\n            else:\n                child.tail += block[start:]\n\n        else:\n            # Disable inline parsing for everything else\n            if element.text is None:\n                element.text = ''\n            element.text = util.AtomicString(element.text)\n            for child in list(element):\n                self.parse_element_content(child)\n                if child.tail:\n                    child.tail = util.AtomicString(child.tail)\n\n    def run(self, parent: etree.Element, blocks: list[str]) -> bool:\n        m = util.HTML_PLACEHOLDER_RE.match(blocks[0])\n        if m:\n            index = int(m.group(1))\n            element = self.parser.md.htmlStash.rawHtmlBlocks[index]\n            if isinstance(element, etree.Element):\n                # We have a matched element. Process it.\n                block = blocks.pop(0)\n                parent.append(element)\n                self.parse_element_content(element)\n                # Cleanup stash. Replace element with empty string to avoid confusing postprocessor.\n                self.parser.md.htmlStash.rawHtmlBlocks.pop(index)\n                self.parser.md.htmlStash.rawHtmlBlocks.insert(index, '')\n                content = block[m.end(0):]\n                # Ensure the rest of the content gets handled\n                if content:\n                    blocks.insert(0, content)\n                # Confirm the match to the `blockparser`.\n                return True\n        # No match found.\n        return False\n\n\nclass MarkdownInHTMLPostprocessor(RawHtmlPostprocessor):\n    def stash_to_string(self, text: str | etree.Element) -> str:\n        \"\"\" Override default to handle any `etree` elements still in the stash. \"\"\"\n        if isinstance(text, etree.Element):\n            return self.md.serializer(text)\n        else:\n            return str(text)\n\n\nclass MarkdownInHtmlExtension(Extension):\n    \"\"\"Add Markdown parsing in HTML to Markdown class.\"\"\"\n\n    def extendMarkdown(self, md):\n        \"\"\" Register extension instances. \"\"\"\n\n        # Replace raw HTML preprocessor\n        md.preprocessors.register(HtmlBlockPreprocessor(md), 'html_block', 20)\n        # Add `blockprocessor` which handles the placeholders for `etree` elements\n        md.parser.blockprocessors.register(\n            MarkdownInHtmlProcessor(md.parser), 'markdown_block', 105\n        )\n        # Replace raw HTML postprocessor\n        md.postprocessors.register(MarkdownInHTMLPostprocessor(md), 'raw_html', 30)\n\n\ndef makeExtension(**kwargs):  # pragma: no cover\n    return MarkdownInHtmlExtension(**kwargs)\n","size_bytes":19785},"markdown/extensions/meta.py":{"content":"# Meta Data Extension for Python-Markdown\n# =======================================\n\n# This extension adds Meta Data handling to markdown.\n\n# See https://Python-Markdown.github.io/extensions/meta_data\n# for documentation.\n\n# Original code Copyright 2007-2008 [Waylan Limberg](http://achinghead.com).\n\n# All changes Copyright 2008-2014 The Python Markdown Project\n\n# License: [BSD](https://opensource.org/licenses/bsd-license.php)\n\n\"\"\"\nThis extension adds Meta Data handling to markdown.\n\nSee the [documentation](https://Python-Markdown.github.io/extensions/meta_data)\nfor details.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom . import Extension\nfrom ..preprocessors import Preprocessor\nimport re\nimport logging\nfrom typing import Any\n\nlog = logging.getLogger('MARKDOWN')\n\n# Global Vars\nMETA_RE = re.compile(r'^[ ]{0,3}(?P<key>[A-Za-z0-9_-]+):\\s*(?P<value>.*)')\nMETA_MORE_RE = re.compile(r'^[ ]{4,}(?P<value>.*)')\nBEGIN_RE = re.compile(r'^-{3}(\\s.*)?')\nEND_RE = re.compile(r'^(-{3}|\\.{3})(\\s.*)?')\n\n\nclass MetaExtension (Extension):\n    \"\"\" Meta-Data extension for Python-Markdown. \"\"\"\n\n    def extendMarkdown(self, md):\n        \"\"\" Add `MetaPreprocessor` to Markdown instance. \"\"\"\n        md.registerExtension(self)\n        self.md = md\n        md.preprocessors.register(MetaPreprocessor(md), 'meta', 27)\n\n    def reset(self) -> None:\n        self.md.Meta = {}\n\n\nclass MetaPreprocessor(Preprocessor):\n    \"\"\" Get Meta-Data. \"\"\"\n\n    def run(self, lines: list[str]) -> list[str]:\n        \"\"\" Parse Meta-Data and store in Markdown.Meta. \"\"\"\n        meta: dict[str, Any] = {}\n        key = None\n        if lines and BEGIN_RE.match(lines[0]):\n            lines.pop(0)\n        while lines:\n            line = lines.pop(0)\n            m1 = META_RE.match(line)\n            if line.strip() == '' or END_RE.match(line):\n                break  # blank line or end of YAML header - done\n            if m1:\n                key = m1.group('key').lower().strip()\n                value = m1.group('value').strip()\n                try:\n                    meta[key].append(value)\n                except KeyError:\n                    meta[key] = [value]\n            else:\n                m2 = META_MORE_RE.match(line)\n                if m2 and key:\n                    # Add another line to existing key\n                    meta[key].append(m2.group('value').strip())\n                else:\n                    lines.insert(0, line)\n                    break  # no meta data - done\n        self.md.Meta = meta\n        return lines\n\n\ndef makeExtension(**kwargs):  # pragma: no cover\n    return MetaExtension(**kwargs)\n","size_bytes":2600},"markdown/extensions/nl2br.py":{"content":"# `NL2BR` Extension\n# ===============\n\n# A Python-Markdown extension to treat newlines as hard breaks; like\n# GitHub-flavored Markdown does.\n\n# See https://Python-Markdown.github.io/extensions/nl2br\n# for documentation.\n\n# Original code Copyright 2011 [Brian Neal](https://deathofagremmie.com/)\n\n# All changes Copyright 2011-2014 The Python Markdown Project\n\n# License: [BSD](https://opensource.org/licenses/bsd-license.php)\n\n\"\"\"\nA Python-Markdown extension to treat newlines as hard breaks.\nSimilar to GitHub-flavored Markdown's behavior.\n\nSee the [documentation](https://Python-Markdown.github.io/extensions/nl2br)\nfor details.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom . import Extension\nfrom ..inlinepatterns import SubstituteTagInlineProcessor\n\nBR_RE = r'\\n'\n\n\nclass Nl2BrExtension(Extension):\n\n    def extendMarkdown(self, md):\n        \"\"\" Add a `SubstituteTagInlineProcessor` to Markdown. \"\"\"\n        br_tag = SubstituteTagInlineProcessor(BR_RE, 'br')\n        md.inlinePatterns.register(br_tag, 'nl', 5)\n\n\ndef makeExtension(**kwargs):  # pragma: no cover\n    return Nl2BrExtension(**kwargs)\n","size_bytes":1102},"markdown/extensions/sane_lists.py":{"content":"# Sane List Extension for Python-Markdown\n# =======================================\n\n# Modify the behavior of Lists in Python-Markdown to act in a sane manor.\n\n# See https://Python-Markdown.github.io/extensions/sane_lists\n# for documentation.\n\n# Original code Copyright 2011 [Waylan Limberg](http://achinghead.com)\n\n# All changes Copyright 2011-2014 The Python Markdown Project\n\n# License: [BSD](https://opensource.org/licenses/bsd-license.php)\n\n\"\"\"\nModify the behavior of Lists in Python-Markdown to act in a sane manor.\n\nSee [documentation](https://Python-Markdown.github.io/extensions/sane_lists)\nfor details.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom . import Extension\nfrom ..blockprocessors import OListProcessor, UListProcessor\nimport re\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:  # pragma: no cover\n    from .. import blockparser\n\n\nclass SaneOListProcessor(OListProcessor):\n    \"\"\" Override `SIBLING_TAGS` to not include `ul` and set `LAZY_OL` to `False`. \"\"\"\n\n    SIBLING_TAGS = ['ol']\n    \"\"\" Exclude `ul` from list of siblings. \"\"\"\n    LAZY_OL = False\n    \"\"\" Disable lazy list behavior. \"\"\"\n\n    def __init__(self, parser: blockparser.BlockParser):\n        super().__init__(parser)\n        self.CHILD_RE = re.compile(r'^[ ]{0,%d}((\\d+\\.))[ ]+(.*)' %\n                                   (self.tab_length - 1))\n\n\nclass SaneUListProcessor(UListProcessor):\n    \"\"\" Override `SIBLING_TAGS` to not include `ol`. \"\"\"\n\n    SIBLING_TAGS = ['ul']\n    \"\"\" Exclude `ol` from list of siblings. \"\"\"\n\n    def __init__(self, parser: blockparser.BlockParser):\n        super().__init__(parser)\n        self.CHILD_RE = re.compile(r'^[ ]{0,%d}(([*+-]))[ ]+(.*)' %\n                                   (self.tab_length - 1))\n\n\nclass SaneListExtension(Extension):\n    \"\"\" Add sane lists to Markdown. \"\"\"\n\n    def extendMarkdown(self, md):\n        \"\"\" Override existing Processors. \"\"\"\n        md.parser.blockprocessors.register(SaneOListProcessor(md.parser), 'olist', 40)\n        md.parser.blockprocessors.register(SaneUListProcessor(md.parser), 'ulist', 30)\n\n\ndef makeExtension(**kwargs):  # pragma: no cover\n    return SaneListExtension(**kwargs)\n","size_bytes":2150},"markdown/extensions/smarty.py":{"content":"# Smarty extension for Python-Markdown\n# ====================================\n\n# Adds conversion of ASCII dashes, quotes and ellipses to their HTML\n# entity equivalents.\n\n# See https://Python-Markdown.github.io/extensions/smarty\n# for documentation.\n\n# Author: 2013, Dmitry Shachnev <mitya57@gmail.com>\n\n# All changes Copyright 2013-2014 The Python Markdown Project\n\n# License: [BSD](https://opensource.org/licenses/bsd-license.php)\n\n# SmartyPants license:\n\n#    Copyright (c) 2003 John Gruber <https://daringfireball.net/>\n#    All rights reserved.\n\n#    Redistribution and use in source and binary forms, with or without\n#    modification, are permitted provided that the following conditions are\n#    met:\n\n#    *  Redistributions of source code must retain the above copyright\n#       notice, this list of conditions and the following disclaimer.\n\n#    *  Redistributions in binary form must reproduce the above copyright\n#       notice, this list of conditions and the following disclaimer in\n#       the documentation and/or other materials provided with the\n#       distribution.\n\n#    *  Neither the name \"SmartyPants\" nor the names of its contributors\n#       may be used to endorse or promote products derived from this\n#       software without specific prior written permission.\n\n#    This software is provided by the copyright holders and contributors \"as\n#    is\" and any express or implied warranties, including, but not limited\n#    to, the implied warranties of merchantability and fitness for a\n#    particular purpose are disclaimed. In no event shall the copyright\n#    owner or contributors be liable for any direct, indirect, incidental,\n#    special, exemplary, or consequential damages (including, but not\n#    limited to, procurement of substitute goods or services; loss of use,\n#    data, or profits; or business interruption) however caused and on any\n#    theory of liability, whether in contract, strict liability, or tort\n#    (including negligence or otherwise) arising in any way out of the use\n#    of this software, even if advised of the possibility of such damage.\n\n\n# `smartypants.py` license:\n\n#    `smartypants.py` is a derivative work of SmartyPants.\n#    Copyright (c) 2004, 2007 Chad Miller <http://web.chad.org/>\n\n#    Redistribution and use in source and binary forms, with or without\n#    modification, are permitted provided that the following conditions are\n#    met:\n\n#    *  Redistributions of source code must retain the above copyright\n#       notice, this list of conditions and the following disclaimer.\n\n#    *  Redistributions in binary form must reproduce the above copyright\n#       notice, this list of conditions and the following disclaimer in\n#       the documentation and/or other materials provided with the\n#       distribution.\n\n#    This software is provided by the copyright holders and contributors \"as\n#    is\" and any express or implied warranties, including, but not limited\n#    to, the implied warranties of merchantability and fitness for a\n#    particular purpose are disclaimed. In no event shall the copyright\n#    owner or contributors be liable for any direct, indirect, incidental,\n#    special, exemplary, or consequential damages (including, but not\n#    limited to, procurement of substitute goods or services; loss of use,\n#    data, or profits; or business interruption) however caused and on any\n#    theory of liability, whether in contract, strict liability, or tort\n#    (including negligence or otherwise) arising in any way out of the use\n#    of this software, even if advised of the possibility of such damage.\n\n\"\"\"\nConvert ASCII dashes, quotes and ellipses to their HTML entity equivalents.\n\nSee the [documentation](https://Python-Markdown.github.io/extensions/smarty)\nfor details.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom . import Extension\nfrom ..inlinepatterns import HtmlInlineProcessor, HTML_RE\nfrom ..treeprocessors import InlineProcessor\nfrom ..util import Registry\nfrom typing import TYPE_CHECKING, Sequence\n\nif TYPE_CHECKING:  # pragma: no cover\n    from markdown import Markdown\n    from .. import inlinepatterns\n    import re\n    import xml.etree.ElementTree as etree\n\n# Constants for quote education.\npunctClass = r\"\"\"[!\"#\\$\\%'()*+,-.\\/:;<=>?\\@\\[\\\\\\]\\^_`{|}~]\"\"\"\nendOfWordClass = r\"[\\s.,;:!?)]\"\ncloseClass = r\"[^\\ \\t\\r\\n\\[\\{\\(\\-\\u0002\\u0003]\"\n\nopeningQuotesBase = (\n    r'(\\s'               # a  whitespace char\n    r'|&nbsp;'           # or a non-breaking space entity\n    r'|--'               # or dashes\n    r'|‚Äì|‚Äî'              # or Unicode\n    r'|&[mn]dash;'       # or named dash entities\n    r'|&#8211;|&#8212;'  # or decimal entities\n    r')'\n)\n\nsubstitutions = {\n    'mdash': '&mdash;',\n    'ndash': '&ndash;',\n    'ellipsis': '&hellip;',\n    'left-angle-quote': '&laquo;',\n    'right-angle-quote': '&raquo;',\n    'left-single-quote': '&lsquo;',\n    'right-single-quote': '&rsquo;',\n    'left-double-quote': '&ldquo;',\n    'right-double-quote': '&rdquo;',\n}\n\n\n# Special case if the very first character is a quote\n# followed by punctuation at a non-word-break. Close the quotes by brute force:\nsingleQuoteStartRe = r\"^'(?=%s\\B)\" % punctClass\ndoubleQuoteStartRe = r'^\"(?=%s\\B)' % punctClass\n\n# Special case for double sets of quotes, e.g.:\n#   <p>He said, \"'Quoted' words in a larger quote.\"</p>\ndoubleQuoteSetsRe = r\"\"\"\"'(?=\\w)\"\"\"\nsingleQuoteSetsRe = r\"\"\"'\"(?=\\w)\"\"\"\ndoubleQuoteSetsRe2 = r'(?<=%s)\\'\"' % closeClass\nsingleQuoteSetsRe2 = r\"(?<=%s)\\\"'\" % closeClass\n\n# Special case for decade abbreviations (the '80s):\ndecadeAbbrRe = r\"(?<!\\w)'(?=\\d{2}s)\"\n\n# Get most opening double quotes:\nopeningDoubleQuotesRegex = r'%s\"(?=\\w)' % openingQuotesBase\n\n# Double closing quotes:\nclosingDoubleQuotesRegex = r'\"(?=\\s)'\nclosingDoubleQuotesRegex2 = r'(?<=%s)\"' % closeClass\n\n# Get most opening single quotes:\nopeningSingleQuotesRegex = r\"%s'(?=\\w)\" % openingQuotesBase\n\n# Single closing quotes:\nclosingSingleQuotesRegex = r\"(?<=%s)'(?!\\s|s\\b|\\d)\" % closeClass\nclosingSingleQuotesRegex2 = r\"'(\\s|s\\b)\"\n\n# All remaining quotes should be opening ones\nremainingSingleQuotesRegex = r\"'\"\nremainingDoubleQuotesRegex = r'\"'\n\nHTML_STRICT_RE = HTML_RE + r'(?!\\>)'\n\n\nclass SubstituteTextPattern(HtmlInlineProcessor):\n    def __init__(self, pattern: str, replace: Sequence[int | str | etree.Element], md: Markdown):\n        \"\"\" Replaces matches with some text. \"\"\"\n        HtmlInlineProcessor.__init__(self, pattern)\n        self.replace = replace\n        self.md = md\n\n    def handleMatch(self, m: re.Match[str], data: str) -> tuple[str, int, int]:\n        result = ''\n        for part in self.replace:\n            if isinstance(part, int):\n                result += m.group(part)\n            else:\n                result += self.md.htmlStash.store(part)\n        return result, m.start(0), m.end(0)\n\n\nclass SmartyExtension(Extension):\n    \"\"\" Add Smarty to Markdown. \"\"\"\n    def __init__(self, **kwargs):\n        self.config = {\n            'smart_quotes': [True, 'Educate quotes'],\n            'smart_angled_quotes': [False, 'Educate angled quotes'],\n            'smart_dashes': [True, 'Educate dashes'],\n            'smart_ellipses': [True, 'Educate ellipses'],\n            'substitutions': [{}, 'Overwrite default substitutions'],\n        }\n        \"\"\" Default configuration options. \"\"\"\n        super().__init__(**kwargs)\n        self.substitutions: dict[str, str] = dict(substitutions)\n        self.substitutions.update(self.getConfig('substitutions', default={}))\n\n    def _addPatterns(\n        self,\n        md: Markdown,\n        patterns: Sequence[tuple[str, Sequence[int | str | etree.Element]]],\n        serie: str,\n        priority: int,\n    ):\n        for ind, pattern in enumerate(patterns):\n            pattern += (md,)\n            pattern = SubstituteTextPattern(*pattern)\n            name = 'smarty-%s-%d' % (serie, ind)\n            self.inlinePatterns.register(pattern, name, priority-ind)\n\n    def educateDashes(self, md: Markdown) -> None:\n        emDashesPattern = SubstituteTextPattern(\n            r'(?<!-)---(?!-)', (self.substitutions['mdash'],), md\n        )\n        enDashesPattern = SubstituteTextPattern(\n            r'(?<!-)--(?!-)', (self.substitutions['ndash'],), md\n        )\n        self.inlinePatterns.register(emDashesPattern, 'smarty-em-dashes', 50)\n        self.inlinePatterns.register(enDashesPattern, 'smarty-en-dashes', 45)\n\n    def educateEllipses(self, md: Markdown) -> None:\n        ellipsesPattern = SubstituteTextPattern(\n            r'(?<!\\.)\\.{3}(?!\\.)', (self.substitutions['ellipsis'],), md\n        )\n        self.inlinePatterns.register(ellipsesPattern, 'smarty-ellipses', 10)\n\n    def educateAngledQuotes(self, md: Markdown) -> None:\n        leftAngledQuotePattern = SubstituteTextPattern(\n            r'\\<\\<', (self.substitutions['left-angle-quote'],), md\n        )\n        rightAngledQuotePattern = SubstituteTextPattern(\n            r'\\>\\>', (self.substitutions['right-angle-quote'],), md\n        )\n        self.inlinePatterns.register(leftAngledQuotePattern, 'smarty-left-angle-quotes', 40)\n        self.inlinePatterns.register(rightAngledQuotePattern, 'smarty-right-angle-quotes', 35)\n\n    def educateQuotes(self, md: Markdown) -> None:\n        lsquo = self.substitutions['left-single-quote']\n        rsquo = self.substitutions['right-single-quote']\n        ldquo = self.substitutions['left-double-quote']\n        rdquo = self.substitutions['right-double-quote']\n        patterns = (\n            (singleQuoteStartRe, (rsquo,)),\n            (doubleQuoteStartRe, (rdquo,)),\n            (doubleQuoteSetsRe, (ldquo + lsquo,)),\n            (singleQuoteSetsRe, (lsquo + ldquo,)),\n            (doubleQuoteSetsRe2, (rsquo + rdquo,)),\n            (singleQuoteSetsRe2, (rdquo + rsquo,)),\n            (decadeAbbrRe, (rsquo,)),\n            (openingSingleQuotesRegex, (1, lsquo)),\n            (closingSingleQuotesRegex, (rsquo,)),\n            (closingSingleQuotesRegex2, (rsquo, 1)),\n            (remainingSingleQuotesRegex, (lsquo,)),\n            (openingDoubleQuotesRegex, (1, ldquo)),\n            (closingDoubleQuotesRegex, (rdquo,)),\n            (closingDoubleQuotesRegex2, (rdquo,)),\n            (remainingDoubleQuotesRegex, (ldquo,))\n        )\n        self._addPatterns(md, patterns, 'quotes', 30)\n\n    def extendMarkdown(self, md):\n        configs = self.getConfigs()\n        self.inlinePatterns: Registry[inlinepatterns.InlineProcessor] = Registry()\n        if configs['smart_ellipses']:\n            self.educateEllipses(md)\n        if configs['smart_quotes']:\n            self.educateQuotes(md)\n        if configs['smart_angled_quotes']:\n            self.educateAngledQuotes(md)\n            # Override `HTML_RE` from `inlinepatterns.py` so that it does not\n            # process tags with duplicate closing quotes.\n            md.inlinePatterns.register(HtmlInlineProcessor(HTML_STRICT_RE, md), 'html', 90)\n        if configs['smart_dashes']:\n            self.educateDashes(md)\n        inlineProcessor = InlineProcessor(md)\n        inlineProcessor.inlinePatterns = self.inlinePatterns\n        md.treeprocessors.register(inlineProcessor, 'smarty', 6)\n        md.ESCAPED_CHARS.extend(['\"', \"'\"])\n\n\ndef makeExtension(**kwargs):  # pragma: no cover\n    return SmartyExtension(**kwargs)\n","size_bytes":11238},"markdown/extensions/tables.py":{"content":"# Tables Extension for Python-Markdown\n# ====================================\n\n# Adds parsing of tables to Python-Markdown.\n\n# See https://Python-Markdown.github.io/extensions/tables\n# for documentation.\n\n# Original code Copyright 2009 [Waylan Limberg](http://achinghead.com)\n\n# All changes Copyright 2008-2014 The Python Markdown Project\n\n# License: [BSD](https://opensource.org/licenses/bsd-license.php)\n\n\"\"\"\nAdds parsing of tables to Python-Markdown.\n\nSee the [documentation](https://Python-Markdown.github.io/extensions/tables)\nfor details.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom . import Extension\nfrom ..blockprocessors import BlockProcessor\nimport xml.etree.ElementTree as etree\nimport re\nfrom typing import TYPE_CHECKING, Any, Sequence\n\nif TYPE_CHECKING:  # pragma: no cover\n    from .. import blockparser\n\nPIPE_NONE = 0\nPIPE_LEFT = 1\nPIPE_RIGHT = 2\n\n\nclass TableProcessor(BlockProcessor):\n    \"\"\" Process Tables. \"\"\"\n\n    RE_CODE_PIPES = re.compile(r'(?:(\\\\\\\\)|(\\\\`+)|(`+)|(\\\\\\|)|(\\|))')\n    RE_END_BORDER = re.compile(r'(?<!\\\\)(?:\\\\\\\\)*\\|$')\n\n    def __init__(self, parser: blockparser.BlockParser, config: dict[str, Any]):\n        self.border: bool | int = False\n        self.separator: Sequence[str] = ''\n        self.config = config\n\n        super().__init__(parser)\n\n    def test(self, parent: etree.Element, block: str) -> bool:\n        \"\"\"\n        Ensure first two rows (column header and separator row) are valid table rows.\n\n        Keep border check and separator row do avoid repeating the work.\n        \"\"\"\n        is_table = False\n        rows = [row.strip(' ') for row in block.split('\\n')]\n        if len(rows) > 1:\n            header0 = rows[0]\n            self.border = PIPE_NONE\n            if header0.startswith('|'):\n                self.border |= PIPE_LEFT\n            if self.RE_END_BORDER.search(header0) is not None:\n                self.border |= PIPE_RIGHT\n            row = self._split_row(header0)\n            row0_len = len(row)\n            is_table = row0_len > 1\n\n            # Each row in a single column table needs at least one pipe.\n            if not is_table and row0_len == 1 and self.border:\n                for index in range(1, len(rows)):\n                    is_table = rows[index].startswith('|')\n                    if not is_table:\n                        is_table = self.RE_END_BORDER.search(rows[index]) is not None\n                    if not is_table:\n                        break\n\n            if is_table:\n                row = self._split_row(rows[1])\n                is_table = (len(row) == row0_len) and set(''.join(row)) <= set('|:- ')\n                if is_table:\n                    self.separator = row\n\n        return is_table\n\n    def run(self, parent: etree.Element, blocks: list[str]) -> None:\n        \"\"\" Parse a table block and build table. \"\"\"\n        block = blocks.pop(0).split('\\n')\n        header = block[0].strip(' ')\n        rows = [] if len(block) < 3 else block[2:]\n\n        # Get alignment of columns\n        align: list[str | None] = []\n        for c in self.separator:\n            c = c.strip(' ')\n            if c.startswith(':') and c.endswith(':'):\n                align.append('center')\n            elif c.startswith(':'):\n                align.append('left')\n            elif c.endswith(':'):\n                align.append('right')\n            else:\n                align.append(None)\n\n        # Build table\n        table = etree.SubElement(parent, 'table')\n        thead = etree.SubElement(table, 'thead')\n        self._build_row(header, thead, align)\n        tbody = etree.SubElement(table, 'tbody')\n        if len(rows) == 0:\n            # Handle empty table\n            self._build_empty_row(tbody, align)\n        else:\n            for row in rows:\n                self._build_row(row.strip(' '), tbody, align)\n\n    def _build_empty_row(self, parent: etree.Element, align: Sequence[str | None]) -> None:\n        \"\"\"Build an empty row.\"\"\"\n        tr = etree.SubElement(parent, 'tr')\n        count = len(align)\n        while count:\n            etree.SubElement(tr, 'td')\n            count -= 1\n\n    def _build_row(self, row: str, parent: etree.Element, align: Sequence[str | None]) -> None:\n        \"\"\" Given a row of text, build table cells. \"\"\"\n        tr = etree.SubElement(parent, 'tr')\n        tag = 'td'\n        if parent.tag == 'thead':\n            tag = 'th'\n        cells = self._split_row(row)\n        # We use align here rather than cells to ensure every row\n        # contains the same number of columns.\n        for i, a in enumerate(align):\n            c = etree.SubElement(tr, tag)\n            try:\n                c.text = cells[i].strip(' ')\n            except IndexError:  # pragma: no cover\n                c.text = \"\"\n            if a:\n                if self.config['use_align_attribute']:\n                    c.set('align', a)\n                else:\n                    c.set('style', f'text-align: {a};')\n\n    def _split_row(self, row: str) -> list[str]:\n        \"\"\" split a row of text into list of cells. \"\"\"\n        if self.border:\n            if row.startswith('|'):\n                row = row[1:]\n            row = self.RE_END_BORDER.sub('', row)\n        return self._split(row)\n\n    def _split(self, row: str) -> list[str]:\n        \"\"\" split a row of text with some code into a list of cells. \"\"\"\n        elements = []\n        pipes = []\n        tics = []\n        tic_points = []\n        tic_region = []\n        good_pipes = []\n\n        # Parse row\n        # Throw out \\\\, and \\|\n        for m in self.RE_CODE_PIPES.finditer(row):\n            # Store ` data (len, start_pos, end_pos)\n            if m.group(2):\n                # \\`+\n                # Store length of each tic group: subtract \\\n                tics.append(len(m.group(2)) - 1)\n                # Store start of group, end of group, and escape length\n                tic_points.append((m.start(2), m.end(2) - 1, 1))\n            elif m.group(3):\n                # `+\n                # Store length of each tic group\n                tics.append(len(m.group(3)))\n                # Store start of group, end of group, and escape length\n                tic_points.append((m.start(3), m.end(3) - 1, 0))\n            # Store pipe location\n            elif m.group(5):\n                pipes.append(m.start(5))\n\n        # Pair up tics according to size if possible\n        # Subtract the escape length *only* from the opening.\n        # Walk through tic list and see if tic has a close.\n        # Store the tic region (start of region, end of region).\n        pos = 0\n        tic_len = len(tics)\n        while pos < tic_len:\n            try:\n                tic_size = tics[pos] - tic_points[pos][2]\n                if tic_size == 0:\n                    raise ValueError\n                index = tics[pos + 1:].index(tic_size) + 1\n                tic_region.append((tic_points[pos][0], tic_points[pos + index][1]))\n                pos += index + 1\n            except ValueError:\n                pos += 1\n\n        # Resolve pipes.  Check if they are within a tic pair region.\n        # Walk through pipes comparing them to each region.\n        #     - If pipe position is less that a region, it isn't in a region\n        #     - If it is within a region, we don't want it, so throw it out\n        #     - If we didn't throw it out, it must be a table pipe\n        for pipe in pipes:\n            throw_out = False\n            for region in tic_region:\n                if pipe < region[0]:\n                    # Pipe is not in a region\n                    break\n                elif region[0] <= pipe <= region[1]:\n                    # Pipe is within a code region.  Throw it out.\n                    throw_out = True\n                    break\n            if not throw_out:\n                good_pipes.append(pipe)\n\n        # Split row according to table delimiters.\n        pos = 0\n        for pipe in good_pipes:\n            elements.append(row[pos:pipe])\n            pos = pipe + 1\n        elements.append(row[pos:])\n        return elements\n\n\nclass TableExtension(Extension):\n    \"\"\" Add tables to Markdown. \"\"\"\n\n    def __init__(self, **kwargs):\n        self.config = {\n            'use_align_attribute': [False, 'True to use align attribute instead of style.'],\n        }\n        \"\"\" Default configuration options. \"\"\"\n\n        super().__init__(**kwargs)\n\n    def extendMarkdown(self, md):\n        \"\"\" Add an instance of `TableProcessor` to `BlockParser`. \"\"\"\n        if '|' not in md.ESCAPED_CHARS:\n            md.ESCAPED_CHARS.append('|')\n        processor = TableProcessor(md.parser, self.getConfigs())\n        md.parser.blockprocessors.register(processor, 'table', 75)\n\n\ndef makeExtension(**kwargs):  # pragma: no cover\n    return TableExtension(**kwargs)\n","size_bytes":8739},"markdown/extensions/toc.py":{"content":"# Table of Contents Extension for Python-Markdown\n# ===============================================\n\n# See https://Python-Markdown.github.io/extensions/toc\n# for documentation.\n\n# Original code Copyright 2008 [Jack Miller](https://codezen.org/)\n\n# All changes Copyright 2008-2024 The Python Markdown Project\n\n# License: [BSD](https://opensource.org/licenses/bsd-license.php)\n\n\"\"\"\nAdd table of contents support to Python-Markdown.\n\nSee the [documentation](https://Python-Markdown.github.io/extensions/toc)\nfor details.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom . import Extension\nfrom ..treeprocessors import Treeprocessor\nfrom ..util import parseBoolValue, AMP_SUBSTITUTE, deprecated, HTML_PLACEHOLDER_RE, AtomicString\nfrom ..treeprocessors import UnescapeTreeprocessor\nfrom ..serializers import RE_AMP\nimport re\nimport html\nimport unicodedata\nfrom copy import deepcopy\nimport xml.etree.ElementTree as etree\nfrom typing import TYPE_CHECKING, Any, Iterator, MutableSet\n\nif TYPE_CHECKING:  # pragma: no cover\n    from markdown import Markdown\n\n\ndef slugify(value: str, separator: str, unicode: bool = False) -> str:\n    \"\"\" Slugify a string, to make it URL friendly. \"\"\"\n    if not unicode:\n        # Replace Extended Latin characters with ASCII, i.e. `≈ælut√Ω` => `zluty`\n        value = unicodedata.normalize('NFKD', value)\n        value = value.encode('ascii', 'ignore').decode('ascii')\n    value = re.sub(r'[^\\w\\s-]', '', value).strip().lower()\n    return re.sub(r'[{}\\s]+'.format(separator), separator, value)\n\n\ndef slugify_unicode(value: str, separator: str) -> str:\n    \"\"\" Slugify a string, to make it URL friendly while preserving Unicode characters. \"\"\"\n    return slugify(value, separator, unicode=True)\n\n\nIDCOUNT_RE = re.compile(r'^(.*)_([0-9]+)$')\n\n\ndef unique(id: str, ids: MutableSet[str]) -> str:\n    \"\"\" Ensure id is unique in set of ids. Append '_1', '_2'... if not \"\"\"\n    while id in ids or not id:\n        m = IDCOUNT_RE.match(id)\n        if m:\n            id = '%s_%d' % (m.group(1), int(m.group(2))+1)\n        else:\n            id = '%s_%d' % (id, 1)\n    ids.add(id)\n    return id\n\n\n@deprecated('Use `render_inner_html` and `striptags` instead.')\ndef get_name(el: etree.Element) -> str:\n    \"\"\"Get title name.\"\"\"\n\n    text = []\n    for c in el.itertext():\n        if isinstance(c, AtomicString):\n            text.append(html.unescape(c))\n        else:\n            text.append(c)\n    return ''.join(text).strip()\n\n\n@deprecated('Use `run_postprocessors`, `render_inner_html` and/or `striptags` instead.')\ndef stashedHTML2text(text: str, md: Markdown, strip_entities: bool = True) -> str:\n    \"\"\" Extract raw HTML from stash, reduce to plain text and swap with placeholder. \"\"\"\n    def _html_sub(m: re.Match[str]) -> str:\n        \"\"\" Substitute raw html with plain text. \"\"\"\n        try:\n            raw = md.htmlStash.rawHtmlBlocks[int(m.group(1))]\n        except (IndexError, TypeError):  # pragma: no cover\n            return m.group(0)\n        # Strip out tags and/or entities - leaving text\n        res = re.sub(r'(<[^>]+>)', '', raw)\n        if strip_entities:\n            res = re.sub(r'(&[\\#a-zA-Z0-9]+;)', '', res)\n        return res\n\n    return HTML_PLACEHOLDER_RE.sub(_html_sub, text)\n\n\ndef unescape(text: str) -> str:\n    \"\"\" Unescape Markdown backslash escaped text. \"\"\"\n    c = UnescapeTreeprocessor()\n    return c.unescape(text)\n\n\ndef strip_tags(text: str) -> str:\n    \"\"\" Strip HTML tags and return plain text. Note: HTML entities are unaffected. \"\"\"\n    # A comment could contain a tag, so strip comments first\n    while (start := text.find('<!--')) != -1 and (end := text.find('-->', start)) != -1:\n        text = f'{text[:start]}{text[end + 3:]}'\n\n    while (start := text.find('<')) != -1 and (end := text.find('>', start)) != -1:\n        text = f'{text[:start]}{text[end + 1:]}'\n\n    # Collapse whitespace\n    text = ' '.join(text.split())\n    return text\n\n\ndef escape_cdata(text: str) -> str:\n    \"\"\" Escape character data. \"\"\"\n    if \"&\" in text:\n        # Only replace & when not part of an entity\n        text = RE_AMP.sub('&amp;', text)\n    if \"<\" in text:\n        text = text.replace(\"<\", \"&lt;\")\n    if \">\" in text:\n        text = text.replace(\">\", \"&gt;\")\n    return text\n\n\ndef run_postprocessors(text: str, md: Markdown) -> str:\n    \"\"\" Run postprocessors from Markdown instance on text. \"\"\"\n    for pp in md.postprocessors:\n        text = pp.run(text)\n    return text.strip()\n\n\ndef render_inner_html(el: etree.Element, md: Markdown) -> str:\n    \"\"\" Fully render inner html of an `etree` element as a string. \"\"\"\n    # The `UnescapeTreeprocessor` runs after `toc` extension so run here.\n    text = unescape(md.serializer(el))\n\n    # strip parent tag\n    start = text.index('>') + 1\n    end = text.rindex('<')\n    text = text[start:end].strip()\n\n    return run_postprocessors(text, md)\n\n\ndef remove_fnrefs(root: etree.Element) -> etree.Element:\n    \"\"\" Remove footnote references from a copy of the element, if any are present. \"\"\"\n    # Remove footnote references, which look like this: `<sup id=\"fnref:1\">...</sup>`.\n    # If there are no `sup` elements, then nothing to do.\n    if next(root.iter('sup'), None) is None:\n        return root\n    root = deepcopy(root)\n    # Find parent elements that contain `sup` elements.\n    for parent in root.findall('.//sup/..'):\n        carry_text = \"\"\n        for child in reversed(parent):  # Reversed for the ability to mutate during iteration.\n            # Remove matching footnote references but carry any `tail` text to preceding elements.\n            if child.tag == 'sup' and child.get('id', '').startswith('fnref'):\n                carry_text = f'{child.tail or \"\"}{carry_text}'\n                parent.remove(child)\n            elif carry_text:\n                child.tail = f'{child.tail or \"\"}{carry_text}'\n                carry_text = \"\"\n        if carry_text:\n            parent.text = f'{parent.text or \"\"}{carry_text}'\n    return root\n\n\ndef nest_toc_tokens(toc_list):\n    \"\"\"Given an unsorted list with errors and skips, return a nested one.\n\n        [{'level': 1}, {'level': 2}]\n        =>\n        [{'level': 1, 'children': [{'level': 2, 'children': []}]}]\n\n    A wrong list is also converted:\n\n        [{'level': 2}, {'level': 1}]\n        =>\n        [{'level': 2, 'children': []}, {'level': 1, 'children': []}]\n    \"\"\"\n\n    ordered_list = []\n    if len(toc_list):\n        # Initialize everything by processing the first entry\n        last = toc_list.pop(0)\n        last['children'] = []\n        levels = [last['level']]\n        ordered_list.append(last)\n        parents = []\n\n        # Walk the rest nesting the entries properly\n        while toc_list:\n            t = toc_list.pop(0)\n            current_level = t['level']\n            t['children'] = []\n\n            # Reduce depth if current level < last item's level\n            if current_level < levels[-1]:\n                # Pop last level since we know we are less than it\n                levels.pop()\n\n                # Pop parents and levels we are less than or equal to\n                to_pop = 0\n                for p in reversed(parents):\n                    if current_level <= p['level']:\n                        to_pop += 1\n                    else:  # pragma: no cover\n                        break\n                if to_pop:\n                    levels = levels[:-to_pop]\n                    parents = parents[:-to_pop]\n\n                # Note current level as last\n                levels.append(current_level)\n\n            # Level is the same, so append to\n            # the current parent (if available)\n            if current_level == levels[-1]:\n                (parents[-1]['children'] if parents\n                 else ordered_list).append(t)\n\n            # Current level is > last item's level,\n            # So make last item a parent and append current as child\n            else:\n                last['children'].append(t)\n                parents.append(last)\n                levels.append(current_level)\n            last = t\n\n    return ordered_list\n\n\nclass TocTreeprocessor(Treeprocessor):\n    \"\"\" Step through document and build TOC. \"\"\"\n\n    def __init__(self, md: Markdown, config: dict[str, Any]):\n        super().__init__(md)\n\n        self.marker: str = config[\"marker\"]\n        self.title: str = config[\"title\"]\n        self.base_level = int(config[\"baselevel\"]) - 1\n        self.slugify = config[\"slugify\"]\n        self.sep = config[\"separator\"]\n        self.toc_class = config[\"toc_class\"]\n        self.title_class: str = config[\"title_class\"]\n        self.use_anchors: bool = parseBoolValue(config[\"anchorlink\"])\n        self.anchorlink_class: str = config[\"anchorlink_class\"]\n        self.use_permalinks = parseBoolValue(config[\"permalink\"], False)\n        if self.use_permalinks is None:\n            self.use_permalinks = config[\"permalink\"]\n        self.permalink_class: str = config[\"permalink_class\"]\n        self.permalink_title: str = config[\"permalink_title\"]\n        self.permalink_leading: bool | None = parseBoolValue(config[\"permalink_leading\"], False)\n        self.header_rgx = re.compile(\"[Hh][123456]\")\n        if isinstance(config[\"toc_depth\"], str) and '-' in config[\"toc_depth\"]:\n            self.toc_top, self.toc_bottom = [int(x) for x in config[\"toc_depth\"].split('-')]\n        else:\n            self.toc_top = 1\n            self.toc_bottom = int(config[\"toc_depth\"])\n\n    def iterparent(self, node: etree.Element) -> Iterator[tuple[etree.Element, etree.Element]]:\n        \"\"\" Iterator wrapper to get allowed parent and child all at once. \"\"\"\n\n        # We do not allow the marker inside a header as that\n        # would causes an endless loop of placing a new TOC\n        # inside previously generated TOC.\n        for child in node:\n            if not self.header_rgx.match(child.tag) and child.tag not in ['pre', 'code']:\n                yield node, child\n                yield from self.iterparent(child)\n\n    def replace_marker(self, root: etree.Element, elem: etree.Element) -> None:\n        \"\"\" Replace marker with elem. \"\"\"\n        for (p, c) in self.iterparent(root):\n            text = ''.join(c.itertext()).strip()\n            if not text:\n                continue\n\n            # To keep the output from screwing up the\n            # validation by putting a `<div>` inside of a `<p>`\n            # we actually replace the `<p>` in its entirety.\n\n            # The `<p>` element may contain more than a single text content\n            # (`nl2br` can introduce a `<br>`). In this situation, `c.text` returns\n            # the very first content, ignore children contents or tail content.\n            # `len(c) == 0` is here to ensure there is only text in the `<p>`.\n            if c.text and c.text.strip() == self.marker and len(c) == 0:\n                for i in range(len(p)):\n                    if p[i] == c:\n                        p[i] = elem\n                        break\n\n    def set_level(self, elem: etree.Element) -> None:\n        \"\"\" Adjust header level according to base level. \"\"\"\n        level = int(elem.tag[-1]) + self.base_level\n        if level > 6:\n            level = 6\n        elem.tag = 'h%d' % level\n\n    def add_anchor(self, c: etree.Element, elem_id: str) -> None:\n        anchor = etree.Element(\"a\")\n        anchor.text = c.text\n        anchor.attrib[\"href\"] = \"#\" + elem_id\n        anchor.attrib[\"class\"] = self.anchorlink_class\n        c.text = \"\"\n        for elem in c:\n            anchor.append(elem)\n        while len(c):\n            c.remove(c[0])\n        c.append(anchor)\n\n    def add_permalink(self, c: etree.Element, elem_id: str) -> None:\n        permalink = etree.Element(\"a\")\n        permalink.text = (\"%spara;\" % AMP_SUBSTITUTE\n                          if self.use_permalinks is True\n                          else self.use_permalinks)\n        permalink.attrib[\"href\"] = \"#\" + elem_id\n        permalink.attrib[\"class\"] = self.permalink_class\n        if self.permalink_title:\n            permalink.attrib[\"title\"] = self.permalink_title\n        if self.permalink_leading:\n            permalink.tail = c.text\n            c.text = \"\"\n            c.insert(0, permalink)\n        else:\n            c.append(permalink)\n\n    def build_toc_div(self, toc_list: list) -> etree.Element:\n        \"\"\" Return a string div given a toc list. \"\"\"\n        div = etree.Element(\"div\")\n        div.attrib[\"class\"] = self.toc_class\n\n        # Add title to the div\n        if self.title:\n            header = etree.SubElement(div, \"span\")\n            if self.title_class:\n                header.attrib[\"class\"] = self.title_class\n            header.text = self.title\n\n        def build_etree_ul(toc_list: list, parent: etree.Element) -> etree.Element:\n            ul = etree.SubElement(parent, \"ul\")\n            for item in toc_list:\n                # List item link, to be inserted into the toc div\n                li = etree.SubElement(ul, \"li\")\n                link = etree.SubElement(li, \"a\")\n                link.text = item.get('name', '')\n                link.attrib[\"href\"] = '#' + item.get('id', '')\n                if item['children']:\n                    build_etree_ul(item['children'], li)\n            return ul\n\n        build_etree_ul(toc_list, div)\n\n        if 'prettify' in self.md.treeprocessors:\n            self.md.treeprocessors['prettify'].run(div)\n\n        return div\n\n    def run(self, doc: etree.Element) -> None:\n        # Get a list of id attributes\n        used_ids = set()\n        for el in doc.iter():\n            if \"id\" in el.attrib:\n                used_ids.add(el.attrib[\"id\"])\n\n        toc_tokens = []\n        for el in doc.iter():\n            if isinstance(el.tag, str) and self.header_rgx.match(el.tag):\n                self.set_level(el)\n                innerhtml = render_inner_html(remove_fnrefs(el), self.md)\n                name = strip_tags(innerhtml)\n\n                # Do not override pre-existing ids\n                if \"id\" not in el.attrib:\n                    el.attrib[\"id\"] = unique(self.slugify(html.unescape(name), self.sep), used_ids)\n\n                data_toc_label = ''\n                if 'data-toc-label' in el.attrib:\n                    data_toc_label = run_postprocessors(unescape(el.attrib['data-toc-label']), self.md)\n                    # Overwrite name with sanitized value of `data-toc-label`.\n                    name = escape_cdata(strip_tags(data_toc_label))\n                    # Remove the data-toc-label attribute as it is no longer needed\n                    del el.attrib['data-toc-label']\n\n                if int(el.tag[-1]) >= self.toc_top and int(el.tag[-1]) <= self.toc_bottom:\n                    toc_tokens.append({\n                        'level': int(el.tag[-1]),\n                        'id': unescape(el.attrib[\"id\"]),\n                        'name': name,\n                        'html': innerhtml,\n                        'data-toc-label': data_toc_label\n                    })\n\n                if self.use_anchors:\n                    self.add_anchor(el, el.attrib[\"id\"])\n                if self.use_permalinks not in [False, None]:\n                    self.add_permalink(el, el.attrib[\"id\"])\n\n        toc_tokens = nest_toc_tokens(toc_tokens)\n        div = self.build_toc_div(toc_tokens)\n        if self.marker:\n            self.replace_marker(doc, div)\n\n        # serialize and attach to markdown instance.\n        toc = self.md.serializer(div)\n        for pp in self.md.postprocessors:\n            toc = pp.run(toc)\n        self.md.toc_tokens = toc_tokens\n        self.md.toc = toc\n\n\nclass TocExtension(Extension):\n\n    TreeProcessorClass = TocTreeprocessor\n\n    def __init__(self, **kwargs):\n        self.config = {\n            'marker': [\n                '[TOC]',\n                'Text to find and replace with Table of Contents. Set to an empty string to disable. '\n                'Default: `[TOC]`.'\n            ],\n            'title': [\n                '', 'Title to insert into TOC `<div>`. Default: an empty string.'\n            ],\n            'title_class': [\n                'toctitle', 'CSS class used for the title. Default: `toctitle`.'\n            ],\n            'toc_class': [\n                'toc', 'CSS class(es) used for the link. Default: `toclink`.'\n            ],\n            'anchorlink': [\n                False, 'True if header should be a self link. Default: `False`.'\n            ],\n            'anchorlink_class': [\n                'toclink', 'CSS class(es) used for the link. Defaults: `toclink`.'\n            ],\n            'permalink': [\n                0, 'True or link text if a Sphinx-style permalink should be added. Default: `False`.'\n            ],\n            'permalink_class': [\n                'headerlink', 'CSS class(es) used for the link. Default: `headerlink`.'\n            ],\n            'permalink_title': [\n                'Permanent link', 'Title attribute of the permalink. Default: `Permanent link`.'\n            ],\n            'permalink_leading': [\n                False,\n                'True if permalinks should be placed at start of the header, rather than end. Default: False.'\n            ],\n            'baselevel': ['1', 'Base level for headers. Default: `1`.'],\n            'slugify': [\n                slugify, 'Function to generate anchors based on header text. Default: `slugify`.'\n            ],\n            'separator': ['-', 'Word separator. Default: `-`.'],\n            'toc_depth': [\n                6,\n                'Define the range of section levels to include in the Table of Contents. A single integer '\n                '(b) defines the bottom section level (<h1>..<hb>) only. A string consisting of two digits '\n                'separated by a hyphen in between (`2-5`) defines the top (t) and the bottom (b) (<ht>..<hb>). '\n                'Default: `6` (bottom).'\n            ],\n        }\n        \"\"\" Default configuration options. \"\"\"\n\n        super().__init__(**kwargs)\n\n    def extendMarkdown(self, md):\n        \"\"\" Add TOC tree processor to Markdown. \"\"\"\n        md.registerExtension(self)\n        self.md = md\n        self.reset()\n        tocext = self.TreeProcessorClass(md, self.getConfigs())\n        md.treeprocessors.register(tocext, 'toc', 5)\n\n    def reset(self) -> None:\n        self.md.toc = ''\n        self.md.toc_tokens = []\n\n\ndef makeExtension(**kwargs):  # pragma: no cover\n    return TocExtension(**kwargs)\n","size_bytes":18332},"markdown/extensions/wikilinks.py":{"content":"# WikiLinks Extension for Python-Markdown\n# ======================================\n\n# Converts [[WikiLinks]] to relative links.\n\n# See https://Python-Markdown.github.io/extensions/wikilinks\n# for documentation.\n\n# Original code Copyright [Waylan Limberg](http://achinghead.com/).\n\n# All changes Copyright The Python Markdown Project\n\n# License: [BSD](https://opensource.org/licenses/bsd-license.php)\n\n\"\"\"\nConverts `[[WikiLinks]]` to relative links.\n\nSee the [documentation](https://Python-Markdown.github.io/extensions/wikilinks)\nfor details.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom . import Extension\nfrom ..inlinepatterns import InlineProcessor\nimport xml.etree.ElementTree as etree\nimport re\nfrom typing import Any\n\n\ndef build_url(label: str, base: str, end: str) -> str:\n    \"\"\" Build a URL from the label, a base, and an end. \"\"\"\n    clean_label = re.sub(r'([ ]+_)|(_[ ]+)|([ ]+)', '_', label)\n    return '{}{}{}'.format(base, clean_label, end)\n\n\nclass WikiLinkExtension(Extension):\n    \"\"\" Add inline processor to Markdown. \"\"\"\n\n    def __init__(self, **kwargs):\n        self.config = {\n            'base_url': ['/', 'String to append to beginning or URL.'],\n            'end_url': ['/', 'String to append to end of URL.'],\n            'html_class': ['wikilink', 'CSS hook. Leave blank for none.'],\n            'build_url': [build_url, 'Callable formats URL from label.'],\n        }\n        \"\"\" Default configuration options. \"\"\"\n        super().__init__(**kwargs)\n\n    def extendMarkdown(self, md):\n        self.md = md\n\n        # append to end of inline patterns\n        WIKILINK_RE = r'\\[\\[([\\w0-9_ -]+)\\]\\]'\n        wikilinkPattern = WikiLinksInlineProcessor(WIKILINK_RE, self.getConfigs())\n        wikilinkPattern.md = md\n        md.inlinePatterns.register(wikilinkPattern, 'wikilink', 75)\n\n\nclass WikiLinksInlineProcessor(InlineProcessor):\n    \"\"\" Build link from `wikilink`. \"\"\"\n\n    def __init__(self, pattern: str, config: dict[str, Any]):\n        super().__init__(pattern)\n        self.config = config\n\n    def handleMatch(self, m: re.Match[str], data: str) -> tuple[etree.Element | str, int, int]:\n        if m.group(1).strip():\n            base_url, end_url, html_class = self._getMeta()\n            label = m.group(1).strip()\n            url = self.config['build_url'](label, base_url, end_url)\n            a = etree.Element('a')\n            a.text = label\n            a.set('href', url)\n            if html_class:\n                a.set('class', html_class)\n        else:\n            a = ''\n        return a, m.start(0), m.end(0)\n\n    def _getMeta(self) -> tuple[str, str, str]:\n        \"\"\" Return meta data or `config` data. \"\"\"\n        base_url = self.config['base_url']\n        end_url = self.config['end_url']\n        html_class = self.config['html_class']\n        if hasattr(self.md, 'Meta'):\n            if 'wiki_base_url' in self.md.Meta:\n                base_url = self.md.Meta['wiki_base_url'][0]\n            if 'wiki_end_url' in self.md.Meta:\n                end_url = self.md.Meta['wiki_end_url'][0]\n            if 'wiki_html_class' in self.md.Meta:\n                html_class = self.md.Meta['wiki_html_class'][0]\n        return base_url, end_url, html_class\n\n\ndef makeExtension(**kwargs):  # pragma: no cover\n    return WikiLinkExtension(**kwargs)\n","size_bytes":3285},"markdown-3.8.2.dist-info/licenses/LICENSE.md":{"content":"BSD 3-Clause License\n\nCopyright 2007, 2008 The Python Markdown Project (v. 1.7 and later)  \nCopyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b)  \nCopyright 2004 Manfred Stienstra (the original version)\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\n   list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its\n   contributors may be used to endorse or promote products derived from\n   this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n","size_bytes":1650},"migrations/versions/__init__.py":{"content":"","size_bytes":0},"migrations/versions/a861e2bfb112_criar_tabelas_iniciais_do_sistema.py":{"content":"\"\"\"Criar tabelas iniciais do sistema\n\nRevision ID: a861e2bfb112\nRevises: \nCreate Date: 2025-09-05 12:01:19.349431\n\n\"\"\"\nfrom alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision = 'a861e2bfb112'\ndown_revision = None\nbranch_labels = None\ndepends_on = None\n\n\ndef upgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('sector',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('name', sa.String(length=100), nullable=False),\n    sa.PrimaryKeyConstraint('id'),\n    sa.UniqueConstraint('name')\n    )\n    op.create_table('user',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('username', sa.String(length=64), nullable=False),\n    sa.Column('email', sa.String(length=120), nullable=False),\n    sa.Column('password_hash', sa.String(length=128), nullable=False),\n    sa.Column('is_admin', sa.Boolean(), nullable=True),\n    sa.Column('is_ti', sa.Boolean(), nullable=True),\n    sa.Column('ativo', sa.Boolean(), nullable=True),\n    sa.Column('sector_id', sa.Integer(), nullable=True),\n    sa.Column('reset_token', sa.String(length=100), nullable=True),\n    sa.Column('reset_token_expiry', sa.DateTime(), nullable=True),\n    sa.ForeignKeyConstraint(['sector_id'], ['sector.id'], ),\n    sa.PrimaryKeyConstraint('id'),\n    sa.UniqueConstraint('email'),\n    sa.UniqueConstraint('username')\n    )\n    op.create_table('chamado',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('titulo', sa.String(length=120), nullable=False),\n    sa.Column('descricao', sa.Text(), nullable=False),\n    sa.Column('status', sa.String(length=50), nullable=False),\n    sa.Column('prioridade', sa.String(length=50), nullable=False),\n    sa.Column('data_abertura', sa.DateTime(), nullable=False),\n    sa.Column('data_ultima_atualizacao', sa.DateTime(), nullable=True),\n    sa.Column('data_fechamento', sa.DateTime(), nullable=True),\n    sa.Column('solicitante_id', sa.Integer(), nullable=False),\n    sa.Column('setor_id', sa.Integer(), nullable=False),\n    sa.Column('responsavel_ti_id', sa.Integer(), nullable=True),\n    sa.ForeignKeyConstraint(['responsavel_ti_id'], ['user.id'], ),\n    sa.ForeignKeyConstraint(['setor_id'], ['sector.id'], ),\n    sa.ForeignKeyConstraint(['solicitante_id'], ['user.id'], ),\n    sa.PrimaryKeyConstraint('id')\n    )\n    op.create_table('equipment_request',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('description', sa.Text(), nullable=False),\n    sa.Column('patrimony', sa.String(length=50), nullable=True),\n    sa.Column('delivery_date', sa.Date(), nullable=True),\n    sa.Column('return_date', sa.Date(), nullable=True),\n    sa.Column('conference_status', sa.String(length=50), nullable=True),\n    sa.Column('observations', sa.Text(), nullable=True),\n    sa.Column('requester_id', sa.Integer(), nullable=False),\n    sa.Column('received_by_id', sa.Integer(), nullable=True),\n    sa.Column('approved_by_id', sa.Integer(), nullable=True),\n    sa.Column('status', sa.String(length=20), nullable=False),\n    sa.Column('request_date', sa.DateTime(), nullable=False),\n    sa.Column('approval_date', sa.DateTime(), nullable=True),\n    sa.Column('equipment_type', sa.String(length=50), nullable=True),\n    sa.Column('destination_sector', sa.String(length=100), nullable=True),\n    sa.Column('request_reason', sa.Text(), nullable=True),\n    sa.Column('created_at', sa.DateTime(), nullable=False),\n    sa.Column('updated_at', sa.DateTime(), nullable=False),\n    sa.ForeignKeyConstraint(['approved_by_id'], ['user.id'], ),\n    sa.ForeignKeyConstraint(['received_by_id'], ['user.id'], ),\n    sa.ForeignKeyConstraint(['requester_id'], ['user.id'], ),\n    sa.PrimaryKeyConstraint('id')\n    )\n    op.create_table('reminder',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('name', sa.String(length=120), nullable=False),\n    sa.Column('type', sa.String(length=50), nullable=False),\n    sa.Column('due_date', sa.Date(), nullable=False),\n    sa.Column('responsible', sa.String(length=100), nullable=False),\n    sa.Column('frequency', sa.String(length=20), nullable=True),\n    sa.Column('notified', sa.Boolean(), nullable=True),\n    sa.Column('completed', sa.Boolean(), nullable=True),\n    sa.Column('sector_id', sa.Integer(), nullable=True),\n    sa.Column('user_id', sa.Integer(), nullable=True),\n    sa.Column('status', sa.String(length=20), nullable=True),\n    sa.Column('pause_until', sa.Date(), nullable=True),\n    sa.Column('end_date', sa.Date(), nullable=True),\n    sa.Column('created_at', sa.DateTime(), nullable=True),\n    sa.ForeignKeyConstraint(['sector_id'], ['sector.id'], ),\n    sa.ForeignKeyConstraint(['user_id'], ['user.id'], ),\n    sa.PrimaryKeyConstraint('id')\n    )\n    op.create_table('task',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('description', sa.String(length=200), nullable=False),\n    sa.Column('date', sa.Date(), nullable=True),\n    sa.Column('responsible', sa.String(length=100), nullable=False),\n    sa.Column('completed', sa.Boolean(), nullable=True),\n    sa.Column('sector_id', sa.Integer(), nullable=True),\n    sa.Column('user_id', sa.Integer(), nullable=True),\n    sa.ForeignKeyConstraint(['sector_id'], ['sector.id'], ),\n    sa.ForeignKeyConstraint(['user_id'], ['user.id'], ),\n    sa.PrimaryKeyConstraint('id')\n    )\n    op.create_table('tutorial',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('titulo', sa.String(length=150), nullable=False),\n    sa.Column('conteudo', sa.Text(), nullable=False),\n    sa.Column('data_criacao', sa.DateTime(), nullable=False),\n    sa.Column('autor_id', sa.Integer(), nullable=False),\n    sa.Column('categoria', sa.String(length=100), nullable=True),\n    sa.ForeignKeyConstraint(['autor_id'], ['user.id'], ),\n    sa.PrimaryKeyConstraint('id')\n    )\n    op.create_table('comentario_chamado',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('chamado_id', sa.Integer(), nullable=False),\n    sa.Column('usuario_id', sa.Integer(), nullable=False),\n    sa.Column('texto', sa.Text(), nullable=False),\n    sa.Column('data_criacao', sa.DateTime(), nullable=True),\n    sa.Column('tipo', sa.String(length=20), nullable=True),\n    sa.ForeignKeyConstraint(['chamado_id'], ['chamado.id'], ),\n    sa.ForeignKeyConstraint(['usuario_id'], ['user.id'], ),\n    sa.PrimaryKeyConstraint('id')\n    )\n    op.create_table('comentario_tutorial',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('tutorial_id', sa.Integer(), nullable=False),\n    sa.Column('usuario_id', sa.Integer(), nullable=False),\n    sa.Column('texto', sa.Text(), nullable=False),\n    sa.Column('data_criacao', sa.DateTime(), nullable=True),\n    sa.Column('chamado_id', sa.Integer(), nullable=True),\n    sa.ForeignKeyConstraint(['chamado_id'], ['chamado.id'], ),\n    sa.ForeignKeyConstraint(['tutorial_id'], ['tutorial.id'], ),\n    sa.ForeignKeyConstraint(['usuario_id'], ['user.id'], ),\n    sa.PrimaryKeyConstraint('id')\n    )\n    op.create_table('feedback_tutorial',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('tutorial_id', sa.Integer(), nullable=False),\n    sa.Column('usuario_id', sa.Integer(), nullable=False),\n    sa.Column('util', sa.Boolean(), nullable=False),\n    sa.Column('data', sa.DateTime(), nullable=True),\n    sa.ForeignKeyConstraint(['tutorial_id'], ['tutorial.id'], ),\n    sa.ForeignKeyConstraint(['usuario_id'], ['user.id'], ),\n    sa.PrimaryKeyConstraint('id')\n    )\n    op.create_table('tutorial_image',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('tutorial_id', sa.Integer(), nullable=False),\n    sa.Column('filename', sa.String(length=255), nullable=False),\n    sa.Column('upload_date', sa.DateTime(), nullable=True),\n    sa.ForeignKeyConstraint(['tutorial_id'], ['tutorial.id'], ),\n    sa.PrimaryKeyConstraint('id')\n    )\n    op.create_table('visualizacao_tutorial',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('tutorial_id', sa.Integer(), nullable=False),\n    sa.Column('usuario_id', sa.Integer(), nullable=True),\n    sa.Column('data', sa.DateTime(), nullable=True),\n    sa.ForeignKeyConstraint(['tutorial_id'], ['tutorial.id'], ),\n    sa.ForeignKeyConstraint(['usuario_id'], ['user.id'], ),\n    sa.PrimaryKeyConstraint('id')\n    )\n    # ### end Alembic commands ###\n\n\ndef downgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_table('visualizacao_tutorial')\n    op.drop_table('tutorial_image')\n    op.drop_table('feedback_tutorial')\n    op.drop_table('comentario_tutorial')\n    op.drop_table('comentario_chamado')\n    op.drop_table('tutorial')\n    op.drop_table('task')\n    op.drop_table('reminder')\n    op.drop_table('equipment_request')\n    op.drop_table('chamado')\n    op.drop_table('user')\n    op.drop_table('sector')\n    # ### end Alembic commands ###\n","size_bytes":8825},"app/static/js/components.js":{"content":"\n// Sistema de Componentes Reutiliz√°veis\nclass ComponentManager {\n    constructor() {\n        this.components = new Map();\n        this.init();\n    }\n\n    init() {\n        this.registerComponents();\n        this.initializeComponents();\n    }\n\n    registerComponents() {\n        // Toast Notifications\n        this.components.set('toast', {\n            create: (type, title, message, duration = 5000) => {\n                const toastId = `toast-${Date.now()}`;\n                const toastHTML = `\n                    <div id=\"${toastId}\" class=\"toast-modern toast-${type} fade-in\">\n                        <div class=\"d-flex align-items-center\">\n                            <div class=\"me-3\">\n                                ${this.getIcon(type)}\n                            </div>\n                            <div class=\"flex-grow-1\">\n                                <div class=\"fw-bold\">${title}</div>\n                                <div class=\"small text-muted\">${message}</div>\n                            </div>\n                            <button type=\"button\" class=\"btn-close ms-2\" onclick=\"this.closest('.toast-modern').remove()\"></button>\n                        </div>\n                        <div class=\"toast-progress\">\n                            <div class=\"toast-progress-bar\" style=\"animation: progress ${duration}ms linear;\"></div>\n                        </div>\n                    </div>\n                `;\n\n                let container = document.querySelector('.toast-container');\n                if (!container) {\n                    container = document.createElement('div');\n                    container.className = 'toast-container';\n                    document.body.appendChild(container);\n                }\n\n                container.insertAdjacentHTML('beforeend', toastHTML);\n\n                // Auto remove\n                setTimeout(() => {\n                    const toast = document.getElementById(toastId);\n                    if (toast) {\n                        toast.style.animation = 'slideOutRight 0.3s ease-in';\n                        setTimeout(() => toast.remove(), 300);\n                    }\n                }, duration);\n\n                return toastId;\n            }\n        });\n\n        // Modal Component\n        this.components.set('modal', {\n            create: (title, content, options = {}) => {\n                const modalId = `modal-${Date.now()}`;\n                const modalHTML = `\n                    <div class=\"modal fade\" id=\"${modalId}\" tabindex=\"-1\">\n                        <div class=\"modal-dialog modal-lg\">\n                            <div class=\"modal-content modern-card\">\n                                <div class=\"modal-header modern-card-header\">\n                                    <h5 class=\"modal-title\">${title}</h5>\n                                    <button type=\"button\" class=\"btn-close btn-close-white\" data-bs-dismiss=\"modal\"></button>\n                                </div>\n                                <div class=\"modal-body p-4\">\n                                    ${content}\n                                </div>\n                                ${options.showFooter !== false ? `\n                                <div class=\"modal-footer\">\n                                    <button type=\"button\" class=\"btn btn-secondary\" data-bs-dismiss=\"modal\">Fechar</button>\n                                    ${options.primaryButton || ''}\n                                </div>\n                                ` : ''}\n                            </div>\n                        </div>\n                    </div>\n                `;\n\n                document.body.insertAdjacentHTML('beforeend', modalHTML);\n                const modal = new bootstrap.Modal(document.getElementById(modalId));\n                \n                // Cleanup on hide\n                document.getElementById(modalId).addEventListener('hidden.bs.modal', function() {\n                    this.remove();\n                });\n\n                return modal;\n            }\n        });\n\n        // Loading Overlay\n        this.components.set('loading', {\n            show: (message = 'Carregando...') => {\n                const loadingHTML = `\n                    <div id=\"loading-overlay\" class=\"position-fixed top-0 start-0 w-100 h-100 d-flex align-items-center justify-content-center\" style=\"background: rgba(0,0,0,0.5); z-index: 9999;\">\n                        <div class=\"modern-card p-4 text-center\">\n                            <div class=\"loading-spinner mb-3\"></div>\n                            <div>${message}</div>\n                        </div>\n                    </div>\n                `;\n                document.body.insertAdjacentHTML('beforeend', loadingHTML);\n            },\n            hide: () => {\n                const overlay = document.getElementById('loading-overlay');\n                if (overlay) overlay.remove();\n            }\n        });\n\n        // Confirmation Dialog\n        this.components.set('confirm', {\n            show: (title, message, onConfirm, onCancel = null) => {\n                const content = `\n                    <div class=\"text-center\">\n                        <i class=\"fas fa-question-circle text-warning fs-1 mb-3\"></i>\n                        <p class=\"mb-0\">${message}</p>\n                    </div>\n                `;\n                \n                const modal = this.components.get('modal').create(title, content, {\n                    primaryButton: `\n                        <button type=\"button\" class=\"btn btn-danger\" id=\"confirm-yes\">Sim, confirmar</button>\n                    `\n                });\n\n                modal.show();\n\n                // Event listeners\n                document.getElementById('confirm-yes').addEventListener('click', () => {\n                    modal.hide();\n                    if (onConfirm) onConfirm();\n                });\n\n                if (onCancel) {\n                    document.querySelector('[data-bs-dismiss=\"modal\"]').addEventListener('click', onCancel);\n                }\n            }\n        });\n    }\n\n    getIcon(type) {\n        const icons = {\n            success: '<i class=\"fas fa-check-circle text-success\"></i>',\n            error: '<i class=\"fas fa-times-circle text-danger\"></i>',\n            warning: '<i class=\"fas fa-exclamation-triangle text-warning\"></i>',\n            info: '<i class=\"fas fa-info-circle text-info\"></i>'\n        };\n        return icons[type] || icons.info;\n    }\n\n    initializeComponents() {\n        // Auto-initialize existing elements\n        this.initDatePickers();\n        this.initFormValidation();\n        this.initTableSearch();\n        this.initTooltips();\n    }\n\n    initDatePickers() {\n        // Modern date picker styling\n        document.querySelectorAll('input[type=\"date\"]').forEach(input => {\n            input.classList.add('form-control-modern');\n        });\n    }\n\n    initFormValidation() {\n        // Real-time form validation\n        document.querySelectorAll('form').forEach(form => {\n            form.addEventListener('submit', function(e) {\n                const requiredFields = this.querySelectorAll('[required]');\n                let isValid = true;\n\n                requiredFields.forEach(field => {\n                    if (!field.value.trim()) {\n                        field.classList.add('is-invalid');\n                        isValid = false;\n                    } else {\n                        field.classList.remove('is-invalid');\n                    }\n                });\n\n                if (!isValid) {\n                    e.preventDefault();\n                    components.get('toast').create('error', 'Erro', 'Preencha todos os campos obrigat√≥rios');\n                }\n            });\n        });\n    }\n\n    initTableSearch() {\n        // Live table search\n        document.querySelectorAll('[data-table-search]').forEach(input => {\n            const tableId = input.getAttribute('data-table-search');\n            const table = document.getElementById(tableId);\n            \n            if (table) {\n                input.addEventListener('input', function() {\n                    const searchTerm = this.value.toLowerCase();\n                    const rows = table.querySelectorAll('tbody tr');\n                    \n                    rows.forEach(row => {\n                        const text = row.textContent.toLowerCase();\n                        row.style.display = text.includes(searchTerm) ? '' : 'none';\n                    });\n                });\n            }\n        });\n    }\n\n    initTooltips() {\n        // Initialize Bootstrap tooltips\n        const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle=\"tooltip\"]'));\n        tooltipTriggerList.map(function (tooltipTriggerEl) {\n            return new bootstrap.Tooltip(tooltipTriggerEl);\n        });\n    }\n\n    // Public API\n    get(componentName) {\n        return this.components.get(componentName);\n    }\n\n    toast(type, title, message, duration) {\n        return this.get('toast').create(type, title, message, duration);\n    }\n\n    modal(title, content, options) {\n        return this.get('modal').create(title, content, options);\n    }\n\n    loading(show = true, message) {\n        if (show) {\n            this.get('loading').show(message);\n        } else {\n            this.get('loading').hide();\n        }\n    }\n\n    confirm(title, message, onConfirm, onCancel) {\n        return this.get('confirm').show(title, message, onConfirm, onCancel);\n    }\n}\n\n// CSS adicional para progress bar\nconst additionalCSS = `\n    @keyframes progress {\n        from { width: 100%; }\n        to { width: 0%; }\n    }\n    \n    .toast-progress {\n        position: absolute;\n        bottom: 0;\n        left: 0;\n        width: 100%;\n        height: 3px;\n        background: rgba(0,0,0,0.1);\n        border-radius: 0 0 12px 12px;\n    }\n    \n    .toast-progress-bar {\n        height: 100%;\n        background: currentColor;\n        border-radius: 0 0 12px 12px;\n        opacity: 0.6;\n    }\n    \n    @keyframes slideOutRight {\n        to {\n            opacity: 0;\n            transform: translateX(100%);\n        }\n    }\n`;\n\n// Inject CSS\nconst style = document.createElement('style');\nstyle.textContent = additionalCSS;\ndocument.head.appendChild(style);\n\n// Global instance\nwindow.components = new ComponentManager();\n\n// Export for modules\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = ComponentManager;\n}\n","size_bytes":10453},"app/static/js/notifications.js":{"content":"\nclass NotificationManager {\n    constructor() {\n        this.isSupported = 'Notification' in window;\n        this.permission = null;\n        this.checkInterval = 60000; // 1 minuto\n        this.serviceWorkerRegistration = null;\n        this.init();\n    }\n\n    async init() {\n        if (!this.isSupported) {\n            console.warn('Notifica√ß√µes n√£o s√£o suportadas neste navegador');\n            return;\n        }\n\n        // Registrar o Service Worker antes de solicitar permiss√£o\n        await this.registerServiceWorker();\n\n        this.permission = await this.requestPermission();\n        console.log(`Status da permiss√£o de notifica√ß√µes: ${this.permission}`);\n        \n        if (this.permission === 'granted') {\n            this.startPolling();\n            // Mostrar notifica√ß√£o de confirma√ß√£o\n            setTimeout(() => {\n                this.notify('success', 'Notifica√ß√µes Ativadas', 'Voc√™ receber√° notifica√ß√µes sobre lembretes, tarefas e chamados.');\n            }, 2000);\n        } else {\n            // Informar o usu√°rio sobre como habilitar notifica√ß√µes\n            console.warn('Permiss√£o para notifica√ß√µes negada pelo usu√°rio');\n            // Adicionar um elemento na interface para informar o usu√°rio\n            this.showPermissionMessage();\n            \n            // Adicionar bot√£o para tentar novamente\n            this.addRetryButton();\n        }\n    }\n    \n    async registerServiceWorker() {\n        if (!('serviceWorker' in navigator)) {\n            console.warn('Service Worker n√£o √© suportado neste navegador');\n            return false;\n        }\n        \n        try {\n            // Verificar se j√° existe um service worker registrado\n            const registrations = await navigator.serviceWorker.getRegistrations();\n            \n            if (registrations.length > 0) {\n                // Verificar se algum dos registros √© para o nosso SW\n                const swRegistration = registrations.find(reg => \n                    reg.scope.includes(window.location.origin));\n                \n                if (swRegistration) {\n                    console.log('Service Worker j√° registrado:', swRegistration);\n                    this.serviceWorkerRegistration = swRegistration;\n                    return true;\n                }\n            }\n            \n            // Se n√£o houver service worker registrado, registrar novamente\n            console.log('Registrando Service Worker...');\n            const registration = await navigator.serviceWorker.register('/static/sw.js');\n            console.log('Service Worker registrado com sucesso:', registration);\n            this.serviceWorkerRegistration = registration;\n            \n            // Verificar se o SW est√° ativo\n            if (registration.active) {\n                console.log('Service Worker est√° ativo');\n            } else {\n                console.log('Service Worker est√° instalando/esperando');\n                // Esperar at√© que o SW esteja ativo\n                registration.addEventListener('updatefound', () => {\n                    const newWorker = registration.installing;\n                    newWorker.addEventListener('statechange', () => {\n                        console.log('Service Worker mudou de estado para:', newWorker.state);\n                    });\n                });\n            }\n            \n            return true;\n        } catch (error) {\n            console.error('Erro ao registrar Service Worker:', error);\n            return false;\n        }\n    }\n    \n    showPermissionMessage() {\n        // Verificar se j√° existe uma mensagem\n        if (document.querySelector('.notification-permission-message')) {\n            return;\n        }\n        \n        // Criar elemento de mensagem\n        const messageContainer = document.createElement('div');\n        messageContainer.className = 'notification-permission-message alert alert-warning alert-dismissible fade show';\n        messageContainer.style.position = 'fixed';\n        messageContainer.style.bottom = '20px';\n        messageContainer.style.right = '20px';\n        messageContainer.style.maxWidth = '350px';\n        messageContainer.style.zIndex = '9999';\n        \n        messageContainer.innerHTML = `\n            <h5><i class=\"fas fa-bell-slash\"></i> Notifica√ß√µes Desativadas</h5>\n            <p>Para receber alertas sobre lembretes, tarefas e chamados, habilite as notifica√ß√µes nas configura√ß√µes do navegador.</p>\n            <div class=\"mt-2 d-flex gap-2\">\n                <button type=\"button\" class=\"btn btn-sm btn-primary retry-notifications\">Tentar Novamente</button>\n                <button type=\"button\" class=\"btn btn-sm btn-outline-secondary test-notifications\">Testar Notifica√ß√µes</button>\n            </div>\n            <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"alert\" aria-label=\"Fechar\"></button>\n        `;\n        \n        document.body.appendChild(messageContainer);\n        \n        // Adicionar listener para o bot√£o de teste\n        const testButton = messageContainer.querySelector('.test-notifications');\n        if (testButton) {\n            testButton.addEventListener('click', () => {\n                this.testNotification();\n            });\n        }\n    }\n    \n    addRetryButton() {\n        // Aguardar um momento para garantir que a mensagem foi adicionada ao DOM\n        setTimeout(() => {\n            const retryButton = document.querySelector('.retry-notifications');\n            if (retryButton) {\n                retryButton.addEventListener('click', async () => {\n                    // Remover a mensagem atual\n                    const messageContainer = document.querySelector('.notification-permission-message');\n                    if (messageContainer) {\n                        messageContainer.remove();\n                    }\n                    \n                    // Solicitar permiss√£o novamente\n                    this.permission = await this.requestPermission();\n                    \n                    if (this.permission === 'granted') {\n                        this.startPolling();\n                        this.notify('success', 'Notifica√ß√µes Ativadas', 'Voc√™ receber√° notifica√ß√µes sobre lembretes, tarefas e chamados.');\n                        // Testar notifica√ß√£o automaticamente\n                        setTimeout(() => {\n                            this.testNotification();\n                        }, 3000);\n                    } else {\n                        this.showPermissionMessage();\n                        this.addRetryButton();\n                    }\n                });\n            }\n            \n            // J√° adicionamos o listener para o bot√£o de teste no m√©todo showPermissionMessage\n        }, 500);\n    }\n\n    async requestPermission() {\n        try {\n            if (Notification.permission === 'granted') {\n                console.log('Permiss√£o para notifica√ß√µes j√° concedida');\n                return 'granted';\n            }\n\n            // Mesmo que a permiss√£o tenha sido negada anteriormente, vamos tentar solicitar novamente\n            // Isso permite que o usu√°rio mude de ideia se j√° negou antes\n            console.log('Solicitando permiss√£o para notifica√ß√µes...');\n            const permission = await Notification.requestPermission();\n            console.log(`Resultado da solicita√ß√£o de permiss√£o: ${permission}`);\n            \n            // Se a permiss√£o foi concedida, verificar o registro do service worker\n            if (permission === 'granted' && 'serviceWorker' in navigator) {\n                try {\n                    const registration = await navigator.serviceWorker.ready;\n                    console.log('Service Worker pronto para notifica√ß√µes:', registration);\n                } catch (swError) {\n                    console.error('Erro ao verificar Service Worker:', swError);\n                    // Tentar registrar novamente o service worker\n                    await navigator.serviceWorker.register('/static/sw.js');\n                }\n            }\n            \n            return permission;\n        } catch (error) {\n            console.error('Erro ao solicitar permiss√£o para notifica√ß√µes:', error);\n            return 'denied';\n        }\n    }\n\n    async showNotification(title, options = {}) {\n        if (this.permission !== 'granted') {\n            console.log('Tentando solicitar permiss√£o para notifica√ß√µes novamente...');\n            this.permission = await this.requestPermission();\n            if (this.permission !== 'granted') {\n                console.warn('Permiss√£o para notifica√ß√µes n√£o concedida');\n                this.showPermissionMessage();\n                return null;\n            }\n        }\n        \n        try {\n            // Verificar se o Service Worker est√° dispon√≠vel e registrado\n            if ('serviceWorker' in navigator && 'PushManager' in window) {\n                // Usar o Service Worker registrado na propriedade serviceWorkerRegistration\n                if (this.serviceWorkerRegistration) {\n                    // Tentar usar o Service Worker para mostrar a notifica√ß√£o\n                    await this.serviceWorkerRegistration.showNotification(title, {\n                        icon: '/static/favicon.ico',\n                        badge: '/static/favicon.ico',\n                        vibrate: [100, 50, 100],\n                        requireInteraction: options.requireInteraction || false,\n                        actions: [\n                            {\n                                action: 'view',\n                                title: 'Ver Detalhes'\n                            }\n                        ],\n                        ...options\n                    });\n                    \n                    console.log('Notifica√ß√£o exibida via Service Worker registrado:', title);\n                    return true;\n                } else {\n                    // Tentar obter o Service Worker pronto\n                    console.log('Service Worker n√£o registrado, tentando obter o pronto...');\n                    const registration = await navigator.serviceWorker.ready;\n                    this.serviceWorkerRegistration = registration;\n                    \n                    // Tentar usar o Service Worker para mostrar a notifica√ß√£o\n                    await registration.showNotification(title, {\n                        icon: '/static/favicon.ico',\n                        badge: '/static/favicon.ico',\n                        vibrate: [100, 50, 100],\n                        requireInteraction: options.requireInteraction || false,\n                        actions: [\n                            {\n                                action: 'view',\n                                title: 'Ver Detalhes'\n                            }\n                        ],\n                        ...options\n                    });\n                    \n                    console.log('Notifica√ß√£o exibida via Service Worker:', title);\n                    return true;\n                }\n            } else {\n                // Fallback para a API de Notifica√ß√£o padr√£o\n                const notification = new Notification(title, {\n                    icon: '/static/favicon.ico',\n                    badge: '/static/favicon.ico',\n                    ...options\n                });\n\n                // Auto fechar ap√≥s 10 segundos\n                setTimeout(() => {\n                    notification.close();\n                }, 10000);\n\n                console.log('Notifica√ß√£o exibida via API padr√£o:', title);\n                return notification;\n            }\n        } catch (error) {\n            console.error('Erro ao exibir notifica√ß√£o:', error);\n            // Tentar registrar o Service Worker novamente\n            try {\n                await this.registerServiceWorker();\n                console.log('Service Worker registrado novamente ap√≥s erro');\n                return null;\n            } catch (swError) {\n                console.error('Erro ao registrar Service Worker ap√≥s falha na notifica√ß√£o:', swError);\n                return null;\n            }\n        }\n    }\n    \n    // M√©todo para testar as notifica√ß√µes\n    async testNotification() {\n        const result = await this.showNotification('üß™ Teste de Notifica√ß√£o', {\n            body: 'Se voc√™ est√° vendo esta mensagem, as notifica√ß√µes est√£o funcionando corretamente!',\n            tag: 'test-notification',\n            requireInteraction: true\n        });\n        \n        if (result) {\n            console.log('Teste de notifica√ß√£o enviado com sucesso');\n            return true;\n        } else {\n            console.warn('Falha no teste de notifica√ß√£o');\n            return false;\n        }\n    }\n\n    async checkForUpdates() {\n        try {\n            // Verificar se o usu√°rio est√° online\n            if (!navigator.onLine) {\n                console.log('Usu√°rio est√° offline, pulando verifica√ß√£o de notifica√ß√µes');\n                return;\n            }\n            \n            // Verificar se temos permiss√£o para notifica√ß√µes\n            if (this.permission !== 'granted') {\n                console.log('Permiss√£o para notifica√ß√µes n√£o concedida, tentando solicitar novamente...');\n                this.permission = await this.requestPermission();\n                \n                if (this.permission !== 'granted') {\n                    console.log('Permiss√£o para notifica√ß√µes ainda n√£o concedida, pulando verifica√ß√£o');\n                    return;\n                }\n            }\n            \n            // Garantir que o Service Worker esteja registrado\n            if (!this.serviceWorkerRegistration) {\n                await this.registerServiceWorker();\n            }\n            \n            const response = await fetch('/api/notifications', {\n                method: 'GET',\n                headers: {\n                    'Cache-Control': 'no-cache',\n                    'Pragma': 'no-cache'\n                },\n                credentials: 'same-origin'\n            });\n            \n            if (!response.ok) {\n                // Se o erro for 401 ou 403, o usu√°rio n√£o est√° autenticado\n                if (response.status === 401 || response.status === 403) {\n                    console.log('Usu√°rio n√£o autenticado, redirecionando para login...');\n                    // Opcional: redirecionar para a p√°gina de login\n                    // window.location.href = '/login';\n                    return;\n                }\n                throw new Error(`Erro na resposta da API: ${response.status} ${response.statusText}`);\n            }\n            \n            let data;\n            try {\n                const responseText = await response.text();\n                data = JSON.parse(responseText);\n            } catch (parseError) {\n                console.error('Erro ao analisar JSON:', parseError);\n                return;\n            }\n            \n            // Verificar se h√° erro de autentica√ß√£o\n            if (data.error === 'N√£o autenticado') {\n                // Usu√°rio n√£o est√° autenticado, n√£o mostrar notifica√ß√µes\n                return;\n            }\n\n            // Verificar se h√° notifica√ß√µes para exibir\n            const hasNotifications = \n                (data.reminders_expiring && data.reminders_expiring.length > 0) ||\n                (data.chamados_updated && data.chamados_updated.length > 0) ||\n                (data.tasks_overdue && data.tasks_overdue.length > 0);\n                \n            if (!hasNotifications) {\n                console.log('Nenhuma notifica√ß√£o para exibir');\n                return;\n            }\n\n            // Lembretes vencendo\n            if (data.reminders_expiring && data.reminders_expiring.length > 0) {\n                console.log(`${data.reminders_expiring.length} lembretes vencendo em breve`);\n                for (const reminder of data.reminders_expiring) {\n                    await this.showNotification('üîî Lembrete Vencendo!', {\n                        body: `${reminder.name} - Respons√°vel: ${reminder.responsible}`,\n                        tag: `reminder-${reminder.id}`,\n                        data: {\n                            url: `/reminders?highlight=${reminder.id}`,\n                            id: reminder.id\n                        },\n                        requireInteraction: true\n                    });\n                }\n            }\n\n            // Chamados atualizados\n            if (data.chamados_updated && data.chamados_updated.length > 0) {\n                console.log(`${data.chamados_updated.length} chamados atualizados recentemente`);\n                for (const chamado of data.chamados_updated) {\n                    await this.showNotification('üìû Chamado Atualizado!', {\n                        body: `#${chamado.id} - ${chamado.titulo}`,\n                        tag: `chamado-${chamado.id}`,\n                        data: {\n                            url: `/chamados/detalhe/${chamado.id}`,\n                            id: chamado.id\n                        },\n                        requireInteraction: true\n                    });\n                }\n            }\n\n            // Tarefas vencidas\n            if (data.tasks_overdue && data.tasks_overdue.length > 0) {\n                console.log(`${data.tasks_overdue.length} tarefas em atraso`);\n                await this.showNotification('‚ö†Ô∏è Tarefas Vencidas!', {\n                    body: `${data.tasks_overdue.length} tarefa(s) em atraso`,\n                    tag: 'tasks-overdue',\n                    data: {\n                        url: '/tasks?filter=overdue'\n                    },\n                    requireInteraction: true\n                });\n            }\n\n            console.log('Verifica√ß√£o de notifica√ß√µes conclu√≠da com sucesso');\n\n        } catch (error) {\n            console.error('Erro ao verificar notifica√ß√µes:', error);\n            \n            // Se houver erro de conex√£o, tentar novamente mais tarde\n            if (error.name === 'TypeError' && error.message.includes('Failed to fetch')) {\n                console.log('Erro de conex√£o, tentando novamente em 30 segundos...');\n                setTimeout(() => this.checkForUpdates(), 30000);\n            }\n        }\n    }\n\n    startPolling() {\n        // Verifica√ß√£o inicial\n        this.checkForUpdates();\n\n        // Verifica√ß√£o peri√≥dica\n        this.pollingInterval = setInterval(() => {\n            this.checkForUpdates();\n        }, this.checkInterval);\n        \n        // Adicionar listeners para eventos de conectividade\n        window.addEventListener('online', () => {\n            console.log('Conex√£o restaurada, verificando notifica√ß√µes...');\n            this.checkForUpdates();\n        });\n        \n        // Registrar para eventos de visibilidade da p√°gina\n        document.addEventListener('visibilitychange', () => {\n            if (document.visibilityState === 'visible') {\n                console.log('P√°gina vis√≠vel, verificando notifica√ß√µes...');\n                this.checkForUpdates();\n            }\n        });\n    }\n\n    // M√©todo para mostrar notifica√ß√£o manual\n    notify(type, title, message) {\n        const icons = {\n            success: '‚úÖ',\n            warning: '‚ö†Ô∏è',\n            error: '‚ùå',\n            info: '‚ÑπÔ∏è'\n        };\n\n        this.showNotification(`${icons[type]} ${title}`, {\n            body: message,\n            tag: `manual-${Date.now()}`\n        });\n    }\n}\n\n// Inicializar quando a p√°gina carregar\ndocument.addEventListener('DOMContentLoaded', function() {\n    window.notificationManager = new NotificationManager();\n});\n","size_bytes":19706},"app/static/js/offline-support.js":{"content":"\nclass OfflineManager {\n    constructor() {\n        this.isOnline = navigator.onLine;\n        this.pendingData = new Map();\n        this.init();\n    }\n\n    init() {\n        // Listeners de conectividade\n        window.addEventListener('online', () => {\n            this.isOnline = true;\n            this.showConnectionStatus('online');\n            this.syncPendingData();\n        });\n\n        window.addEventListener('offline', () => {\n            this.isOnline = false;\n            this.showConnectionStatus('offline');\n        });\n\n        // Interceptar formul√°rios para cache offline\n        this.interceptForms();\n        \n        // Mostrar status inicial\n        if (!this.isOnline) {\n            this.showConnectionStatus('offline');\n        }\n    }\n\n    showConnectionStatus(status) {\n        const message = status === 'online' \n            ? { type: 'success', title: 'Conectado', message: 'Conex√£o restaurada!' }\n            : { type: 'warning', title: 'Offline', message: 'Trabalhando offline. Dados ser√£o sincronizados quando voltar a conex√£o.' };\n\n        if (window.components) {\n            window.components.toast(message.type, message.title, message.message);\n        }\n\n        // Badge visual no topo da p√°gina\n        this.updateConnectionBadge(status);\n    }\n\n    updateConnectionBadge(status) {\n        let badge = document.getElementById('connection-status');\n        \n        if (!badge) {\n            badge = document.createElement('div');\n            badge.id = 'connection-status';\n            badge.style.cssText = `\n                position: fixed;\n                top: 10px;\n                right: 10px;\n                z-index: 9999;\n                padding: 8px 16px;\n                border-radius: 20px;\n                font-size: 12px;\n                font-weight: bold;\n                text-transform: uppercase;\n                letter-spacing: 0.5px;\n                transition: all 0.3s ease;\n            `;\n            document.body.appendChild(badge);\n        }\n\n        if (status === 'offline') {\n            badge.textContent = 'üî¥ Offline';\n            badge.style.background = 'rgba(220, 53, 69, 0.9)';\n            badge.style.color = 'white';\n            badge.style.display = 'block';\n        } else {\n            badge.textContent = 'üü¢ Online';\n            badge.style.background = 'rgba(25, 135, 84, 0.9)';\n            badge.style.color = 'white';\n            badge.style.display = 'block';\n            \n            // Auto-hide ap√≥s 3 segundos\n            setTimeout(() => {\n                badge.style.display = 'none';\n            }, 3000);\n        }\n    }\n\n    interceptForms() {\n        document.addEventListener('submit', (e) => {\n            const form = e.target;\n            \n            // Apenas para formul√°rios de cria√ß√£o/edi√ß√£o\n            if (form.method.toLowerCase() === 'post' && !this.isOnline) {\n                e.preventDefault();\n                this.storeFormData(form);\n                \n                if (window.components) {\n                    window.components.toast('info', 'Dados Salvos', 'Formul√°rio salvo offline. Ser√° enviado quando a conex√£o for restaurada.');\n                }\n            }\n        });\n    }\n\n    storeFormData(form) {\n        const formData = new FormData(form);\n        const data = Object.fromEntries(formData.entries());\n        const timestamp = Date.now();\n        const key = `form_${form.action}_${timestamp}`;\n\n        // Armazenar no localStorage\n        const pendingForms = JSON.parse(localStorage.getItem('pendingForms') || '[]');\n        pendingForms.push({\n            key,\n            action: form.action,\n            method: form.method,\n            data,\n            timestamp\n        });\n        \n        localStorage.setItem('pendingForms', JSON.stringify(pendingForms));\n        \n        this.pendingData.set(key, {\n            action: form.action,\n            method: form.method,\n            data,\n            timestamp\n        });\n    }\n\n    async syncPendingData() {\n        const pendingForms = JSON.parse(localStorage.getItem('pendingForms') || '[]');\n        \n        if (pendingForms.length === 0) return;\n\n        let syncCount = 0;\n        const errors = [];\n\n        for (const formData of pendingForms) {\n            try {\n                const response = await fetch(formData.action, {\n                    method: formData.method,\n                    headers: {\n                        'Content-Type': 'application/x-www-form-urlencoded',\n                    },\n                    body: new URLSearchParams(formData.data)\n                });\n\n                if (response.ok) {\n                    syncCount++;\n                    // Remover do localStorage\n                    const remaining = pendingForms.filter(f => f.key !== formData.key);\n                    localStorage.setItem('pendingForms', JSON.stringify(remaining));\n                } else {\n                    errors.push(`Erro ao sincronizar formul√°rio: ${response.status}`);\n                }\n            } catch (error) {\n                errors.push(`Erro de rede: ${error.message}`);\n            }\n        }\n\n        // Mostrar resultados\n        if (syncCount > 0) {\n            if (window.components) {\n                window.components.toast('success', 'Sincroniza√ß√£o', `${syncCount} formul√°rio(s) sincronizado(s) com sucesso!`);\n            }\n        }\n\n        if (errors.length > 0) {\n            console.error('Erros de sincroniza√ß√£o:', errors);\n        }\n    }\n\n    // API p√∫blica\n    getPendingCount() {\n        const pending = JSON.parse(localStorage.getItem('pendingForms') || '[]');\n        return pending.length;\n    }\n\n    clearPendingData() {\n        localStorage.removeItem('pendingForms');\n        this.pendingData.clear();\n    }\n}\n\n// Inicializar quando a p√°gina carregar\ndocument.addEventListener('DOMContentLoaded', () => {\n    window.offlineManager = new OfflineManager();\n});\n","size_bytes":5934},"migrations/versions/b91b0d7d62b4_adicionar_campos_de_sla_ao_sistema_de_.py":{"content":"\"\"\"Adicionar campos de SLA ao sistema de chamados\n\nRevision ID: b91b0d7d62b4\nRevises: a861e2bfb112\nCreate Date: 2025-09-05 12:35:36.010970\n\n\"\"\"\nfrom alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision = 'b91b0d7d62b4'\ndown_revision = 'a861e2bfb112'\nbranch_labels = None\ndepends_on = None\n\n\ndef upgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('sla_config',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('prioridade', sa.String(length=50), nullable=False),\n    sa.Column('tempo_resposta_horas', sa.Integer(), nullable=False),\n    sa.Column('tempo_resolucao_horas', sa.Integer(), nullable=True),\n    sa.Column('ativo', sa.Boolean(), nullable=True),\n    sa.PrimaryKeyConstraint('id'),\n    sa.UniqueConstraint('prioridade')\n    )\n    with op.batch_alter_table('chamado', schema=None) as batch_op:\n        batch_op.add_column(sa.Column('prazo_sla', sa.DateTime(), nullable=True))\n        batch_op.add_column(sa.Column('data_primeira_resposta', sa.DateTime(), nullable=True))\n        batch_op.add_column(sa.Column('sla_cumprido', sa.Boolean(), nullable=True))\n        batch_op.add_column(sa.Column('tempo_resposta_horas', sa.Float(), nullable=True))\n\n    # ### end Alembic commands ###\n\n\ndef downgrade():\n    # ### commands auto generated by Alembic - please adjust! ###\n    with op.batch_alter_table('chamado', schema=None) as batch_op:\n        batch_op.drop_column('tempo_resposta_horas')\n        batch_op.drop_column('sla_cumprido')\n        batch_op.drop_column('data_primeira_resposta')\n        batch_op.drop_column('prazo_sla')\n\n    op.drop_table('sla_config')\n    # ### end Alembic commands ###\n","size_bytes":1704}},"version":1}